# Example

# **The Real-World Scenario: "The Gourmet Pizza Shop"**

- Let's ignore user interfaces and databases for a moment. Imagine we are standing in the kitchen of a Pizza shop.
    - **The Use Case:**
        - A customer places an order for a custom pizza.
    - **The Rules (Invariants):**
        1. An order must have a delivery address.
        2. You cannot add items to an order once it has been "Confirmed."
        3. You cannot cancel an order once it is "Cooking."

---

# **1. Strategic Design (The Big Picture)**

- Before writing code, we must agree on the **Ubiquitous Language**. This is the dictionary shared by developers and business experts.
    - **Bad Language:** "Insert record into Order table with Status ID 2."
    - **Ubiquitous Language:** "Confirm the Order."

---

# **2. Tactical Design (Breaking it Down)**

- In DDD, we categorize our C# classes into specific types based on their job.
    - **A. Value Objects**
        - These are small objects that hold data but no identity. If you swap two $5 bills, it doesn't matter; the value is the same.
            - **Example:** Address. If two customers have the same address data, it's the same location.
    - **B. Entities**
        - These objects have a distinct identity (ID). Even if their data changes (e.g., a person changes their name), they remain the same object.
            - **Example:** Customer.
    - **C. Aggregates (The Most Important Part)**
        - An Aggregate is a cluster of objects treated as a single unit. One entity is the **Root**.
            - **Rule:** Outside objects can only talk to the Root. You cannot directly mess with the internals.
            - **Example:** The Order is the Aggregate Root. The OrderItems (pizzas/drinks) inside it are internal. To add a pizza, you ask the Order, you don't access the list directly.

---

# **3. The C# Implementation**

- Here is how a "Anemic" (Bad) model differs from a "Rich" (DDD) model.
    - **The "Anemic" Way (Avoid this in DDD)**
        - This is just a bag of data. There are no protections.
        
        ```csharp
        // ❌ BAD: Logic exists elsewhere (in Controllers or Services)
        public class Order
        {
            public int Id { get; set; }
            public string Status { get; set; }
            public List<Pizza> Pizzas { get; set; } // Anyone can clear this list!
        }
        
        ```
        
    - **The "Rich Domain" Way (DDD)**
        - Here, the logic lives *inside* the class.
        
        ```csharp
        using System;
        using System.Collections.Generic;
        using System.Linq;
        
        namespace PizzaShop.Domain
        {
            // 1. VALUE OBJECT (Use C# Records for immutability)
            public record Address(string Street, string City, string ZipCode);
        
            // 2. ENTITY (Has an ID, belongs to the Aggregate)
            public class OrderItem
            {
                public Guid Id { get; }
                public string Name { get; private set; }
                public decimal Price { get; private set; }
        
                public OrderItem(string name, decimal price)
                {
                    Id = Guid.NewGuid();
                    Name = name;
                    Price = price;
                }
            }
        
            // 3. AGGREGATE ROOT
            public class Order
            {
                public Guid Id { get; }
        
                // The properties are read-only to the outside world!
                public Address DeliveryAddress { get; private set; }
                public OrderStatus Status { get; private set; }
        
                // Encapsulation: Use a backing field so no one can .Clear() the list from outside
                private readonly List<OrderItem> _items = new();
                public IReadOnlyCollection<OrderItem> Items => _items.AsReadOnly();
        
                // Constructor: An order CANNOT exist without an address (Rule #1)
                public Order(Address address)
                {
                    Id = Guid.NewGuid();
                    DeliveryAddress = address ?? throw new ArgumentNullException(nameof(address));
                    Status = OrderStatus.New;
                }
        
                // METHOD: "Add Item" – Not just adding to a list, but checking rules
                public void AddItem(OrderItem item)
                {
                    // Rule #2: Cannot add items if confirmed
                    if (Status != OrderStatus.New)
                    {
                        throw new InvalidOperationException("Can't modify order after it's confirmed.");
                    }
        
                    _items.Add(item);
                }
        
                // METHOD: Expresses business language
                public void ConfirmOrder()
                {
                    if (_items.Count == 0) throw new InvalidOperationException("Cannot confirm empty order");
        
                    Status = OrderStatus.Confirmed;
                    // Here implies we might raise an event later
                }
        
                public void StartCooking()
                {
                    if (Status != OrderStatus.Confirmed) throw new InvalidOperationException("Must confirm first.");
                    Status = OrderStatus.Cooking;
                }
        
                // Rule #3: Cannot cancel if cooking
                public void CancelOrder()
                {
                    if (Status == OrderStatus.Cooking)
                    {
                        throw new InvalidOperationException("Too late! Pizza is in the oven.");
                    }
                    Status = OrderStatus.Cancelled;
                }
            }
        
            public enum OrderStatus
            {
                New,
                Confirmed,
                Cooking,
                Cancelled
            }
        }
        
        ```
        

---

# **4. Architect's Questions (How to decide)**

- As you build this, ask yourself these questions to decide where code goes.
    - **Q1: "Is this an Entity or a Value Object?"**
        - **The Test:** If you change the spelling of the street name, is it a totally new identity?
            - **Answer:** No. It's just a value update. -> **Value Object**.
            - **Example:** If a User changes their email, they are still the same User ID. -> **Entity**.
    - **Q2: "Who creates the Order?"**
        - We generally use a **Factory** if creation is complex, or just the Constructor if it's simple.
            - **Decision:** Since Order needs an Address immediately, force it in the constructor. Never allow an object to be created in an invalid state.
    - **Q3: "Where do I save this to the database?"**
        - In DDD, the Domain code (above) **should not know about the database**. It shouldn't have [Key] or SQL references.
        - We use a **Repository Pattern**.
        
        ```csharp
        // The Interface lives in the Domain layer
        public interface IOrderRepository
        {
            Order GetById(Guid id);
            void Save(Order order);
        }
        
        // The Implementation lives in the Infrastructure layer (Separate Project)
        public class SqlOrderRepository : IOrderRepository { ... }
        
        ```
        

---

# **5. Tying it all together (The Application Service)**

- This is the "API" or "Controller" level logic. It creates the workflow.
    
    ```csharp
    public class PizzaOrderingService
    {
        private readonly IOrderRepository _repository;
    
        public PizzaOrderingService(IOrderRepository repository)
        {
            _repository = repository;
        }
    
        public void PlaceOrder(string street, string city, string zip, List<string> pizzas)
        {
            // 1. Prepare Value Objects
            var address = new Address(street, city, zip);
    
            // 2. Create Aggregate
            var order = new Order(address);
    
            // 3. Interact with Aggregate via Business Methods
            foreach(var p in pizzas)
            {
                order.AddItem(new OrderItem(p, 10.00m));
            }
    
            order.ConfirmOrder();
    
            // 4. Persist the entire Aggregate
            _repository.Save(order);
        }
    }
    
    ```
    

---

# **Summary**

- **1. Ubiquitous Language:** Methods represent business actions (ConfirmOrder), not data setters (Status = Confirmed).
- **2. Invariants:** The class protects itself. You literally cannot write C# code that breaks the business rules (like canceling a cooking pizza) because the class throws an exception.
- **3. Encapsulation:** private set and IReadOnlyCollection are your best friends.
- Here is the golden rule of DDD Architecture (The Dependency Rule):
    - **The inner layers must NOT know anything about the outer layers.**
    - Let's break down the four standard layers and then answer the Repository question.

---

# **1. The Layers (From the Inside Out)**

- **A. The Domain Layer (The Core)**
    - This is the center of the Onion. This project has **zero dependencies** on other projects. It contains only pure C# classes.
        - **Contains:** Entities (Order), Value Objects (Address), Domain Exceptions, and **Interfaces for Repositories** (IOrderRepository).
        - **Analogy:** The Pizza Recipe Book. It lists ingredients and cooking times. It doesn't care which oven you own or which cook is working today.
- **B. The Application Layer (The Orchestrator)**
    - Surrounds the Domain. It uses the Domain objects to perform specific tasks requested by the user.
        - **Contains:** Services (OrderService), DTOs (Data Transfer Objects - simple classes to send data to the UI).
        - **Analogy:** The Kitchen Manager. He reads the ticket, tells the chefs (Domain) what to cook, and hands the finished pizza to the waiter. He doesn't cook the pizza himself.
- **C. The Infrastructure Layer (The Plumber)**
    - This is where the technology lives. It references both Domain and Application.
        - **Contains:** Entity Framework Core, SQL Server connectivity, Email sending logic, File system access.
        - **Analogy:** The Oven, The Delivery Bike, The Cash Register.
- **D. The Presentation Layer (The Entry Point)**
    - This is the outside world.
        - **Contains:** Controllers (Web API), View Models.
        - **Analogy:** The Waiter or the Website Order Form.

---

# **2. The Repository Dilemma: Direct Mapping vs. Separation**

- You asked: *"Will repository use Domain model to directly save in database?"*
    - **The Short Answer:**
        - The Repository **Interface** uses Domain Models.
        - The Repository **Implementation** *translates* those Domain Models into Database Models.
    - **The Problem:**
        - Your Domain Order class has logic (Confirm()), private setters, and List\<OrderItem>.
        - Database tables need public setters and simpler types to work with SQL easily.
    - **The Solution: Mapping (The Anti-Corruption Pattern)**
        - Inside the **Infrastructure Layer**, we create a generic "Data Model" that looks just like a DB table, and we map between the two.
    - **Step 1: The Domain (Inner Layer)**
        
        ```csharp
        // Project: PizzaShop.Domain
        public class Order
        {
            public Guid Id { get; }
            public string Status { get; private set; } // Logic guarded
            // Logic...
        }
        
        public interface IOrderRepository
        {
            // The Interface speaks "Domain"
            void Save(Order order);
        }
        
        ```
        
    - **Step 2: The Infrastructure (Outer Layer)**
        
        ```csharp
        // Project: PizzaShop.Infrastructure
        
        // 1. A simple class that mimics the SQL Table 1:1
        public class OrderDbEntity
        {
            public Guid Id { get; set; }      // Open for EF Core
            public string Status { get; set; } // Open for EF Core
        }
        
        // 2. The Repository Implementation
        public class SqlOrderRepository : IOrderRepository
        {
            private readonly MyDbContext _dbContext; // EF Core Context
        
            public void Save(Order domainOrder)
            {
                // MAP: Domain Object -> Database Object
                var dbEntity = new OrderDbEntity
                {
                    Id = domainOrder.Id,
                    Status = domainOrder.Status.ToString()
                };
        
                _dbContext.Orders.Add(dbEntity);
                _dbContext.SaveChanges();
            }
        }
        
        ```
        
    - **Why do this work?**
        - If you add a new column to your database for performance indexing, you modify the OrderDbEntity. Your critical Business Logic (Order.cs) **never touches** the database code. You can change from SQL Server to MongoDB without changing a single line of business rules.

---

# **3. The Decision Matrix: "Where does this code go?"**

- When you have a new requirement, ask these 3 questions to decide the layer.
    - **Question 1: "Does this logic relate to a business rule that exists even without a computer?"**
        - *Example:* "A pizza cannot be cancelled if it's cooking." (Physical rule)
        - *Example:* "Calculation of sales tax." (Government rule)
        - **Verdict: Domain Layer.**
    - **Question 2: "Is this logic coordinating a flow or fetching data?"**
        - *Example:* "Get the user request, load the Order from DB, call Confirm(), send an email, save back to DB."
        - *Example:* "Generate a PDF receipt."
        - **Verdict: Application Layer.**
    - **Question 3: "Does this touch an external tool, library, or database?"**
        - *Example:* "Serialize to JSON."
        - *Example:* "Send SMTP email."
        - *Example:* "Write to SQL Table."
        - **Verdict: Infrastructure Layer.**

---

# **4. Real World Workflow Example**

- Let's trace a request: **"Confirm Order"**.
    1. **Presentation (Controller):** receives HTTP POST. Creates a command. Calls Application Layer.
        - *Code:* `service.Confirm(orderId);`
    2. **Application (Service):**
        - Calls Infrastructure: `repo.GetById(orderId)`.
        - Infrastructure maps DB Row -> Domain Object. Returns Order.
        - Service calls Domain: `order.Confirm()`.
        - Domain checks rules: if (status == Cooking) throw.... Logic happens. Status changes.
        - Service calls Infrastructure: `repo.Save(order)`.
        - Infrastructure maps Domain Object -> DB Row. Saves to SQL.
    3. **Infrastructure:** Updates DB.
    4. **Presentation:** Returns HTTP 200 OK.

---

# **Architect's Summary**

- Do not pollute your Domain (Entities) with database annotations like [Table("Orders")] or [Key]. That makes your business rules dependent on your database choice. Keep the Domain pure, and let the Repository (in Infrastructure) handle the messy work of translation.