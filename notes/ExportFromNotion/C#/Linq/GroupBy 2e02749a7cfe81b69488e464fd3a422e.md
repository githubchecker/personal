# GroupBy

`GroupBy` is a fundamental operator that organizes a flat sequence of elements into buckets based on a shared "Key".

Unlike SQL `GROUP BY` (which usually forces you to aggregate data immediately into counts or sums), LINQ `GroupBy` preserves the actual object data in a hierarchical format.

---

### **The Output Structure: `IGrouping<Key, T>`**

Before looking at the syntax, you must understand what `GroupBy` actually returns. It returns an `IEnumerable` of **groups**.

Each item in the result is an object of type `IGrouping<Key, T>`.

- **`.Key`**: The value used to group these items.
- **The Object Itself**: The `IGrouping` acts exactly like a `List<T>`. You can iterate over it to get the items belonging to that group.

---

### **1. Method Syntax (Fluent API)**

There are three main ways to use `GroupBy` in method syntax, depending on how much control you need.

### **A. Basic Grouping (Key Selector)**

This groups the items but keeps the original objects intact inside the groups.

```csharp
var numbers = new[] { 1, 2, 3, 4, 5, 6 };

// Group by Odd vs Even
var groupings = numbers.GroupBy(n => n % 2 == 0 ? "Even" : "Odd");

foreach (var group in groupings)
{
    Console.WriteLine($"Key: {group.Key}"); // "Odd" or "Even"
    foreach (var number in group)
    {
        Console.WriteLine(number); // The actual integers
    }
}

```

### **B. Grouping with Element Selector**

Sometimes you don't want the *entire* object inside the group, just one property.

- *Argument 1:* Key Selector (What defines the group?)
- *Argument 2:* Element Selector (What goes *inside* the group?)

```csharp
var users = new[]
{
    new { Name = "Alice", Role = "Admin" },
    new { Name = "Bob",   Role = "User" },
    new { Name = "Charlie", Role = "Admin" }
};

// "Key is Role. Inside the group, I only want the Names, not the full User objects."
var roleGroups = users.GroupBy(
    u => u.Role,    // Key
    u => u.Name     // Element
);

// Access:
// Key: "Admin" -> List: ["Alice", "Charlie"]
// Key: "User"  -> List: ["Bob"]

```

### **C. Grouping with Result Selector**

This is the most efficient method if you want to group and immediately transform the output into a new object (e.g., getting counts) without manually iterating later.

```csharp
var stats = users.GroupBy(
    u => u.Role,                     // Key
    (key, items) => new              // Result Selector
    {
        Role = key,
        Count = items.Count(),
        Names = string.Join(", ", items.Select(x => x.Name))
    }
);

/* Result (Flattened List):
[
    { Role: "Admin", Count: 2, Names: "Alice, Charlie" },
    { Role: "User",  Count: 1, Names: "Bob" }
]
*/

```

---

### **2. Query Syntax (`group ... by ...`)**

The syntax is distinct because it does **not** end with `select` like most queries. It ends with the `group` clause (unless you use `into`).

### **Basic Structure**

```csharp
// Format: group [variable] by [key]
var query = from u in users
            group u by u.Role;

```

### **With Element Selection**

If you want to modify what gets stored in the group (like Method B above):

```csharp
// Format: group [projection] by [key]
var namesByRole = from u in users
                  group u.Name by u.Role;

```

### **Using `into` for Result Transformation**

If you want to perform operations on the groups immediately (like Method C above), you continue the query using `into`.

```csharp
var groupStats = from u in users
                 group u by u.Role into roleGroup // 'roleGroup' is now the IGrouping
                 select new
                 {
                     Role = roleGroup.Key,
                     Count = roleGroup.Count()
                 };

```

---

### **3. Advanced: Composite Keys**

What if you need to group by **multiple** columns? (e.g., Group by `Country` AND `City`).

You must create an **Anonymous Object** as the key. LINQ is smart enough to compare anonymous objects by their property values.

```csharp
var people = new[]
{
    new { Country = "USA", City = "NY", Name = "John" },
    new { Country = "USA", City = "NY", Name = "Jane" },
    new { Country = "USA", City = "LA", Name = "Mike" },
};

var grouped = people.GroupBy(p => new { p.Country, p.City });

foreach (var g in grouped)
{
    // The Key is now an object!
    Console.WriteLine($"Location: {g.Key.City}, {g.Key.Country}");
    Console.WriteLine($"Count: {g.Count()}");
}

```

### **Common "Gotcha": The Variable Scope**

When iterating a `GroupBy` result, beginners often forget that the iterator variable **IS** the list.

**Wrong:**

```csharp
var groups = list.GroupBy(x => x.Category);
// Error: 'groups' is a collection of groups, not the items themselves.
var count = groups.Count(); // Returns number of CATEGORIES, not items.

```

**Right:**

```csharp
foreach (var group in groups)
{
    // group.Key = The Category Name
    // group.Count() = Number of items in this specific category
}

```