# 4. Keys

# Keys

A key serves as a unique identifier for each entity instance. Most entities in EF have a single key, which maps to the concept of a primary key in relational databases (for entities without keys, see [Keyless entities](https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types)). Entities can have additional keys beyond the primary key (see [Alternate Keys](https://learn.microsoft.com/en-us/ef/core/modeling/keys#alternate-keys) for more information).

## Configuring a primary key

By convention, a property named Id or Id will be configured as the primary key of an entity.

```csharp
internal class Car
{
    public string Id { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

internal class Truck
{
    public string TruckId { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

```

<aside>
‚ÑπÔ∏è **NOTE:** [Owned entity types](https://learn.microsoft.com/en-us/ef/core/modeling/owned-entities)use different rules to define keys.

</aside>

You can configure a single property to be the primary key of an entity as follows:

### Data Annotations

```csharp
internal class Car
{
    [Key]
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

```

### Fluent API

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasKey(c => c.LicensePlate);
}

```

You can also configure multiple properties to be the key of an entity - this is known as a composite key. Conventions will only set up a composite key in specific cases - like for an owned type collection.

### Data Annotations

```csharp
[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }

    public string Make { get; set; }
    public string Model { get; set; }
}

```

### Fluent API

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasKey(c => new { c.State, c.LicensePlate });
}

```

## Value generation

For non-composite numeric and GUID primary keys, EF Core sets up value generation for you by convention. For example, a numeric primary key in SQL Server is automatically set up to be an IDENTITY column. For more information, see [the documentation on value generation](https://learn.microsoft.com/en-us/ef/core/modeling/generated-properties) and [guidance for specific inheritance mapping strategies](https://learn.microsoft.com/en-us/ef/core/modeling/inheritance#key-generation).

## Primary key name

By convention, on relational databases primary keys are created with the name PK_. You can configure the name of the primary key constraint as follows:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .HasKey(b => b.BlogId)
        .HasName("PrimaryKey_BlogId");
}

```

## Key types and values

While EF Core supports using properties of any primitive type as the primary key, including string, Guid, byte[] and others, not all databases support all types as keys. In some cases the key values can be converted to a supported type automatically, otherwise the conversion should be [specified manually](https://learn.microsoft.com/en-us/ef/core/modeling/value-conversions).

Key properties must always have a non-default value when adding a new entity to the context, but some types will be [generated by the database](https://learn.microsoft.com/en-us/ef/core/modeling/generated-properties). In that case EF will try to generate a temporary value when the entity is added for tracking purposes. After [SaveChanges](https://learn.microsoft.com/en-us/dotnet/api/Microsoft.EntityFrameworkCore.DbContext.SaveChanges) is called the temporary value will be replaced by the value generated by the database.

<aside>
üî• **IMPORTANT:** If a key property has its value generated by the database and a non-default value is specified when an entity is added, then EF will assume that the entity already exists in the database and will try to update it instead of inserting a new one. To avoid this, turn off value generation or see[how to specify explicit values for generated properties](https://learn.microsoft.com/en-us/ef/core/modeling/generated-properties#overriding-value-generation).

</aside>

## Alternate Keys

An alternate key serves as an alternate unique identifier for each entity instance in addition to the primary key; it can be used as the target of a relationship. When using a relational database this maps to the concept of a unique index/constraint on the alternate key column(s) and one or more foreign key constraints that reference the column(s).

<aside>
üí° **TIP:** If you just want to enforce uniqueness on a column, define a unique index rather than an alternate key (see[Indexes](https://learn.microsoft.com/en-us/ef/core/modeling/indexes)). In EF, alternate keys are read-only and provide additional semantics over unique indexes because they can be used as the target of a foreign key.

</aside>

Alternate keys are typically introduced for you when needed and you do not need to manually configure them. By convention, an alternate key is introduced for you when you identify a property which isn't the primary key as the target of a relationship.

```csharp
internal class MyContext : DbContext
{
    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Post>()
            .HasOne(p => p.Blog)
            .WithMany(b => b.Posts)
            .HasForeignKey(p => p.BlogUrl)
            .HasPrincipalKey(b => b.Url);
    }
}

public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }

    public List<Post> Posts { get; set; }
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    public string BlogUrl { get; set; }
    public Blog Blog { get; set; }
}

```

You can also configure a single property to be an alternate key:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => c.LicensePlate);
}

```

You can also configure multiple properties to be an alternate key (known as a composite alternate key):

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => new { c.State, c.LicensePlate });
}

```

Finally, by convention, the index and constraint that are introduced for an alternate key will be named AK__ (for composite alternate keys  becomes an underscore separated list of property names). You can configure the name of the alternate key's index and unique constraint:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => c.LicensePlate)
        .HasName("AlternateKey_LicensePlate");
}

```