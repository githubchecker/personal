# 1. Overview

# Model Creation and Configuration

EF Core uses a metadata model to map .NET entity types to a database. This model is built using **Conventions**, which can be overridden by **Data Annotations** (attributes) or the **Fluent API**.

## 1. Configuration Methods and Precedence

Configuration is applied in the following order of priority (highest priority first):

- **Fluent API:** Defined in `OnModelCreating`.
- **Data Annotations:** Attributes applied directly to entity classes/properties.
- **Conventions:** Default heuristics (e.g., `Id` property becomes the Primary Key).

## 2. Using the Fluent API

The Fluent API is the most flexible configuration method. It allows you to specify mappings without modifying your domain entities.

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .Property(b => b.Url)
        .IsRequired();
}

```

### Grouping Configuration (`IEntityTypeConfiguration`)

For large models, extract configuration into separate classes:

```csharp
public class BlogConfiguration : IEntityTypeConfiguration<Blog>
{
    public void Configure(EntityTypeBuilder<Blog> builder)
    {
        builder.Property(b => b.Url).IsRequired();
    }
}

```

### Applying Configurations

Register configurations manually or by scanning an assembly:

```csharp
// Manual
new BlogConfiguration().Configure(modelBuilder.Entity<Blog>());

// Assembly Scanning
modelBuilder.ApplyConfigurationsFromAssembly(typeof(BlogConfiguration).Assembly);

```

### Using `EntityTypeConfigurationAttribute`

Link a configuration class directly to an entity type:

```csharp
[EntityTypeConfiguration(typeof(BookConfiguration))]
public class Book { ... }

```

## 3. Using Data Annotations

Attributes provide a way to configure simple mappings inside the entity file.

```csharp
[Table("Blogs")]
public class Blog
{
    public int BlogId { get; set; }

    [Required]
    public string Url { get; set; }
}

```

## 4. Built-in Conventions

EF Core comes with many default conventions (e.g., creating indexes for Foreign Keys). You can remove or customize these in `ConfigureConventions`.

### Example: Removing Foreign Key Indexes

```csharp
protected override void ConfigureConventions(ModelConfigurationBuilder configurationBuilder)
{
    // Stops EF from automatically creating indexes for every FK
    configurationBuilder.Conventions.Remove(typeof(ForeignKeyIndexConvention));
}

```

## 5. Model Debug View

You can inspect the generated model metadata at runtime to verify mappings.

```csharp
// Output the short debug string to console
Console.WriteLine(context.Model.ToDebugString());

// Output the long debug string (includes metadata and provider-specific details)
Console.WriteLine(context.Model.ToDebugString(MetadataDebugStringOptions.LongDefault));

```

The debug view is also accessible via the IDE debugger by inspecting the `Model` property on your `DbContext` instance.