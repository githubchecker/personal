# 1. Overview

# DbContext Lifetime, Configuration, and Initialization

This guide covers the basic patterns for initializing and configuring a [DbContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext).

## The DbContext Lifetime

The lifetime of a `DbContext` begins at instantiation and ends when it is [disposed](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/unmanaged). It is designed for a **single unit-of-work**, meaning its lifetime should be short.

### Typical Unit-of-Work Workflow:

- **Instantiation:** Create the `DbContext` instance.
- **Tracking:** Entities become tracked via queries or by being added/attached.
- **Modification:** Changes are made to tracked entities.
- **Persistence:** Call `SaveChanges` or `SaveChangesAsync` to write changes to the database.
- **Disposal:** Dispose the `DbContext` to free resources.

<aside>
ðŸ”¥ Always dispose the `DbContext` to prevent memory leaks and free unmanaged resources. Note that `DbContext` is **not thread-safe**. Do not share instances across threads and always await asynchronous calls.

</aside>

## DbContext in Dependency Injection (ASP.NET Core)

In web apps, the `DbContext` lifetime is usually tied to the HTTP request. ASP.NET Core handles this via Dependency Injection (DI).

### Registration in `Program.cs`:

```csharp
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection")
    ?? throw new InvalidOperationException("Connection string 'DefaultConnection' not found.");

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));

```

### Constructor Pattern:

Your `DbContext` must expose a constructor that accepts `DbContextOptions<T>`.

```csharp
public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }
}

```

### Usage in Controllers:

```csharp
public class MyController
{
    private readonly ApplicationDbContext _context;

    public MyController(ApplicationDbContext context) => _context = context;
}

```

## Manual Initialization with `new`

You can manually instantiate a `DbContext` by overriding `OnConfiguring` or passing options to the constructor.

### Using `OnConfiguring`:

```csharp
public class ApplicationDbContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=Test;");
    }
}

```

### Passing Options Explicitly:

```csharp
var options = new DbContextOptionsBuilder<ApplicationDbContext>()
    .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=Test;")
    .Options;

using var context = new ApplicationDbContext(options);

```

## Using a DbContext Factory

Use [AddDbContextFactory](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.entityframeworkservicecollectionextensions.adddbcontextfactory) when the DI scope doesn't match the desired lifetime (e.g., in Blazor) or when performing multiple units-of-work in one scope.

### Registration:

```csharp
services.AddDbContextFactory<ApplicationDbContext>(options => 
    options.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=Test;"));

```

### Usage:

```csharp
private readonly IDbContextFactory<ApplicationDbContext> _contextFactory;

public MyService(IDbContextFactory<ApplicationDbContext> contextFactory) 
    => _contextFactory = contextFactory;

public async Task DoWork()
{
    using var context = _contextFactory.CreateDbContext();
    // Context is created manually and must be disposed manually
}

```

## Configuring DbContextOptions

`DbContextOptionsBuilder` is the primary tool for configuration, whether in `AddDbContext`, `OnConfiguring`, or manual creation.

### Database Providers

Each instance must use exactly one provider. Common providers:

| Database | Method | NuGet Package |
| --- | --- | --- |
| **SQL Server** | `.UseSqlServer(connString)` | `Microsoft.EntityFrameworkCore.SqlServer` |
| **SQLite** | `.UseSqlite(connString)` | `Microsoft.EntityFrameworkCore.Sqlite` |
| **Cosmos DB** | `.UseCosmos(connString, dbName)` | `Microsoft.EntityFrameworkCore.Cosmos` |
| **PostgreSQL** | `.UseNpgsql(connString)` | `Npgsql.EntityFrameworkCore.PostgreSQL` |
| **MySQL** | `.UseMySql(connString, version)` | `Pomelo.EntityFrameworkCore.MySql` |

### Common Configuration Methods

| Method | Description |
| --- | --- |
| `UseQueryTrackingBehavior` | Sets default tracking (e.g., `NoTracking`). |
| `LogTo` | Simple console/debug logging. |
| `EnableSensitiveDataLogging` | Includes data values in logs/exceptions. |
| `EnableDetailedErrors` | Provides more details for query failures. |
| `AddInterceptors` | Registers database interceptors. |
| `UseLazyLoadingProxies` | Enables lazy loading via proxies. |

## Threading Issues

`DbContext` does **not** support concurrent operations. Parallel use or failing to await async calls will result in an `InvalidOperationException`.

### Best Practices to Avoid Corrupt State:

- **Always Await:** Never initiate a second operation on a context before the first completes.
- **Scoped Lifetime:** In DI, ensure each thread or logical unit of work has its own scope to avoid sharing instances.
- **Context Pooling:** For high-performance scenarios, consider [DbContext Pooling](https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics#dbcontext-pooling) to reduce instantiation overhead.

## Design-Time Creation

Tools like Migrations need to create a `DbContext` instance at design-time. Ensure your context follows standard patterns or implement `IDesignTimeDbContextFactory<T>` if you have complex instantiation logic. See [Design-Time Context Creation](https://learn.microsoft.com/en-us/ef/core/cli/dbcontext-creation) for details.