# Sonarqube integration

This is a significant jump in complexity. To add **SonarQube** and **Code Coverage Enforcement**, you must fundamentally change the shape of your pipeline.

You can no longer just "Build". You must follow the **Sandwich Pattern**:

1. **Prepare** (Tell SonarQube "I am about to do something").
2. **Build & Test** (The actual work).
3. **Analyze** (Send data to SonarQube).
4. **Publish/Gate** (Did we pass?).

---

### **1. The SonarQube Tasks (The "Sandwich")**

SonarQube analysis **must** wrap your build commands. If you run `Analyze` before `Build`, it won't find any binaries to scan.

### **Step A: The Service Connection**

Before writing YAML, you must create a connection.

- **Where:** Project Settings -> Service Connections -> New -> **SonarQube**.
- **What:** You provide the URL (e.g., `https://sonarcloud.io`) and the Token (generated in SonarQube). Name it `MySonarConnection`.

### **Step B: `SonarQubePrepare@5`**

This goes **before** any restore or build task.

```yaml
- task: SonarQubePrepare@5
  displayName: 'Prepare SonarQube Analysis'
  inputs:
    SonarQube: 'MySonarConnection' # The Service Connection Name
    scannerMode: 'MSBuild' # Vital for .NET Core
    projectKey: 'MyCompany_MyApi' # Get this from SonarQube UI
    projectName: 'My .NET API'
    # Vital for Coverage: Tell Sonar where to look for test reports
    extraProperties: |
      sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/coverage.cobertura.xml

```

### **Step C: `SonarQubeAnalyze@5`**

This goes **immediately after** your Build and Test steps are finished.

```yaml
- task: SonarQubeAnalyze@5
  displayName: 'Run Code Analysis'

```

### **Step D: `SonarQubePublish@5` (The Quality Gate)**

This checks if you passed.

```yaml
- task: SonarQubePublish@5
  displayName: 'Check Quality Gate'
  inputs:
    pollingTimeoutSec: '300'

```

---

### **2. The Test Step (Generating Coverage)**

SonarQube does **not** calculate coverage itself. It reads the report generated by `dotnet test`. You must configure `DotNetCoreCLI@2` to produce this report in a format SonarQube understands (Cobertura is the standard).

```yaml
- task: DotNetCoreCLI@2
  displayName: 'Run Tests & Collect Coverage'
  inputs:
    command: 'test'
    projects: '**/*Tests.csproj'
    arguments: '--configuration Release --collect "XPlat Code Coverage"'

```

- `-collect "XPlat Code Coverage"`: This creates a `.xml` coverage file (Coverlet) instead of the proprietary `.coverage` binary. SonarQube reads this XML.

---

### **3. How to Fail the Build on Low Coverage (< 80%)**

There are two ways to do this.

### **Method A: The "Expert" Way (SonarQube Quality Gate)**

You do **not** write a script for this in YAML. You manage it centrally.

1. **In SonarQube Dashboard:** Go to "Quality Gates".
2. **Define Rule:** "Coverage on New Code must be greater than 80%".
3. **Assign:** Assign this gate to your Project.
4. **In Azure Pipeline:** The `SonarQubePublish@5` task talks to the server. If the Server says "Gate Failed", the task will fail, **stopping the pipeline**.
    - *Note:* Ensure the "Clean" option is unchecked if using polling, or just trust the task's default behavior which fails on "Error" status from the gate.

### **Method B: The "Script" Way (If you don't have SonarQube)**

If you are poor and only rely on local tools, you can use the library `BuildQualityChecks` (an Extension) or a custom script.

**Custom Script Strategy (Using ReportGenerator):**

1. Install tool `dotnet tool install -g dotnet-reportgenerator-globaltool`.
2. Run `reportgenerator` to convert XML to readable text.
3. Parse text.

```yaml
# Simple enforcement without SonarQube
- task: DotNetCoreCLI@2
  displayName: 'Test'
  inputs:
    command: 'test'
    arguments: '--collect "XPlat Code Coverage"'

- script: |
    # Install tool
    dotnet tool install -g dotnet-reportgenerator-globaltool

    # Generate Report
    reportgenerator "-reports:$(Agent.TempDirectory)/**/coverage.cobertura.xml" "-targetdir:$(Agent.TempDirectory)/Cover" "-reporttypes:TextSummary"

    # Read the Line coverage
    $summary = Get-Content "$(Agent.TempDirectory)/Cover/Summary.txt"
    $lineCoverage = $summary | Select-String "Line coverage: (\\d+)%"
    $val = $lineCoverage.Matches.Groups[1].Value

    Write-Host "Current Coverage: $val%"

    if ([int]$val -lt 80) {
        Write-Error "Coverage is $val%, which is below the 80% threshold!"
        exit 1 # Fails the build
    }
  displayName: 'Enforce 80% Coverage'

```

---

### **4. Summary: The Complete Phase 2 YAML (with SonarQube)**

Here is the ultimate "Phase 2" snippet including SDK, Restore, SonarQube Start, Build, Test, SonarQube End, and Publish.

```yaml
steps:
# 1. SDK
- task: UseDotNet@2
  inputs: { version: '8.x' }

# 2. START SONARQUBE (The Top Bun)
- task: SonarQubePrepare@5
  inputs:
    SonarQube: 'MySonarConnection'
    scannerMode: 'MSBuild'
    projectKey: 'MyApiProject'
    extraProperties: 'sonar.cs.opencover.reportsPaths=$(Agent.TempDirectory)/**/coverage.cobertura.xml'

# 3. Restore
- task: DotNetCoreCLI@2
  inputs: { command: 'restore', projects: '**/*.sln' }

# 4. Build
- task: DotNetCoreCLI@2
  inputs: { command: 'build', projects: '**/*.sln', arguments: '--no-restore' }

# 5. Test (With Coverage)
- task: DotNetCoreCLI@2
  inputs:
    command: 'test'
    projects: '**/*Tests.csproj'
    arguments: '--no-build --collect "XPlat Code Coverage"'

# 6. ANALYZE & PUBLISH (The Bottom Bun)
- task: SonarQubeAnalyze@5

- task: SonarQubePublish@5
  inputs:
    pollingTimeoutSec: '300' # Waits 5 mins for Server to say "Pass/Fail". Fails pipeline if Gate fails.

# 7. Upload Artifacts (If build passed)
- task: DotNetCoreCLI@2
  inputs: { command: 'publish', output: '$(Build.ArtifactStagingDirectory)' }

- task: PublishBuildArtifacts@1

```

Are you ready to move to **Phase 3: CD - Deploying Your Code** (Where we learn about the various types of **Service Connections**)?