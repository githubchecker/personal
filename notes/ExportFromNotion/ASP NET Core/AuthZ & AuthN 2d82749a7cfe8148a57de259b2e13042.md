# AuthZ & AuthN

## **Phase 1: The Anatomy of Identity (Core Concepts)**

Before configuring Azure or writing Middleware, you must understand the data structure of **Identity**. In modern authentication (OpenID Connect / OAuth2), we don't pass usernames and passwords around. We pass **Security Tokens**.

For a .NET API Developer using Azure Entra ID (Azure AD), the "Token" is your source of truth.

---

### **1. The ClaimsPrincipal (`HttpContext.User`)**

In [ASP.NET](http://asp.net/) Core, inside any Controller, you have access to `User` (or `HttpContext.User`). This object represents the **ClaimsPrincipal**.

Think of the `ClaimsPrincipal` as a physical **Wallet**.

- The **Identities** are the ID cards inside (Driver's License, Passport).
- The **Claims** are the specific details written on those cards (Name, Date of Birth, Height).

### **What is a Claim?**

A Claim is a simple **Key-Value pair** that represents a fact about the user.

- **Key (Type):** `email`, `sub`, `oid`, `role`.
- **Value:** `dave@company.com`, `123-abc`, `Manager`.

**C# Example:**
How to read who is calling your API manually:

```csharp
[HttpGet("me")]
public IActionResult GetMyDetails()
{
    // 1. Check if authenticated
    if (!User.Identity.IsAuthenticated) return Unauthorized();

    // 2. Read specific Azure AD Claims
    // "name" = The display name (e.g., "John Doe")
    var name = User.Identity.Name;

    // "oid" (Object ID) = The primary key GUID of the user in Azure AD
    // This is the BEST field to use for Database Foreign Keys
    var userId = User.FindFirst("<http://schemas.microsoft.com/identity/claims/objectidentifier>")?.Value
                 ?? User.FindFirst("oid")?.Value;

    // "preferred_username" = usually the email used to login
    var email = User.FindFirst("preferred_username")?.Value;

    return Ok(new { Name = name, ID = userId, Email = email });
}

```

---

### **2. Scopes vs. Roles (The Critical Azure Distinction)**

This is the most common interview question and architecture mistake. In Azure Entra ID, access is controlled via two distinct concepts in the token.

### **A. Scopes (`scp`) -> Delegated Access**

- **Context:** A User is present (e.g., An Angular App logged in as John).
- **Meaning:** "The User consents to allow this App to do X on their behalf."
- **Use Case:** Your API receives a token from a Frontend App.
- **Example Claim:** `"scp": "Files.Read"`
- **Code Check:** The user can read files, but **this app** is allowed to read files for them.

### **B. Roles (`roles`) -> App Roles / RBAC**

- **Context:** User OR Machine (e.g., A Background Service).
- **Meaning:** "The Administrator has assigned this job function to this User/App."
- **Use Case:**
    - **User:** John is assigned the "Admin" role for the API.
    - **Service-to-Service:** The "OrderService" is assigned the "Writer" role for the Inventory API.
- **Example Claim:** `"roles": ["Admin", "Writer"]`

| Feature | **Scopes (`scp`)** | **Roles (`roles`)** |
| --- | --- | --- |
| **Who grants it?** | User (Consent) or Admin (Consent) | Admin (Assignment) |
| **Logic** | "Can the App do this?" | "Is the User allowed to do this?" |
| **Usage** | Granular API Permission (Read/Write) | High Level Business Rule (Manager/Viewer) |
| **Claim Array?** | Space-separated string (`"Files.Read User.Read"`) | JSON Array (`["Admin", "User"]`) |

---

### **3. The Azure AD JWT Structure**

When Azure AD authenticates a user, it sends a **JWT (JSON Web Token)** to your API. You can inspect these at [jwt.ms](https://jwt.ms/) (Microsoft's decoder).

A JWT has 3 parts: `Header.Payload.Signature`. The **Payload** is what we care about.

### **Critical Azure Claims (Memorize These)**

1. **`aud` (Audience):**
    - *Question:* "Who is this token meant for?"
    - *Value:* It should be **Your API's Client ID** (or App ID URI).
    - *Security:* If the audience matches "Graph API", your API should reject it. It wasn't meant for you.
2. **`iss` (Issuer):**
    - *Question:* "Who created this token?"
    - *Value:* `https://login.microsoftonline.com/{TenantId}/v2.0`
    - *Security:* Ensures the token came from *your* Azure AD tenant, not a hacker's tenant.
3. **`tid` (Tenant ID):**
    - *Question:* "Which company does this user belong to?"
    - *Value:* A GUID representing the Organization (e.g., Contoso). Critical for Multi-tenant apps.
4. **`oid` (Object ID):**
    - *Question:* "Who is the user?"
    - *Value:* The **Immutable, Unique GUID** of the user in Azure AD.
    - *Best Practice:* Always map this GUID to your SQL Database `UserId` column. Do not use email (emails change). Do not use `sub` (Subject) in Azure AD v2 if possible, as it is "pairwise" (changes depending on the Client ID calling). **`oid` is the Gold Standard for User ID.**
5. **`azp` (Authorized Party):**
    - *Question:* "Which App sent this request?"
    - *Value:* The Client ID of the **Frontend Application** (Angular/React).
    - *Use Case:* "Only allow the *Official iPhone App* to call this API."

### **Summary of Phase 1**

1. **JWT:** is the vehicle carrying identity.
2. **Claims:** are the data inside (Key-Value).
3. **`oid`**: is the Primary Key you use in your DB.
4. **Scopes:** define what the Client App is allowed to do (`[RequiredScope]`).
5. **Roles:** define what the User/Service is allowed to do (`[Authorize(Roles="...")]`).

Are you ready to move to **Phase 2: Integration with Azure Entra ID**? (We will go into the Azure Portal to create the App Registrations and write the `Program.cs` code).

## **Phase 2: Integration with Azure Entra ID (Setup)**

In this phase, we connect the dots. You will perform setup in the **Azure Portal** and then write the corresponding configuration code in [**ASP.NET](http://asp.net/) Core**.

The goal: Your API will reject any request that does not contain a valid JWT Access Token signed by your Azure Tenant.

---

### **1. Azure Portal Setup (The App Registration)**

For an API to trust Azure AD, it needs a registration.

### **Step A: Create the Registration**

1. Go to [**portal.azure.com**](http://portal.azure.com/) -> **Microsoft Entra ID** -> **App registrations**.
2. Click **New registration**.
3. **Name:** `My-Microservice-API`.
4. **Supported account types:** "Accounts in this organizational directory only" (Single Tenant) is standard for internal enterprise apps.
5. **Redirect URI:** Leave empty (this is an API, not a web app with a login UI).
6. Click **Register**.
7. **Copy these values** to Notepad:
    - **Application (client) ID**: (e.g., `1111-2222...`)
    - **Directory (tenant) ID**: (e.g., `aaaa-bbbb...`)

### **Step B: Expose the API (The Identifier)**

Tokens need an `aud` (Audience) claim. You define that here.

1. Go to **Expose an API** blade.
2. Click **Set** next to "Application ID URI".
    - Default: `api://<ClientId>` (This is fine).
    - Better: `api://my-microservice-api`.
3. Click **Save**.

### **Step C: Define a Scope (For the Frontend)**

1. On the same "Expose an API" page, click **+ Add a scope**.
2. **Scope name:** `access_as_user` (The standard name for "Let the app act as the logged-in user").
3. **Who can consent?:** "Admins and users".
4. **Admin consent display name:** "Access My API".
5. Click **Add scope**.
    - *Result:* Your full scope URI is `api://my-microservice-api/access_as_user`.

---

### **2. Application Configuration (`appsettings.json`)**

Now, switch to your .NET Core project. You need to tell it who to trust.

Open `appsettings.json` and add a specific section for AzureAd:

```json
{
  "AzureAd": {
    "Instance": "<https://login.microsoftonline.com/>",
    "Domain": "mycompany.onmicrosoft.com", // Your primary domain
    "TenantId": "aaaa-bbbb-cccc-dddd",    // From Step A
    "ClientId": "1111-2222-3333-4444",    // From Step A
    "Scopes": "access_as_user",           // The scope name you created

    // ValidAudience ensures the token is meant for THIS API, not another one.
    // Usually matched automatically by the library, but good to know.
    "Audience": "api://my-microservice-api"
  },
  "Logging": { ... }
}

```

---

### **3. The Library: `Microsoft.Identity.Web`**

Microsoft maintains a library specifically for this. **Do not** use the vanilla `JwtBearer` library if you are targeting Azure AD; `Microsoft.Identity.Web` handles caching, OBO flow, and validation much better.

**Package Installation:**

```bash
dotnet add package Microsoft.Identity.Web
dotnet add package Microsoft.Identity.Web.UI // Optional, for web apps

```

---

### **4. Dependency Injection (`Program.cs`)**

Here is the robust setup code.

```csharp
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.Identity.Web;

var builder = WebApplication.CreateBuilder(args);

// 1. Add Authentication Services
// "WebApi" means: Expect Bearer tokens. Do not redirect to a login page.
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection("AzureAd"));

// 2. Add Controllers
builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();

// 3. Enable the Middleware (ORDER MATTERS!)
// AuthN = Validate the token signature and expiration
app.UseAuthentication();

// AuthZ = Check Role/Policy
app.UseAuthorization();

app.MapControllers();

app.Run();

```

---

### **5. Validating It Works**

At this stage, you haven't added specific Policies yet, but you have enabled the "Bouncer" at the door.

### **Step A: Secure a Controller**

Add the `[Authorize]` attribute. This says: "Any valid token from my tenant is allowed. Anonymous is blocked."

```csharp
[ApiController]
[Route("[controller]")]
[Authorize] // <--- The Lock
public class WeatherController : ControllerBase
{
    [HttpGet]
    public IEnumerable<WeatherForecast> Get()
    {
        // If code reaches here, the token is 100% valid and not expired.
        // User.Identity.Name is populated.
        return ...;
    }
}

```

### **Step B: Test via Postman (The Failure)**

1. Run the API (`https://localhost:5001/Weather`).
2. Send a GET request without headers.
3. **Result:** `401 Unauthorized`. (Success! It is secure).

### **Step C: Test via Postman (The Success)**

You need a token. Getting one manually for an API is tricky (involves OAuth2 flows). For dev testing, we often use the Azure CLI.

1. Login locally: `az login`
2. Get a raw token for your user:
    
    ```bash
    az account get-access-token --resource "api://my-microservice-api"
    
    ```
    
3. Copy the `accessToken` string.
4. In Postman -> **Authorization** Tab -> Type: **Bearer Token** -> Paste.
5. Send GET request.
6. **Result:** `200 OK`.

---

### **Summary of Phase 2**

1. **App Registration:** Defines the identity of your API in the Cloud.
2. **App ID URI (`api://...`):** Is the unique name your API calls itself (Audience).
3. [**Microsoft.Identity.Web](http://microsoft.identity.web/):** The standard library for connecting .NET 6/8+ to Azure AD.
4. **`app.UseAuthentication()`:** The middleware that actually validates the JWT signature against Microsoft's public keys.

**Current State:**
Any user in your company can call your API if they have a token.
**The Missing Piece:** How do we restrict it? How do we say "Only Admins" or "Only the App running locally"?

Are you ready for **Phase 3: Deep Dive into Authorization (Logic Layer)**? (App Roles and Policies).

## **Phase 3: Deep Dive into Authorization (Logic Layer)**

You now have a secure API (AuthN). But currently, an intern can delete the production database because `[Authorize]` simply means "You have a token," not "You are an Admin."

We need **Authorization (AuthZ)**.

In the Azure ecosystem, we use **App Roles** (Best Practice) or **Groups** (Legacy/Enterprise). We implement these using the [**ASP.NET](http://asp.net/) Core Policy Engine**.

---

### **1. Azure App Roles (The Gold Standard)**

This is the cleanest way to handle permissions. You define roles in the App Registration, assign users/groups to those roles, and the API simply checks the `roles` claim.

### **Step A: Define Roles in Azure Portal**

1. Go to your **App Registration** -> **App roles**.
2. Click **Create app role**.
    - **Display Name:** `Writer`
    - **Allowed member types:** Users/Groups (or Applications)
    - **Value:** `Writer` (This is the exact string you check in C#)
    - **Description:** Can write data.
3. Click **Apply**. Repeat for `Admin`.

### **Step B: Assign Users to Roles**

*Note: You do this in the "Enterprise Application" blade, not App Registration.*

1. Go to **Entra ID Home** -> **Enterprise Applications**.
2. Find your app (`My-Microservice-API`).
3. Go to **Users and groups** -> **Add user/group**.
4. Select a User -> Select a Role (`Writer`) -> Assign.

### **Step C: Enforce in C# Code**

When that user gets a token, it will look like this:

```json
{
  "roles": ["Writer"]
}

```

Now restrict the Controller:

```csharp
[Authorize(Roles = "Admin")] // Only Admins
[HttpPost]
public IActionResult DeleteDatabase() { ... }

[Authorize(Roles = "Writer, Admin")] // Writers OR Admins
[HttpPost]
public IActionResult UpdateData() { ... }

```

**Configuration Note:**
If using `Microsoft.Identity.Web`, role mapping is automatic. If `Roles` check fails despite having the claim, verify in `Program.cs` that the `RoleClaimType` is set to `"roles"`:

```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddMicrosoftIdentityWebApi(options => { }, options => {
         // Fix for Azure AD sending "roles" instead of the standard W3C schema role
         options.TokenValidationParameters.RoleClaimType = "roles";
    },
    builder.Configuration.GetSection("AzureAd"));

```

---

### **2. Policy-Based Authorization (The "Engine")**

Using strings like `[Authorize(Roles = "Admin")]` everywhere is "Hardcoded". If "Admin" changes to "SuperAdmin", you have to find/replace your code.

**The Expert Way:** Define **Policies**.
A Policy gives a name to a rule.

### **Step A: Define Policy in `Program.cs`**

```csharp
builder.Services.AddAuthorization(options =>
{
    // Policy 1: Require specific Role
    options.AddPolicy("RequireAdmin", policy =>
        policy.RequireRole("Admin"));

    // Policy 2: Require specific Azure AD Scope
    options.AddPolicy("CanRead", policy =>
        policy.RequireScope("access_as_user", "Files.Read"));

    // Policy 3: Require a specific Tenant (Multitenant Security)
    options.AddPolicy("CorporateUsersOnly", policy =>
        policy.RequireClaim("tid", "aaaa-bbbb-cccc-dddd")); // Only users from specific Tenant
});

```

### **Step B: Use Policy in Controllers**

```csharp
[Authorize(Policy = "RequireAdmin")]
public IActionResult AdminAction() { ... }

```

Now, if your definition of "Admin" becomes complex (e.g., Role=Admin AND Tenant=HQ), you only change the Policy definition in `Program.cs`, not the Controller.

---

### **3. Azure Security Groups (The "Enterprise" Problem)**

Large companies sync their on-premise AD Groups to Azure. They don't want to manually assign App Roles. They want to use existing Groups (e.g., `All_HR_Employees`).

**The Problem:**
Azure tokens contain Group **Object IDs (GUIDs)**, not names.
Token: `"groups": ["0000-1111-2222-3333"]`. It does NOT say `"HR_Employees"`.

**The Solution: Map IDs in Policy.**

```csharp
var hrGroupId = "0000-1111-2222-3333"; // ID from Azure Portal
var itGroupId = "5555-6666-7777-8888";

builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("HR_Only", policy =>
        policy.RequireClaim("groups", hrGroupId));

    options.AddPolicy("IT_Admin", policy =>
        policy.RequireClaim("groups", itGroupId));
});

```

*Note:* You must enable the "Group Claim" in the App Registration Token Configuration for this to appear in the token.

---

### **4. Scopes (Delegated Permissions)**

If your API is being called by a Frontend (React/Angular), you must check **Scopes**.

- **Roles** = Who the user is.
- **Scopes** = What the Client App is allowed to do.

`Microsoft.Identity.Web` provides the `[RequiredScope]` attribute.

```csharp
using Microsoft.Identity.Web.Resource;

[ApiController]
[Route("[controller]")]
public class FileController : ControllerBase
{
    [HttpGet]
    [RequiredScope("Files.Read")] // Enforces 'scp': 'Files.Read' in token
    public IActionResult ReadFile()
    {
        return Ok("Content");
    }

    [HttpPost]
    [RequiredScope("Files.Write")]
    public IActionResult WriteFile()
    {
        return Ok("Written");
    }
}

```

---

### **5. Custom Requirement Handlers (Master Logic)**

Sometimes, Claims/Roles are not enough.
**Scenario:** "User can only edit documents if the Document CreatedDate is within the last 24 hours."

You cannot check this in `Program.cs` or `[Attributes]`. You need C# logic.

### **Step A: Define Requirement (The "Signature")**

```csharp
public class FreshContentRequirement : IAuthorizationRequirement
{
    public FreshContentRequirement() { }
}

```

### **Step B: Define Handler (The "Logic")**

```csharp
public class FreshContentHandler : AuthorizationHandler<FreshContentRequirement>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, FreshContentRequirement requirement)
    {
        // 1. Example: Check a header or DB value
        // Real logic would probably need an injected Service to look up data
        var isFresh = DateTime.UtcNow.Hour < 12; // Example logic

        if (isFresh)
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}

```

### **Step C: Register and Use**

```csharp
// Program.cs
builder.Services.AddSingleton<IAuthorizationHandler, FreshContentHandler>();
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("FreshContentOnly", policy => policy.Requirements.Add(new FreshContentRequirement()));
});

// Controller
[Authorize(Policy = "FreshContentOnly")]
public IActionResult EditRecentPost() { ... }

```

---

### **Summary of Phase 3**

1. **Use Policies:** Never hardcode logic in Controllers. Group it in `Program.cs`.
2. **App Roles > Groups:** Always prefer **Azure App Roles** (`roles` claim) because they give you readable names (`Admin`). Use **Groups** (`groups` claim) only if Corporate IT forces you to map to AD IDs.
3. **Scopes:** Use `[RequiredScope]` for checking User Consent.
4. **Token Config:** Ensure `RoleClaimType` is correctly configured so .NET can "see" the `roles` array in the Azure token.

**Current State:**
Your API is robust. It checks authentication, it checks specific roles, and handles frontend permissions.

**The Missing Piece:**
How does **Microservice A** call **Microservice B** securely? What if there is no user logged in (Background Worker)?

Are you ready for **Phase 4: Microservices & Architecture**? (OBO Flow and Daemon Apps).

## **Phase 5: Production Readiness**

You have mastered the protocols, the code, and the architecture. This final phase is about making your system **Robust**, **Testable**, and **Secure** against real-world browser threats.

---

### **1. Token Caching (Performance)**

The On-Behalf-Of flow is powerful but expensive. Each `_tokenAcquisition.GetAccessTokenForUserAsync` call can result in a roundtrip to Azure AD. In a high-traffic system, this adds significant latency.

**The Problem:**
By default (`.AddInMemoryTokenCaches()`), the OBO token is cached in the RAM of a specific server instance.

- **Scenario:** You have 3 replicas of your API Gateway.
- **Request 1:** Hits Server A. OBO call happens. Token is cached in Server A's memory.
- **Request 2 (1ms later):** Hits Server B. Server B doesn't have the cache. **Another OBO call happens.**

**The Solution: Distributed Token Caching**
We must use a shared cache that all replicas can see, typically **Redis**.

**The `Microsoft.Identity.Web` Implementation:**

1. **Install Package:**`dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis`
2. **Configure in `Program.cs`:**
    
    ```csharp
    // Add Redis as a distributed cache
    builder.Services.AddStackExchangeRedisCache(options =>
    {
        options.Configuration = builder.Configuration.GetConnectionString("Redis");
    });
    
    // Wire up Microsoft.Identity.Web to use it
    builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        .AddMicrosoftIdentityWebApi(builder.Configuration.GetSection("AzureAd"))
        .EnableTokenAcquisitionToCallDownstreamApi()
        // SWAP THIS:
        // .AddInMemoryTokenCaches();
        .AddDistributedTokenCaches(); // <-- FOR PRODUCTION
    
    ```
    
- **Result:** The OBO token is now stored centrally in Redis. All 3 servers can read from it, dramatically reducing calls to Azure AD and improving latency.

---

### **2. Testing & Mocking (Stability)**

How do you run Unit Tests or Integration Tests on a Controller locked with `[Authorize(Roles = "Admin")]` without actually calling Azure AD every time?

**The Technique:** Mock `HttpContext.User`.
Your tests should **NEVER** depend on a live Azure connection.

### **Example: XUnit Test with a Mock User**

```csharp
public class AdminControllerTests
{
    [Fact]
    public void DeleteAction_WhenCalledByAdmin_ShouldReturnOk()
    {
        // ARRANGE

        // 1. Create a fake Admin claim
        var adminClaims = new List<Claim>
        {
            new Claim(ClaimTypes.NameIdentifier, "test-user-id"),
            new Claim("roles", "Admin") // Using the Azure AD "roles" claim type
        };
        var adminIdentity = new ClaimsIdentity(adminClaims, "TestAuthType");
        var adminPrincipal = new ClaimsPrincipal(adminIdentity);

        // 2. Create the Controller and inject the mock user
        var controller = new AdminController
        {
            ControllerContext = new ControllerContext
            {
                HttpContext = new DefaultHttpContext { User = adminPrincipal }
            }
        };

        // ACT
        var result = controller.DeleteImportantData();

        // ASSERT
        Assert.IsType<OkObjectResult>(result);
    }
}

```

- **Result:** The `[Authorize(Roles = "Admin")]` attribute checks `HttpContext.User`, sees the fake "Admin" role, and allows the test to execute.

---

### **3. The BFF Pattern (Backend for Frontend) - Security**

This pattern addresses the biggest security hole in modern SPA (Single Page Application) architecture.

**The Vulnerability:** Storing JWTs in **LocalStorage**.

- **How it works:** Your React/Angular app stores the Access Token in the browser's LocalStorage.
- **The Risk (XSS - Cross-Site Scripting):** If your site has a single XSS flaw (e.g., a vulnerable NPM package for rendering Markdown), an attacker can inject a script that executes `localStorage.getItem('jwt')` and sends the token to their server. They have now hijacked the user's session.

**The BFF Solution:**
You create a lightweight [ASP.NET](http://asp.net/) Core application (The BFF) that acts as a secure proxy. The Token never touches the browser's JavaScript environment.

**The Workflow:**

1. **Authentication:** User logs in. The BFF performs the OAuth2 flow with Azure AD.
2. **Storage:** The BFF stores the JWT Access and Refresh tokens in a secure, encrypted, **`HttpOnly` Cookie**.
3. **Result:** `HttpOnly` cookies are sent automatically by the browser on requests, but are **inaccessible to JavaScript**. `document.cookie` cannot read them. The XSS attack is blocked.
4. **API Calls:**
    - Angular calls `/api/orders` on the BFF (same domain, no CORS needed).
    - The BFF receives the request, pulls the JWT from the Cookie, and attaches it as a `Bearer` token to the downstream Microservice call.
- **`Microsoft.Identity.Web.UI`** has built-in support for this cookie-based authentication flow, making it easier to implement than starting from scratch.

---

### **4. Token Revocation (Advanced)**

**The Problem:** A user's laptop is stolen. You need to log them out of everything **immediately**.

- **JWTs are Stateless:** JWTs are valid until they expire. The API server doesn't check with Azure AD on every request. Even if you disable the user in Azure, their 15-minute token is still valid.

**Solutions:**

1. **Short-Lived Tokens:** Use very short access tokens (e.g., 5 minutes) and rely on Refresh Tokens. This minimizes the window of attack. This is the simplest approach.
2. **Reference Tokens:** A complex pattern where you don't issue a full JWT, but a random string. The API has to look up the string in a database (like Redis) on every request to get the claims. If you delete the entry, the user is logged out. This is stateful and adds latency.
3. **The "Revocation List" (JTI Claim):**
    - Add a unique ID (`jti`) to every token.
    - When you want to revoke, add that `jti` to a blacklist in Redis with a TTL matching the token's expiry.
    - Create a custom Policy that checks the `jti` against Redis on every request. This is the most robust stateless solution but adds a Redis check to the pipeline.

---

### **Congratulations! You have completed the Masterclass.**

You have moved from basic concepts to securing a complex, distributed system with microservices, leveraging Azure's most powerful identity features.

**Final Expert Checklist:**

- Is your user identity based on the immutable **`oid`** claim?
- Are you using **Policies** for authorization, not hardcoded strings?
- Are you using **OBO** for user-driven service-to-service calls?
- Are you using **Client Credentials** for machine-to-machine calls?
- Are you using **Distributed Caching** for OBO tokens?
- Are you using a **BFF with `HttpOnly` cookies** if you have a browser-based frontend?

This is the standard for building enterprise-grade, secure applications on Azure.