# CORS

Here is a comprehensive guide to mastering **CORS (Cross-Origin Resource Sharing)** in [ASP.NET](http://asp.net/) Core Web API, ranging from the basic concepts to expert configuration.

---

### **1. The Concept: What and Why?**

- **The Problem:** By default, browsers enforce the **Same-Origin Policy (SOP)**. This prevents JavaScript running on `http://my-react-app.com` from making an API call to `http://my-api.com`. The browser blocks the request to protect users.
- **The Solution (CORS):** The Server (API) must send specific HTTP headers (like `Access-Control-Allow-Origin`) telling the browser, *"It's okay, I trust `http://my-react-app.com`."*
- **Important:** CORS is **not** a security feature to stop hackers. It only stops browser-based requests. Tools like Postman or curl ignore CORS completely.

---

### **2. Basic Setup (Global Policy)**

In modern [ASP.NET](http://asp.net/) Core (.NET 6/7/8+), setup happens in `Program.cs`. You need two steps: **Define the Policy** (DI) and **Use the Middleware**.

### **Scenario A: Development Mode (Allow Everything)**

*Use this only for local testing. Never in production.*

```csharp
var builder = WebApplication.CreateBuilder(args);

// 1. Add CORS services
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll", builder =>
    {
        builder.AllowAnyOrigin()
               .AllowAnyMethod()
               .AllowAnyHeader();
    });
});

builder.Services.AddControllers();

var app = builder.Build();

// ... existing pipeline configuration ...

// 2. Enable CORS Middleware
// IMPORTANT: Must be placed AFTER UseRouting and BEFORE UseAuthorization
app.UseRouting();

app.UseCors("AllowAll"); // Apply the policy globally

app.UseAuthentication();
app.UseAuthorization();

app.MapControllers();

app.Run();

```

---

### **3. Production Setup (Specific Origins)**

For production, you must explicitly whitelist the client domains.

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCors(options =>
{
    options.AddPolicy("ProductionCorsPolicy", builder =>
    {
        builder.WithOrigins("<https://www.myclient.com>", "<https://admin.myclient.com>")
               .AllowAnyMethod()  // GET, POST, PUT, DELETE, etc.
               .AllowAnyHeader(); // Content-Type, Authorization, etc.
    });
});

```

**Common Mistake:**

- `https://www.site.com` is different from `http://www.site.com`.
- Trailing slashes matter: `https://site.com` works, but `https://site.com/` often causes mismatches in string comparisons unless the browser normalizes it. **Best practice: Do not use trailing slashes in `WithOrigins`.**

---

### **4. Controller-Level Granularity**

Sometimes you don't want a global policy. You might want `AllowAll` for a public weather endpoint, but `Strict` for an admin endpoint.

1. **Define Policies** in `Program.cs` (as shown above).
2. **Apply with Attributes** in Controllers.

```csharp
[ApiController]
[Route("api/[controller]")]
[EnableCors("ProductionCorsPolicy")] // Applies to all actions in this controller
public class UsersController : ControllerBase
{
    [HttpGet]
    public IActionResult GetAll() { ... }

    [HttpPost]
    [DisableCors] // Exception: This specific action won't use CORS
    public IActionResult Create() { ... }
}

```

---

### **5. Credentials (Cookies & Auth Headers)**

If your frontend is sending Cookies or Authentication Headers, and you are doing Cross-Origin requests, standard CORS fails. You need `AllowCredentials`.

**The Rule:** You **cannot** use `AllowAnyOrigin()` (`*`) when `AllowCredentials()` is set. The browser specification forbids it. You must specify exact origins.

```csharp
options.AddPolicy("SecurePolicy", builder =>
{
    builder.WithOrigins("<https://my-secure-app.com>") // Must be specific!
           .AllowCredentials()                       // Allows Cookies/Auth Headers
           .AllowAnyMethod()
           .AllowAnyHeader();
});

```

---

### **6. Exposing Custom Headers**

By default, browsers running JavaScript can only read "Safe" response headers (Content-Type, etc.). If your API returns a custom header (e.g., `X-Pagination-Total-Count`), the frontend React/Angular app won't see it unless you expose it.

```csharp
options.AddPolicy("ExposePagination", builder =>
{
    builder.WithOrigins("<https://client.com>")
           .WithExposedHeaders("X-Pagination-Total-Count", "X-Custom-ID");
});

```

---

### **7. Troubleshooting & Pitfalls**

If CORS isn't working, check these common issues:

1. **Middleware Order (Critical):**`app.UseCors()` **MUST** be placed between `app.UseRouting()` and `app.UseEndpoints()` (or `app.MapControllers()`). Ideally, place it before `app.UseAuthorization()`.
2. **The "Preflight" Request (OPTIONS):**
Browsers send a hidden HTTP `OPTIONS` request before a `POST`, `PUT`, or `DELETE`. If your server requires authentication for *everything*, the `OPTIONS` request might fail (because browsers don't send tokens on preflight).
    - *Fix:* [ASP.NET](http://asp.net/) Core `UseCors` handles OPTIONS automatically without auth, provided it is placed *before* `UseAuthorization` in the middleware pipeline.
3. **Localhost Issues:**
Browsers treat `localhost` and `127.0.0.1` as different origins. Also, a specific port (`localhost:3000` vs `localhost:5000`) makes it a different origin.
4. **Browser Cache:**
Browsers cache CORS headers. If you change settings in code and it doesn't seem to work, do a "Empty Cache and Hard Reload" in the browser.

### **Summary Checklist**

| Scenario | Solution |
| --- | --- |
| **Dev / Testing** | `AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader()` |
| **Production** | `WithOrigins("<https://domain.com>")` |
| **Cookies / Auth** | `AllowCredentials()` + Specific Origins (No wildcard `*`) |
| **Specific Actions** | Use `[EnableCors("PolicyName")]` attribute |
| **Reading Custom Headers** | `WithExposedHeaders("Header-Name")` |