# Builder Pattern

### 1. What is it?

The Builder is a creational design pattern that lets you construct complex objects step-by-step. It separates the construction of a complex object from its final representation, allowing the same construction process to create different representations. It is designed to provide a flexible solution to various object creation problems.

### 2. Why it is required?

The Builder pattern is required to solve two common problems in object creation:

1. **The "Telescopic Constructor":** When creating a complex object, you might have a single, monstrous constructor with a long list of optional parameters. To make it easier to use, you might create multiple overloaded constructors (a "telescope"), but this leads to code that is hard to read and maintain. For example, `new House(4, 2, true, true, false, null, "Modern")` is confusing.
2. **The "Subclass Explosion":** To handle different variations of an object, you might create a unique subclass for every possible configuration (e.g., `HouseWithGarage`, `HouseWithPool`, `HouseWithGarageAndPool`). This approach is not scalable and leads to a massive number of classes.

The Builder pattern solves these issues by extracting the object construction logic into a separate class.

### 3. Details and key points and examples in the reference Book

- **Core Concept:**
    - The pattern suggests extracting the object-construction code out of its own class and moving it to separate objects called **builders**.
- **Structure and Roles:**
    - **The Builder Interface:**
        - Declares product construction steps that are common to all types of builders (e.g., `buildWalls()`, `buildDoors()`).
    - **Concrete Builders:**
        - Provide different implementations of the construction steps. A concrete builder creates a specific *representation* of the product.
        - For example, a `WoodHouseBuilder` builds walls of wood, while a `CastleBuilder` builds them of stone, even though both are executing the `buildWalls` step.
    - **The Product:**
        - The resulting complex object. A key point from the book is that products constructed by different builders do not need to belong to the same class hierarchy.
        - **Book Example:** The same construction process can be used to build a `Car` object (using a `CarBuilder`) and a `CarManual` object (using a `CarManualBuilder`). These are two completely different types of products.
    - **The Director (Optional):**
        - This is a class that defines the order in which to call the construction steps.
        - The Director is useful for encapsulating common construction routines. For example, a `Director` might have `constructSportsCar()` and `constructSUV()` methods.
        - The client associates a builder with the director, the director runs the construction sequence, and the client then retrieves the result from the builder.
- **Key Process:**
    - The client creates a builder object.
    - The client (or a Director) executes a series of steps on the builder object. The important part is that you don't need to call all steps.
    - The client retrieves the final product from the builder. The Director is never aware of the final product's type, which keeps it decoupled.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:**
    - Use the pattern to get rid of a "telescopic constructor."
    - Use it when you want your code to be able to create different representations of some product (e.g., stone vs. wooden houses).
    - Use it to construct complex objects or Composite trees, as the construction process can be broken down into discrete, manageable steps.
- ⚠️ **When to Avoid (Anti-Pattern Warning):**
    - The pattern introduces multiple new classes and can be overkill if the object is simple and its creation logic is not complex.
    - If you don't have multiple representations of the object and the construction is straightforward, a simple constructor or a Factory Method is often a better choice.

### 5. Step By Step Detailed Rules to Map the concept to C# code

1. **Define the Builder Interface:** Create an interface (e.g., `IPizzaBuilder`) that defines all possible construction steps. These methods should typically return the builder interface itself to allow for a fluent, chainable syntax (e.g., `builder.SetSize().AddCheese()`). Also include a method to retrieve the final product (e.g., `GetPizza()`).
2. **Create the Product Class:** Define the complex object that is being built (e.g., `Pizza`). Its constructor should be made non-public (`internal` or `private`) to force clients to use a builder for its creation.
3. **Implement Concrete Builders:** Create one or more classes that implement the builder interface. Each builder will hold a private instance of the product it is building. The construction step methods will modify this internal product instance. The `GetResult()` method will return the final object.
4. **Create an Optional Director Class:** Create a `Director` class that can orchestrate the building process. It will contain methods that accept a builder interface as an argument and call a series of steps on it to construct a common product variation.
5. **Refactor Client Code:** The client is now responsible for creating the correct builder. It can then either pass this builder to a Director or call the building steps manually in any desired order. Finally, it calls the retrieval method on the builder to get the fully constructed object.

### 6. C# code Example which is not in the correct state

This "Bad Code" demonstrates the "Telescopic Constructor" problem. It's hard to create a `Pizza` object, and the code is unreadable and error-prone.

```csharp
// BAD CODE: Telescopic Constructor
using System.Collections.Generic;
using System.Text;

public class Pizza
{
    // A pizza can have many optional components.
    public string Size { get; }
    public bool HasExtraCheese { get; }
    public bool HasPepperoni { get; }
    public bool HasOlives { get; }
    public bool HasBacon { get; }

    // The main constructor with many parameters. It's hard to use directly.
    public Pizza(string size, bool extraCheese, bool pepperoni, bool olives, bool bacon)
    {
        Size = size;
        HasExtraCheese = extraCheese;
        HasPepperoni = pepperoni;
        HasOlives = olives;
        HasBacon = bacon;
    }

    // Overloaded "telescopic" constructors to make life "easier".
    public Pizza(string size)
        : this(size, false, false, false, false) { }

    public Pizza(string size, bool extraCheese, bool pepperoni)
        : this(size, extraCheese, pepperoni, false, false) { }

    // ... many more combinations could be added here.

    public override string ToString()
    {
        var sb = new StringBuilder();
        sb.Append($"A {Size} pizza with:");
        if (HasExtraCheese) sb.Append(" Extra Cheese,");
        if (HasPepperoni) sb.Append(" Pepperoni,");
        if (HasOlives) sb.Append(" Olives,");
        if (HasBacon) sb.Append(" Bacon,");
        return sb.ToString().TrimEnd(',');
    }
}

```

### 7. Applying the rules to make it correct

This "Good Code" refactors the `Pizza` creation using the Builder pattern, resulting in clean, readable, and flexible client code.

```csharp
// GOOD CODE: Applying the Builder Pattern
using System;
using System.Collections.Generic;
using System.Text;

// Rule 2: The Product class is now much simpler.
// Its constructor is internal, so it can only be created within this assembly (by a builder).
public class Pizza
{
    public string Size { get; set; }
    public bool HasExtraCheese { get; set; }
    public bool HasPepperoni { get; set; }
    public bool HasOlives { get; set; }
    public bool HasBacon { get; set; }

    internal Pizza() { } // Constructor is not public!

    public override string ToString()
    {
        var sb = new StringBuilder();
        sb.Append($"A {Size} pizza with:");
        if (HasExtraCheese) sb.Append(" Extra Cheese,");
        if (HasPepperoni) sb.Append(" Pepperoni,");
        if (HasOlives) sb.Append(" Olives,");
        if (HasBacon) sb.Append(" Bacon,");
        return sb.ToString().TrimEnd(',');
    }
}

// Rule 1: The Builder Interface
public interface IPizzaBuilder
{
    void Reset();
    IPizzaBuilder SetSize(string size);
    IPizzaBuilder AddExtraCheese();
    IPizzaBuilder AddPepperoni();
    IPizzaBuilder AddOlives();
    IPizzaBuilder AddBacon();
    Pizza GetPizza();
}

// Rule 3: A Concrete Builder implementation
public class PizzaBuilder : IPizzaBuilder
{
    private Pizza _pizza;

    public PizzaBuilder()
    {
        this.Reset();
    }

    public void Reset()
    {
        _pizza = new Pizza();
    }

    // Each step returns the builder to allow for fluent chaining.
    public IPizzaBuilder SetSize(string size)
    {
        _pizza.Size = size;
        return this;
    }
    public IPizzaBuilder AddExtraCheese()
    {
        _pizza.HasExtraCheese = true;
        return this;
    }
    public IPizzaBuilder AddPepperoni()
    {
        _pizza.HasPepperoni = true;
        return this;
    }
    public IPizzaBuilder AddOlives()
    {
        _pizza.HasOlives = true;
        return this;
    }
    public IPizzaBuilder AddBacon()
    {
        _pizza.HasBacon = true;
        return this;
    }

    // The final step returns the complete product.
    public Pizza GetPizza()
    {
        Pizza result = _pizza;
        this.Reset(); // Get ready for the next pizza
        return result;
    }
}

// Rule 4: The Optional Director
public class PizzeriaDirector
{
    public void ConstructMeatLoversPizza(IPizzaBuilder builder)
    {
        builder.Reset();
        builder.SetSize("Large")
               .AddExtraCheese()
               .AddPepperoni()
               .AddBacon();
    }

    public void ConstructVeggiePizza(IPizzaBuilder builder)
    {
        builder.Reset();
        builder.SetSize("Medium")
               .AddOlives();
    }
}

// Rule 5: Client Code
public static class Client
{
    public static void Main()
    {
        var builder = new PizzaBuilder();

        // --- Scenario 1: The client builds a custom pizza manually ---
        Pizza customPizza = builder.SetSize("Medium")
                                   .AddPepperoni()
                                   .AddOlives()
                                   .GetPizza();
        Console.WriteLine("Client built a custom pizza:");
        Console.WriteLine(customPizza);
        Console.WriteLine();

        // --- Scenario 2: The client uses a Director for a pre-defined pizza ---
        var director = new PizzeriaDirector();
        director.ConstructMeatLoversPizza(builder);
        Pizza meatLoversPizza = builder.GetPizza();
        Console.WriteLine("Director built a Meat Lovers pizza:");
        Console.WriteLine(meatLoversPizza);
    }
}

```

[Builder Pattern : Example 2](Builder%20Pattern/Builder%20Pattern%20Example%202%202d62749a7cfe81f59613f2ca7bb350d6.md)