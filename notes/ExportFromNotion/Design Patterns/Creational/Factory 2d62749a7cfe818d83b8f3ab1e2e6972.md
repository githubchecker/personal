# Factory

Of course. Here is the detailed breakdown for the Factory Design Pattern and its variations, based on your `CodeX` template.

---

### Factory Design Pattern

---

### 1. What is it?

The Factory Design Pattern is a creational pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. It encapsulates the object creation logic, moving it from the client code into a dedicated method or class. This pattern has two primary variations: **Factory Method** and **Abstract Factory**.

### 2. Why it is required?

It is required to solve the problem of tight coupling between a client and the concrete classes it needs to instantiate. When client code creates objects directly using the `new` operator, it becomes dependent on those concrete classes. If new types of objects need to be introduced, the client code must be modified, which violates the Open/Closed Principle. The Factory pattern delegates the responsibility of instantiation to a separate "factory," making the system more flexible and easier to extend.

### 3. Details and key points and examples in the reference Book

The book details two main forms of the Factory pattern: **Factory Method** and **Abstract Factory**.

### Variation 1: Factory Method

- **Core Idea:**
    - This pattern suggests replacing direct object construction calls (using `new`) with calls to a special *factory method*.
    - Subclasses can then **override** this factory method to change the class of the objects (products) that get created. This is why it's also known as a "Virtual Constructor."
- **Problem Solved:**
    - Imagine a logistics management application that initially only handles transportation by `Truck`. The code becomes tightly coupled to the `Truck` class.
    - When the requirement comes to add `Ship` transportation, it would require significant changes throughout the entire codebase, often involving large conditional statements to switch between object types.
- **Solution Structure:**
    - The core business logic is moved into a superclass (the **Creator**) which refers to the objects it needs via a common interface (the **Product**).
    - The Creator class declares an abstract or virtual `factory method` that returns an object of the Product type.
    - Subclasses (**Concrete Creators**) override this factory method to return specific types of objects (**Concrete Products**).
    - **Key Points & Example:**
        - All products (`Truck`, `Ship`) must follow a common interface (e.g., `ITransport`) which declares shared methods like `deliver()`.
        - The base `Logistics` class (Creator) has the core business logic, like planning a delivery, but it calls the factory method `createTransport()` to get a transport object.
        - A `RoadLogistics` subclass overrides `createTransport()` to return a `new Truck()`.
        - A `SeaLogistics` subclass overrides `createTransport()` to return a `new Ship()`.
        - The client code works with a creator instance (e.g., `RoadLogistics`) but doesn't care that it's getting a `Truck`. It only knows it's getting an `ITransport` object.

### Variation 2: Abstract Factory

- **Core Idea:**
    - This pattern lets you produce **families of related objects** without specifying their concrete classes. It's like a "factory of factories."
- **Problem Solved:**
    - Imagine a furniture shop simulator where you have families of products (`Chair`, `Sofa`) that come in different variants (`Modern`, `Victorian`).
    - You need a way to create a `ModernChair` and a `ModernSofa` together, ensuring that you don't accidentally get a `ModernChair` with a `VictorianSofa`, which would look mismatched.
- **Solution Structure:**
    - First, you declare abstract interfaces for each distinct product in the family (`IChair`, `ISofa`).
    - Next, you declare the **Abstract Factory** interface with a set of creation methods for all the abstract products (e.g., `CreateChair()`, `CreateSofa()`).
    - For each variant of the product family, you create a **Concrete Factory** class that implements the abstract factory interface.
    - **Key Points & Example:**
        - A `ModernFurnitureFactory` would implement the `IFurnitureFactory` interface. Its `CreateChair()` method would return a `ModernChair`, and its `CreateSofa()` method would return a `ModernSofa`.
        - A `VictorianFurnitureFactory` would similarly return `VictorianChair` and `VictorianSofa`.
        - The client code works with a factory (e.g., `IFurnitureFactory`) and asks it to create products. The client doesn't know about `ModernFurnitureFactory` or `VictorianFurnitureFactory`, only that it will receive compatible products (`IChair`, `ISofa`) from whichever factory it is given.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:**
    - Use **Factory Method** when you don't know beforehand the exact types of objects your code will need to work with.
    - Use **Factory Method** when you want to provide users of your library or framework with a way to extend its internal components.
    - Use **Abstract Factory** when your system needs to be independent of how its products are created, composed, and represented, and you are working with families of related objects.
    - Use **Abstract Factory** when you need to ensure that the products you are creating are from the same family or variant and are designed to work together.
- ⚠️ **When to Avoid (Anti-Pattern Warning):**
    - The patterns can introduce a lot of new subclasses and interfaces, which can overcomplicate the code if you only have a few object types that rarely change.
    - Avoid using them as a default practice. If your object creation logic is simple and stable, direct instantiation (`new`) is often sufficient and easier to read.

### 5. Step By Step Detailed Rules to Map the concept to C# code

Here we will focus on the **Factory Method** pattern.

1. **Define the Product Interface:** Create a common interface that all concrete product classes will implement. This interface declares the methods that the client (context) will use.
2. **Create Concrete Products:** Implement the Product interface in your concrete product classes (`Truck`, `Ship`, etc.).
3. **Define the Creator Class:** Create an `abstract` class that will act as the creator.
    - It should contain the business logic that relies on a product object.
    - Declare an `abstract` factory method that returns the Product interface type.
4. **Create Concrete Creators:** For each concrete product, create a concrete creator class that inherits from the abstract Creator.
    - Implement the `abstract` factory method using the `override` keyword.
    - Inside this method, instantiate and return the specific concrete product.
5. **Refactor Client Code:** The client code will now decide which concrete creator to instantiate. It then calls the business logic methods on that creator, never instantiating products directly.

### 6. C# code Example which is not in the correct state

This "Bad Code" shows a client class with a large conditional block for object creation, making it rigid and hard to extend.

```csharp
// BAD CODE: Tightly coupled and violates Open/Closed Principle
using System;
public enum TransportType { Road, Sea }

// 1. Products
public interface ITransport
{
    void Deliver();
}
public class Truck : ITransport
{
    public void Deliver() => Console.WriteLine("Delivering cargo by land in a truck.");
}
public class Ship : ITransport
{
    public void Deliver() => Console.WriteLine("Delivering cargo by sea in a ship.");
}
// Add more transport types here... like Train, Airplane...

// 2. The Client is coupled to all concrete products
public class LogisticsManager
{
    public void PlanDelivery(TransportType type)
    {
        ITransport transport;
        // This switch block must be modified for every new transport type.
        switch (type)
        {
            case TransportType.Road:
                transport = new Truck();
                break;
            case TransportType.Sea:
                transport = new Ship();
                break;
            // What if we add a Train? We have to change this class.
            default:
                throw new ArgumentException("Invalid transport type");
        }

        // The business logic that uses the product
        Console.WriteLine("Delivery plan in motion...");
        transport.Deliver();
    }
}

```

### 7. Applying the rules to make it correct

This "Good Code" refactors the example using the Factory Method pattern, making it flexible and easy to extend with new transport types.

```csharp
// GOOD CODE: Using Factory Method
using System;

// Rule 1: Define the Product Interface
public interface ITransport
{
    void Deliver();
}

// Rule 2: Create Concrete Products
public class Truck : ITransport
{
    public void Deliver() => Console.WriteLine("Delivering cargo by land in a truck.");
}

public class Ship : ITransport
{
    public void Deliver() => Console.WriteLine("Delivering cargo by sea in a ship.");
}

// Rule 3: Define the Abstract Creator Class
public abstract class Logistics
{
    // The core business logic - it doesn't know what product it's using.
    public void PlanDelivery()
    {
        // Call the factory method to get a product object.
        ITransport transport = CreateTransport();

        // Use the product.
        Console.WriteLine("Delivery plan in motion...");
        transport.Deliver();
    }

    // The factory method is abstract, forcing subclasses to implement it.
    public abstract ITransport CreateTransport();
}

// Rule 4: Create Concrete Creators
public class RoadLogistics : Logistics
{
    // Override the factory method to create and return a Truck.
    public override ITransport CreateTransport()
    {
        return new Truck();
    }
}

public class SeaLogistics : Logistics
{
    // Override the factory method to create and return a Ship.
    public override ITransport CreateTransport()
    {
        return new Ship();
    }
}

// Rule 5: Client code is now simple and decoupled.
// To add a new transport type like a Train, you would create a Train class
// and a TrainLogistics class. The client below would not need to change.
public class Client
{
    public void RunLogistics(Logistics logisticsProvider)
    {
        logisticsProvider.PlanDelivery();
    }
}

```

Of course. Let's first address your question about the Factory Method example and then provide a detailed example of the Abstract Factory pattern.

---

### Who provides the `logisticsProvider`?

This is an excellent question that gets to the heart of how these patterns are used in a real application.

In the Factory Method example, the `Client` or, more accurately, the **Composition Root** of the application is responsible for providing the specific `logisticsProvider` (`RoadLogistics` or `SeaLogistics`).

The Composition Root is the initial part of your application's code where all the classes are instantiated and wired together. This is typically done in the `Main` method, a startup class, or by a Dependency Injection container.

The decision of which concrete factory to create is based on configuration, environment, or user input. The client code that *uses* the factory (`Client` class in the example) should not be responsible for this decision; it should simply be given a factory to work with.

### C# Example of the Composition Root

Here is how the `Client` from the previous example would be set up and run in a main application entry point.

```csharp
// This is the entry point of the application (e.g., Program.cs)
public class Application
{
    private Logistics _logisticsProvider;
    private readonly Client _client;

    public Application(string environment)
    {
        // 1. READ CONFIGURATION
        // The application determines which factory to use based on configuration,
        // user input, environment variables, etc.
        Console.WriteLine($"Application configured to run in '{environment}' mode.");

        // 2. CHOOSE THE CONCRETE FACTORY
        // Based on the configuration, it instantiates the appropriate concrete factory.
        if (environment.Equals("Sea", StringComparison.OrdinalIgnoreCase))
        {
            _logisticsProvider = new SeaLogistics();
        }
        else if (environment.Equals("Road", StringComparison.OrdinalIgnoreCase))
        {
            _logisticsProvider = new RoadLogistics();
        }
        else
        {
            throw new ArgumentException("Unknown environment specified.");
        }

        // 3. INJECT THE DEPENDENCY
        // The chosen factory is passed to the client.
        _client = new Client();
    }

    public void Main()
    {
        // 4. RUN THE CLIENT CODE
        // The client runs its business logic, using the factory it was given,
        // completely unaware of whether it's dealing with trucks or ships.
        _client.RunLogistics(_logisticsProvider);
    }
}

public static class Program
{
    public static void Main(string[] args)
    {
        // --- Scenario 1: Configure for Road Transport ---
        var roadApp = new Application("Road");
        roadApp.Main();

        Console.WriteLine("\\n--------------------------\\n");

        // --- Scenario 2: Configure for Sea Transport ---
        var seaApp = new Application("Sea");
        seaApp.Main();
    }
}

```