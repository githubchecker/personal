# SOLID

### S: Single Responsibility Principle (SRP)

---

### 1. What is it?

The Single Responsibility Principle (SRP) states that a class should have only **one reason to change**. This means a class should have a single, well-defined job or responsibility.

### 2. Why it is required?

This principle is required to reduce complexity. When a class has multiple responsibilities, changes related to one responsibility can inadvertently break the logic for another. It also makes the code harder to understand and maintain. By separating responsibilities, classes become smaller, more focused, and easier to test and reuse.

### 3. Details and key points from the reference Book

- The book defines the principle as "A class should have just one reason to change."
- It highlights that problems emerge as a program grows. A class that does too many things becomes a "God Object" that is difficult to understand and risky to modify.
- **Book Example:** The book uses an `Employee` class that manages employee data but also contains logic to `printTimeSheetReport()`. These are two separate responsibilities. A change in the timesheet report's format (a presentation concern) would force a change in the `Employee` class (a data management concern). The solution is to move the report-related logic to a separate `TimeSheetReport` class.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:**
    - When a class is becoming large and difficult to manage.
    - When changes to one small part of a class's functionality require re-testing the entire class.
    - When you want to improve code reusability (a focused class is easier to reuse).
- ⚠️ **When to Avoid:**
    - In very small or simple applications, strictly applying SRP can lead to an explosion of tiny classes, which might be an over-engineering for the problem at hand.

### 5. Step By Step Detailed Rules to Map the concept to C# code

1. **Analyze a Class:** Look at a class and identify its core responsibilities. Ask, "What are the different reasons this class might need to change?"
2. **Identify Distinct Responsibilities:** Group methods and properties that relate to a single job. For instance, data persistence logic is one responsibility; business rule validation is another.
3. **Extract Each Responsibility:** For each identified responsibility, create a new, separate class.
4. **Delegate from the Original Class:** The original class (or a client that used it) should now hold a reference to the new classes and delegate the specific tasks to them.

### 6. C# code Example which is not in the correct state

```csharp
// BAD CODE: This class violates SRP.
public class Invoice
{
    public long InvoiceNumber { get; set; }
    public decimal Amount { get; set; }
    public DateTime InvoiceDate { get; set; }

    // Responsibility 1: Business Logic
    public void CalculateTotal()
    {
        // ... logic to calculate total with taxes and discounts
    }

    // Responsibility 2: Data Persistence
    public void SaveToDatabase()
    {
        // ... logic to connect to a DB and save the invoice
    }

    // Responsibility 3: Presentation
    public void PrintInvoice()
    {
        // ... logic to format and print the invoice
    }
}

```

### 7. Applying the rules to make it correct

```csharp
// GOOD CODE: Each class has a single responsibility.
public class Invoice
{
    public long InvoiceNumber { get; set; }
    public decimal Amount { get; set; }
    public DateTime InvoiceDate { get; set; }

    public void CalculateTotal()
    {
        // ... logic to calculate total with taxes and discounts
    }
}

// Responsibility 2: Data Persistence
public class InvoiceRepository
{
    public void Save(Invoice invoice)
    {
        // ... logic to connect to a DB and save the invoice
    }
}

// Responsibility 3: Presentation
public class InvoicePrinter
{
    public void Print(Invoice invoice)
    {
        // ... logic to format and print the invoice
    }
}

```

---

### O: Open/Closed Principle (OCP)

---

### 1. What is it?

The Open/Closed Principle states that software entities (classes, modules, functions) should be **open for extension, but closed for modification**. This means you should be able to add new functionality without changing existing, working code.

### 2. Why it is required?

It is required to prevent introducing bugs into existing, stable code. When you modify a class that is already tested and in use, you risk breaking its current functionality. By extending the class with new behavior (often through inheritance or composition), you add features without touching the original code.

### 3. Details and key points from the reference Book

- The principle is about keeping existing code from breaking when you implement new features.
- **"Closed"** means the class is developed, tested, and ready to be used by other classes. Its interface is stable.
- **"Open"** means you can produce a subclass (or use composition) to add new behaviors.
- **Book Example:** An `Order` class calculates shipping costs using a large `if/else` block for different shipping methods ("ground", "air"). To add a new "sea" shipping method, you must modify the `Order` class. The solution is to apply the **Strategy Pattern**: extract the shipping logic into a `Shipping` interface and create separate classes (`GroundShipping`, `AirShipping`) that implement it. The `Order` class can then be configured with any shipping strategy, allowing new ones to be added without changing `Order`.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:**
    - When you have a class where you anticipate new variations will be frequently added (e.g., new report formats, new calculation rules).
    - When developing a framework or library that others will extend.
- ⚠️ **When to Avoid:**
    - The book warns that this principle is not for fixing bugs. If you find a bug in existing code, you should modify the class to fix it.
    - Don't apply it prematurely to every part of your code, as it adds a layer of abstraction that can increase complexity if that area never actually needs to be extended.

### 5. Step By Step Detailed Rules to Map the concept to C# code

1. **Identify Areas of Variation:** Find parts of your code that are likely to change or have new variations added in the future (e.g., a `switch` statement based on a type).
2. **Create an Abstraction:** Define an interface or an abstract base class for the behavior that varies.
3. **Implement Concrete Variations:** Create new classes that implement the interface, with each class representing one variation of the behavior.
4. **Use Composition/Dependency Injection:** The original class (now called the context) should hold a reference to the abstraction (the interface) and delegate the work to it.

### 6. C# code Example which is not in the correct state

```csharp
// BAD CODE: This class is not closed for modification.
public enum ReportType { Csv, Pdf }
public class ReportGenerator
{
    public void Generate(ReportType type)
    {
        if (type == ReportType.Csv)
        {
            Console.WriteLine("Generating CSV report...");
        }
        else if (type == ReportType.Pdf)
        {
            Console.WriteLine("Generating PDF report...");
        }
        // To add a new report type (e.g., XML), we must MODIFY this class.
    }
}
```

### 7. Applying the rules to make it correct

```csharp
// GOOD CODE: Open for extension, closed for modification.
public interface IReportGenerator
{
    void Generate();
}

public class CsvReportGenerator : IReportGenerator
{
    public void Generate() =&gt; Console.WriteLine("Generating CSV report...");
}

public class PdfReportGenerator : IReportGenerator
{
    public void Generate() =&gt; Console.WriteLine("Generating PDF report...");
}

// We can now add an XmlReportGenerator class without changing any existing code.
public class XmlReportGenerator : IReportGenerator
{
    public void Generate() =&gt; Console.WriteLine("Generating XML report...");
}

// The client code can now use any generator.
public class ReportService
{
    public void GenerateReport(IReportGenerator generator)
    {
        generator.Generate();
    }
}
```

---

### L: Liskov Substitution Principle (LSP)

---

### 1. What is it?

The Liskov Substitution Principle states that objects of a superclass should be substitutable with objects of its subclasses without breaking the application. In simpler terms, a subclass should not behave in a way that the client code using the superclass does not expect.

### 2. Why it is required?

It is required to ensure that inheritance and polymorphism work correctly and reliably. If a subclass violates the contract of its superclass (e.g., by throwing an unexpected exception or doing nothing when it's supposed to do something), it can cause subtle and hard-to-find bugs in the client code that uses the base class.

### 3. Details and key points from the reference Book

- The book defines it as: "When extending a class, remember that you should be able to pass objects of the subclass in place of objects of the parent class without breaking the client code."
- A subclass should **extend** the base behavior, not replace it with something completely different.
- **Formal Rules Mentioned:**
    - Parameter types in an overridden method should be the same or more abstract than in the base class.
    - Return types should be the same or a subtype.
    - An overridden method should not throw new types of exceptions that the base method isn't expected to throw.
    - A subclass shouldn't strengthen pre-conditions (e.g., an `Add(int number)` method in the parent should not be overridden to only accept positive numbers in the child).
- **Book Example:** A `Document` class has a `save()` method. A `ReadOnlyDocument` subclass inherits from it but overrides `save()` to throw an exception because it cannot be saved. This is an LSP violation. Client code that works with a list of `Document` objects will crash if it encounters a `ReadOnlyDocument`. The solution is to rethink the hierarchy: have a base `Document` class (read-only by default) and a `WritableDocument` subclass that adds the save functionality.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:** This principle should **always** be followed whenever you use inheritance. It's a fundamental rule for correct object-oriented design, not an optional pattern.
- ⚠️ **When to Avoid:** You "avoid" violating it by carefully designing your inheritance hierarchies. If you find yourself needing to violate LSP, it's a strong sign that inheritance is the wrong tool for the job and you should favor composition instead.

### 5. Step By Step Detailed Rules to Map the concept to C# code

1. **Analyze the Base Class Contract:** When inheriting, understand the expected behavior of every `virtual` or `abstract` method. This includes what it does, what it returns, and what exceptions it might throw.
2. **Ensure Subclass Adherence:** In your subclass, ensure your overridden methods honor the parent's contract.
3. **Don't Throw New Exceptions:** Do not throw exceptions from an overridden method unless they are the same type as, or a subtype of, exceptions the base method is declared to throw.
4. **Do Not Implement Empty Methods:** If a subclass can't meaningfully implement a method from its parent, it's a sign that the inheritance relationship is incorrect.

### 6. C# code Example which is not in the correct state

```csharp
// BAD CODE: Classic Rectangle/Square violation of LSP.
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    public int Area => Width * Height;
}

public class Square : Rectangle
{
    public override int Width
    {
        get => base.Width;
        set { base.Width = base.Height = value; }
    }
    public override int Height
    {
        get => base.Height;
        set { base.Width = base.Height = value; }
    }
}

// Client code that breaks
public class AreaCalculator
{
    public static void Test(Rectangle r)
    {
        r.Width = 5;
        r.Height = 10;
        // The client EXPECTS the area to be 50.
        // For a Square, this will be 100, which is an unexpected side-effect.
        Console.WriteLine($"Expected 50, but got: {r.Area}");
    }
}

```

### 7. Applying the rules to make it correct

```csharp
// GOOD CODE: Respecting LSP by using a better abstraction.
// A square is not a substitutable rectangle. The hierarchy was wrong.
public abstract class Shape
{
    public abstract int Area { get; }
}

public class Rectangle : Shape
{
    public int Width { get; set; }
    public int Height { get; set; }
    public override int Area => Width * Height;
}

public class Square : Shape
{
    public int Side { get; set; }
    public override int Area => Side * Side;
}

// The client code can work with any Shape abstractly, and the behavior is predictable.

```

---

### I: Interface Segregation Principle (ISP)

---

### 1. What is it?

The Interface Segregation Principle states that **clients should not be forced to depend on methods they do not use**. In practice, this means you should favor many small, specific interfaces over one large, general-purpose ("fat") interface.

### 2. Why it is required?

This principle is required to keep systems decoupled and easier to maintain. When a class implements a "fat" interface, it is forced to provide implementations for methods it doesn't need, which often leads to empty or exception-throwing methods. Furthermore, if that fat interface changes, it can force a recompilation of client classes that don't even use the changed methods.

### 3. Details and key points from the reference Book

- The principle is about making interfaces narrow enough that clients don't have to implement unnecessary behaviors.
- **Book Example:** A single, "fat" `ICloudProvider` interface includes `storeFile()`, `createServer()`, and `getCDNAddress()`. A class like `AmazonProvider` can implement all of these. However, a class like `DropboxProvider` can only `storeFile()`. The `DropboxProvider` class is forced to implement `createServer()` and `getCDNAddress()` anyway, likely by throwing a `NotSupportedException`. The solution is to segregate the fat interface into smaller, more focused interfaces: `ICloudStorage`, `ICloudHosting`, and `ICdnProvider`. A class can then implement only the interfaces it truly supports.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:**
    - When you notice that classes implementing an interface often leave several methods empty or throwing exceptions.
    - When an interface is becoming very large and covers multiple distinct areas of functionality.
- ⚠️ **When to Avoid:**
    - The book warns: "Don't further divide an interface which is already quite specific." Creating too many tiny interfaces can make the code more complex by increasing the number of types you have to manage. Find the right balance.

### 5. Step By Step Detailed Rules to Map the concept to C# code

1. **Analyze Fat Interfaces:** Look at your large interfaces and identify distinct groups of methods that represent separate capabilities.
2. **Extract to New Interfaces:** For each group of methods, create a new, smaller, more specific interface.
3. **Implement Specific Interfaces:** Change your classes to implement the new, smaller interfaces instead of the single large one. A class can implement multiple small interfaces if needed.
4. **Update Client Code:** Refactor client code to depend on the new, smaller interfaces that they actually need.

### 6. C# code Example which is not in the correct state```csharp

```csharp
// BAD CODE: A fat interface that forces classes to implement too much.
public interface IMachine
{
    void Print();
    void Staple();
    void Fax();
}

// This is fine.
public class MultiFunctionPrinter : IMachine
{
    public void Print() => Console.WriteLine("Printing document...");
    public void Staple() => Console.WriteLine("Stapling document...");
    public void Fax() => Console.WriteLine("Faxing document...");
}

// This class is forced to implement methods it doesn't support.
public class SimplePrinter : IMachine
{
    public void Print() => Console.WriteLine("Printing document...");

    public void Staple() => throw new NotImplementedException("This printer cannot staple.");

    public void Fax() => throw new NotImplementedException("This printer cannot fax.");
}
```

### 7. Applying the rules to make it correct

```csharp
// GOOD CODE: Interfaces are segregated by responsibility.
public interface IPrinter
{
    void Print();
}
public interface IStapler
{
    void Staple();
}
public interface IFax
{
    void Fax();
}

// A MultiFunction device can implement all interfaces.
public class MultiFunctionPrinter : IPrinter, IStapler, IFax
{
    public void Print() => Console.WriteLine("Printing document...");
    public void Staple() => Console.WriteLine("Stapling document...");
    public void Fax() => Console.WriteLine("Faxing document...");
}

// A simple printer only needs to implement what it can do.
public class SimplePrinter : IPrinter
{
    public void Print() => Console.WriteLine("Printing document...");
}

```

---

### D: Dependency Inversion Principle (DIP)

---

### 1. What is it?

The Dependency Inversion Principle has two parts:

1. **High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces).**
2. **Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.**

In simpler terms, your business logic (high-level) should not be tightly coupled to specific, low-level implementation details like a particular database, a file logger, or an email service.

### 2. Why it is required?

It is required to build loosely coupled, flexible, and maintainable systems. By making high-level modules depend on abstractions, you can easily swap out the low-level implementations without changing the high-level business logic at all. This makes your code easier to test (you can provide a "mock" implementation) and adapt to new requirements (e.g., changing from SQL Server to PostgreSQL).

### 3. Details and key points from the reference Book

- **High-level classes** contain complex business logic, while **low-level classes** implement basic operations like writing to a disk or a database.
- The principle suggests changing the direction of the dependency. Instead of `BusinessLogic -> ConcreteDatabase`, the relationship becomes `BusinessLogic -> IDatabase <- ConcreteDatabase`.
- The **abstraction** (`IDatabase` interface) is "owned" by the high-level layer. The low-level module then implements this abstraction. This is why it's called an "inversion"—the low-level module now depends on an abstraction defined by the high-level one.
- **Book Example:** A `BudgetReport` (high-level) class has a direct dependency on a `MySQLDatabase` (low-level) class. This is a violation. The solution is to create an `IDatabase` interface. `BudgetReport` now depends only on `IDatabase`. The `MySQLDatabase` class is modified to implement the `IDatabase` interface. Now, you can create a `MongoDB` class that also implements `IDatabase` and switch it out without changing `BudgetReport`.

### 4. When to Use vs. When to Avoid?

- ✅ **When to Use:** This principle should be used pervasively in modern application development. It is the core idea behind **Dependency Injection** (DI) and is fundamental to building any testable, scalable, and maintainable application.
- ⚠️ **When to Avoid:** In the simplest of applications or scripts where you know the implementation details will never change, it might be overkill. However, for any system expected to grow or be maintained, this principle is essential.

### 5. Step By Step Detailed Rules to Map the concept to C# code

1. **Identify High-Level and Low-Level Modules:** Find where your core business logic (`high-level`) is directly using concrete implementation details (`low-level`), especially with the `new` keyword.
2. **Create an Abstraction:** Define an interface that the high-level module needs. This interface should be in terms of the business logic, not the low-level details.
3. **Depend on the Abstraction:** Change the high-level module to depend on the new interface, typically by accepting it in the constructor (this is Dependency Injection).
4. **Implement the Abstraction:** Make your low-level concrete class implement the new interface.
5. **Use a DI Container (or pure DI):** In your application's entry point (the Composition Root), configure which concrete implementation to provide for that interface. The DI container will handle "injecting" the concrete class into your high-level module.

### 6. C# code Example which is not in the correct state

```csharp
// BAD CODE: High-level module depends directly on a low-level module.
public class FileLogger
{
    public void Log(string message)
    {
        // ... logic to write message to a file
    }
}

public class UserManager
{
    private readonly FileLogger _logger;

    public UserManager()
    {
        // Direct dependency on a concrete implementation!
        // This is a violation of DIP.
        _logger = new FileLogger();
    }

    public void CreateUser(string username)
    {
        _logger.Log($"User '{username}' created.");
        // ... business logic
    }
}

```

### 7. Applying the rules to make it correct

```csharp
// GOOD CODE: Both modules depend on an abstraction.

// Rule 2: Create an abstraction.
public interface ILogger
{
    void Log(string message);
}

// Rule 4: The low-level detail implements the abstraction.
public class FileLogger : ILogger
{
    public void Log(string message) => Console.WriteLine($"[File Log]: {message}");
}
public class DatabaseLogger : ILogger
{
    public void Log(string message) => Console.WriteLine($"[DB Log]: {message}");
}

// Rule 3: The high-level module depends on the abstraction.
public class UserManager
{
    private readonly ILogger _logger;

    // The dependency is "injected" via the constructor.
    public UserManager(ILogger logger)
    {
        _logger = logger;
    }

    public void CreateUser(string username)
    {
        _logger.Log($"User '{username}' created.");
        // ... business logic
    }
}

// Rule 5: The Composition Root wires everything together.
public class Program
{
    public static void Main()
    {
        // We can easily swap the implementation without changing UserManager.
        ILogger logger = new DatabaseLogger();
        var userManager = new UserManager(logger);

        userManager.CreateUser("testuser");
    }
}

```