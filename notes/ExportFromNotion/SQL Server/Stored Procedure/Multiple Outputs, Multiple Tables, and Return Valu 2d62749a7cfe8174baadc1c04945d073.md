# Multiple Outputs, Multiple Tables, and Return Values

Here is the precise guide on handling **Multiple Outputs, Multiple Tables, and Return Values** in Stored Procedures, including how to handle the data flow from Child to Parent.

---

# üìò Phase 1: The Child SP (The Producer)

To return everything at once (Return Status, Multiple Variables, and Multiple Tables), your Child SP looks like this:

### Anatomy of a Complex SP

1. **Output Parameters:** Defined in the header with `OUTPUT`.
2. **Return Value:** `RETURN` keyword (Integers only).
3. **Result Sets:** Standard `SELECT` statements (Can have multiple).

```sql
CREATE PROCEDURE dbo.usp_ComplexChild
    @InputID INT,
    @OutputStatus VARCHAR(50) OUTPUT, -- üì§ 1. Output Param
    @OutputCount INT OUTPUT           -- üì§ 1. Output Param
AS
BEGIN
    SET NOCOUNT ON;

    -- ‚öôÔ∏è Logic: Set Output Parameters
    SELECT @OutputStatus = 'Processed', @OutputCount = 100;

    -- üìÑ 2. First Result Set (Table 1)
    SELECT Id, UserName FROM Users WHERE Id = @InputID;

    -- üìÑ 2. Second Result Set (Table 2)
    SELECT OrderId, Amount FROM Orders WHERE UserId = @InputID;

    -- üî¢ 3. Return Value (Status Code)
    -- Must be the LAST executable line usually
    IF @InputID > 0
        RETURN 0; -- Success
    ELSE
        RETURN 1; -- Error
END

```

---

# üîó Phase 2: The Parent SP (The Consumer)

Here is exactly how a Parent SP captures these values.

### üõë The Limitation (Crucial Concept)

SQL Server T-SQL (Parent SP) **cannot** natively capture *multiple* Result Sets (Table 1 & Table 2) from a single `EXEC` call into variables.

- [**ADO.NET](http://ado.net/) (C#)** can handle this easily (`reader.NextResult()`).
- **Parent SP** needs a workaround (See Phase 3) to capture the tables.

However, capturing **Output Parameters** and the **Return Value** is straightforward.

### Capturing Values (Syntax)

```sql
CREATE PROCEDURE dbo.usp_ParentCaller
AS
BEGIN
    SET NOCOUNT ON;

    -- A. Declare variables to hold the outputs
    DECLARE @RetCode INT;
    DECLARE @MyStatus VARCHAR(50);
    DECLARE @MyCount INT;

    -- B. Execute with Special Syntax
    EXEC @RetCode = dbo.usp_ComplexChild  -- Capture Return Value
         @InputID = 10,
         @OutputStatus = @MyStatus OUTPUT, -- Capture Output Param
         @OutputCount = @MyCount OUTPUT;   -- Capture Output Param

    -- C. Use the Data
    PRINT 'Return Code: ' + CAST(@RetCode AS VARCHAR);
    PRINT 'Status: ' + @MyStatus;
    PRINT 'Count: '  + CAST(@MyCount AS VARCHAR);

    -- ‚ö†Ô∏è Note: The two SELECT statements (Tables) from the Child
    -- will simply "pass through" the Parent and go straight to the Client.
    -- The Parent CANNOT see the data inside them using this method.
END

```

---

# üß† Phase 3: Capturing Tables in Parent (The Workarounds)

Since `EXEC` cannot pour two tables into variables, how does a Parent access the **Table Data** generated by a Child?

### Option A: The `#TempTable` Approach (Standard)

Scope inheritance allows the Child to write to a table created by the Parent.

1. **Parent:** Creates `#UserTable` and `#OrderTable`.
2. **Parent:** Calls Child.
3. **Child:** Does `INSERT INTO #UserTable...` instead of `SELECT`.
4. **Parent:** Now reads `#UserTable`.

### Option B: INSERT...EXEC (Capture One Table Only)

If the Child returns **only one** table, the Parent can capture it.

```sql
DECLARE @CapturedTable TABLE (Id INT, Name VARCHAR(50));

INSERT INTO @CapturedTable
EXEC dbo.usp_GetSingleResult;

-- Now Parent has the data
SELECT * FROM @CapturedTable;

```

### Option C: JSON Output (Modern / Expert)

This is the cleanest way to pass complex datasets (multiple tables) from Child to Parent without Temp Table dependency. **Child returns data as strings.**

**The Child:**

```sql
CREATE PROCEDURE dbo.usp_Child_JSON
    @Table1Json NVARCHAR(MAX) OUTPUT,
    @Table2Json NVARCHAR(MAX) OUTPUT
AS
BEGIN
    -- Serialize Tables to JSON
    SET @Table1Json = (SELECT * FROM Users FOR JSON AUTO);
    SET @Table2Json = (SELECT * FROM Orders FOR JSON AUTO);
END

```

**The Parent:**

```sql
DECLARE @J1 NVARCHAR(MAX), @J2 NVARCHAR(MAX);

EXEC dbo.usp_Child_JSON
    @Table1Json = @J1 OUTPUT,
    @Table2Json = @J2 OUTPUT;

-- Parse JSON back to Table
SELECT * FROM OPENJSON(@J1) WITH (Id INT, Name VARCHAR(50));
SELECT * FROM OPENJSON(@J2) WITH (OrderId INT, Amount MONEY);

```

---

# üèÜ Summary: SP Precise Data Flow

| Feature | Child SP Logic | Parent SP Logic to Access |
| --- | --- | --- |
| **Return Code** | `RETURN 0;` (Int Only) | `EXEC @Var = dbo.Name ...` |
| **Output Param** | `SET @P = 10` (Any Type) | `EXEC ... @Param = @Var OUTPUT` |
| **1 Table** | `SELECT * FROM T` | `INSERT INTO @T EXEC dbo.Name` |
| **2+ Tables** | `SELECT...; SELECT...;` | **Impossible** directly. Use Shared `#Temp` or JSON. |

### üîç Expert Tips

1. **Return Code:** Use strictly for **Execution Status** (0 = Success, -1 = Deadlock, etc.). Do not use it for Business Data (like a CustomerID).
2. **Output Params:** Use these for single scalar values (New Identity ID, Totals, calculated Dates).
3. **Result Sets:** Use these for Data Grids. If C# is calling SQL, returning multiple `SELECT`s is fine. If SQL is calling SQL, try to avoid returning `SELECT` sets; use `#TempTables` instead for better performance and control.