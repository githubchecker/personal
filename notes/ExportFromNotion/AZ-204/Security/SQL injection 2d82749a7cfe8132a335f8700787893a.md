# SQL injection

# SQL Injection Mastery: The .NET & SQL Server Edition

## Curriculum Syllabus

### Phase 1: The Fundamentals ([ADO.NET](http://ado.net/) Deep Dive)

1. **Definition**: How AST Mutation actually works looking at `SqlCommand`.
2. [**ADO.NET](http://ado.net/) Vulnerability**: The `string.Format` trap in `SqlCommand`.
3. **Tautologies**: Bypassing Login Logic with `OR 1=1`.
4. **Union-Based**: Merging result sets (`UNION ALL`) to steal data.

### Phase 2: The Attack Surface (SQL Server Specifics)

1. **Stored Procedures**: Why `EXEC(@sql)` is just as dangerous as inline SQL.
2. **Second Order SQLi**: Storing malicious data to be triggered later.
3. **Blind SQLi**: Using `WAITFOR DELAY` to infer data bit-by-bit.

### Phase 3: The Shield (The .NET Defense)

1. [**ADO.NET](http://ado.net/) Parameterization**: The only correct way to use `SqlParameter`.
2. **EF Core 8.0**: `FromSqlRaw` (Dangerous) vs `FromSqlInterpolated` (Safe).
3. **Dapper Micro-ORM**: Why `Query<T>(sql, param)` is safe and `Query<T>(sql + input)` is dead.
4. **Safe Stored Procedures**: Using `sp_executesql` for dynamic sorting.
5. **Least Privilege**: Configuring the SQL User limits.

---

## Phase 1: The Fundamentals ([ADO.NET](http://ado.net/) Deep Dive)

*Goal: Understand how poor C# code destroys Database security.*

### 1. Definition & Mechanics

**Q: How does Injection actually alter the query structure?**

- **The Concept (AST Mutation):**
SQL Server parses a query into an **Abstract Syntax Tree (AST)** before running it.
Injection breaks the tree structure, turning "Data" into "Code".

### 2. [ADO.NET](http://ado.net/) Vulnerability

**Q: The most common mistake in .NET History.**

- **Vulnerable Code (`SqlCommand`):**
    
    ```csharp
    public void GetUser(string username) {
        using var conn = new SqlConnection(_connString);
        conn.Open();
    
        // BAD: Concatenation happens BEFORE the SQL Server sees the query.
        string sql = "SELECT * FROM Users WHERE Name = '" + username + "'";
    
        using var cmd = new SqlCommand(sql, conn);
        var reader = cmd.ExecuteReader();
    }
    
    ```
    
- **The Checkmate:**
    - Input: `x'; DROP TABLE Users; --`
    - Resulting SQL: `SELECT * FROM Users WHERE Name = 'x'; DROP TABLE Users; --'`
    - **Result:** The user is selected (returns nothing), and then the Table is deleted.
    - **Sample Console Output:**
    (The next time you try to login, the app crashes because the table is gone).
        
        ```
        System.Data.SqlClient.SqlException: Invalid object name 'Users'.
        
        ```
        

---

### 3. Tautologies

**Q: Bypassing Logic Gates.**

- **The Scenario:** A Login Screen checking `User` and `Password`.
- **Vulnerable SQL:**
    
    ```sql
    SELECT * FROM Users WHERE Username = '$u' AND Password = '$p'
    
    ```
    
- **The Attack:**
    - Input `$u`: `admin' --`
    - Result: `SELECT * FROM Users WHERE Username = 'admin' --' AND Password = '...'`
    - *Effect:* The `-` comments out the password check. You are logged in as Admin without a password.
    - **Sample App Behavior:**
        - **Normal:** "Welcome, User!"
        - **Attack:** "Welcome, **Administrator**! (Admin Panel Unlocked)"

---

### 4. Union-Based SQLi

**Q: Stealing data from other tables.**

- **The Mechanism:**
Use `UNION ALL` to append results from a different table to the visible output.
- **The Attack:**
    - Original: `SELECT Title, Body FROM Posts WHERE Id = 1`
    - Input: `1 UNION ALL SELECT Username, Password FROM Users`
    - Result: The page displays Post content, followed by the Database Credentials.
    - **Sample Page Output:**
        
        
        | Post Title | Body Content |
        | --- | --- |
        | "How to cook" | "Use better ingredients..." |
        | **"admin"** | **"P@ssw0rd123!"** |
        | *(The attacker sees your secrets rendered as if they were blog posts).* |  |

---

---

## Phase 2: The Attack Surface (SQL Server Specifics)

*Goal: Understanding advanced vectors beyond simple SELECTs.*

### 5. Stored Procedures (The Myth)

**Q: "I use Stored Procs, so I am safe, right?" (WRONG).**

- **The Myth:** Stored Procedures are automatically safe.
- **The Reality:** If you use **Dynamic SQL** (`EXEC`) inside the proc, it is just as vulnerable.
- **Vulnerable Code (T-SQL):**
    
    ```sql
    CREATE PROCEDURE sp_SearchUsers (@name NVARCHAR(50))
    AS
    BEGIN
        -- BAD: Concatenating inside T-SQL
        DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM Users WHERE Name = ''' + @name + '''';
        EXEC(@sql);
    END
    
    ```
    
- **The Fix:**
Never use `EXEC(@sql)` with user input. Use parameterization inside the proc (See Phase 3).

---

### 6. Second Order SQLi

**Q: The Time Bomb.**

- **Scenario:**
    1. **Injection:** You create an account with username `admin' --`.
    2. **Safety:** The Registration page uses Parameters, so the username is stored literally as `admin' --` in the DB. Safe so far.
    3. **Trigger:** An Admin Panel allows changing passwords.
    `UPDATE Users SET Pass = '123' WHERE Name = '$stored_name'`
    4. **Explosion:** When the Admin Panel runs this query using the values *from the database*, the injection fires.
    `UPDATE Users SET Pass = '123' WHERE Name = 'admin' --'`

---

### 7. Blind SQLi (SQL Server)

**Q: Using `WAITFOR DELAY` to infer data.**

- **Scenario:** The app shows generic error pages. No data leakage.
- **The Attack:**
Ask questions: "Is the first letter of the password 'A'?"
    - Payload: `IF (SELECT SUBSTRING(Password,1,1) FROM Users WHERE User='Admin') = 'A' WAITFOR DELAY '0:0:5'`
- **Result:**
    - If the page loads instantly -> False.
    - If the page takes 5 seconds -> True (Letter is 'A').

---

---

## Phase 3: The Shield (The .NET Defense)

*Goal: Production-Ready code patterns for C# Developers.*

### 8. [ADO.NET](http://ado.net/) Parameterization

**Q: The only correct way to use `SqlCommand`.**

- **The Solution:**
Use `SqlParameter`. The data is sent in a separate packet from the query instructions. The SQL Engine treats it strictly as a value, never as code.
- **Secure Code (C#):**
    
    ```csharp
    public void GetUserSafe(string username) {
        using var conn = new SqlConnection(_connString);
        string sql = "SELECT * FROM Users WHERE Name = @Name"; // Use @Placeholder
    
        using var cmd = new SqlCommand(sql, conn);
        // Explicitly define Type and Value
        cmd.Parameters.Add("@Name", SqlDbType.NVarChar, 50).Value = username;
    
        conn.Open();
        var reader = cmd.ExecuteReader();
    }
    
    ```
    

---

### 9. EF Core 8.0 Safety

**Q: `FromSqlRaw` vs `FromSqlInterpolated`.**

- **The Danger Zone (`FromSqlRaw`):**
    
    ```csharp
    // VULNERABLE: Acts just like string concatenation
    var users = ctx.Users.FromSqlRaw("SELECT * FROM Users WHERE Name = '" + name + "'");
    
    ```
    
- **The Safe Zone (`FromSqlInterpolated`):**
EF Core automatically creates `SqlParameter` objects for the variables in the interpolated string.
    
    ```csharp
    // SECURE: 'name' is converted to @p0 automatically
    var users = ctx.Users.FromSqlInterpolated($"SELECT * FROM Users WHERE Name = {name}");
    
    ```
    
- **Best Practice:**
Stick to **LINQ** whenever possible (`ctx.Users.Where(u => u.Name == name)`). It is safe by default.

---

### 10. Dapper (The Micro-ORM Popular Choice)

**Q: How to use Dapper safely?**

- **Vulnerable Code:**
    
    ```csharp
    // BAD: String concatenation
    var user = connection.Query<User>("SELECT * FROM Users WHERE Name = '" + input + "'");
    
    ```
    
- **Secure Code (Anonymous Object):**
Dapper handles parameterization automatically if you pass an object as the second argument.
    
    ```csharp
    // SAFE: Dapper creates @Name parameter under the hood
    var user = connection.Query<User>("SELECT * FROM Users WHERE Name = @Name", new { Name = input });
    
    ```
    

---

**Q: How to sort dynamically or Pick Tables without SQLi?**

- **The Problem:** You cannot parameterize Column Names (`ORDER BY @col`) or Table Names (`FROM @table`).
- **The Solution:** Use **Allowlisting** (Validation) combined with `QUOTENAME` (SQL Server safe quoting).
- **Secure T-SQL (Stored Procedure):**
    
    ```sql
    CREATE PROCEDURE sp_SortUsers (@col NVARCHAR(50))
    AS
    BEGIN
        -- 1. Infrastructure: Define valid columns
        DECLARE @safeCol NVARCHAR(128); -- 128 is max identifier length in SQL Server
    
        -- 2. Allowlisting (CRITICAL STEP)
        -- We ONLY allow specific hardcoded strings. Everything else throws error.
        IF @col = 'Name' SET @safeCol = 'Name';
        ELSE IF @col = 'Age' SET @safeCol = 'Age';
        ELSE THROW 50000, 'Invalid Column Name Provided', 1;
    
        -- 3. Execution: safely inject the validated string using QUOTENAME
        -- QUOTENAME adds [ ] brackets (e.g., [Name]), preventing breakout
        DECLARE @sql NVARCHAR(MAX) = 'SELECT * FROM Users ORDER BY ' + QUOTENAME(@safeCol);
    
        -- 4. Execute with sp_executesql
        EXEC sp_executesql @sql;
    END
    
    ```
    

---

### 11. Least Privilege

**Q: Configuring the SQL User limits.**

- **The Concept:**
Your Web App should connect as a user `WebAppUser`, NOT `sa` (System Admin).
- **Configuration:**
    1. **Deny DROP:** `DENY DROP TABLE TO WebAppUser;`
    2. **Deny ALTER:** `DENY ALTER TO WebAppUser;`
    3. **Grant EXEC:** `GRANT EXECUTE ON SCHEMA::dbo TO WebAppUser;` (If using Procs).
- **Result:** Even if injection succeeds, the attacker cannot delete tables or drop the database.

---

## Graduation: You are now a .NET Security Architect.

**Final Checklist for your next PR:**

1. [**ADO.NET](http://ado.net/):** Are you using `Parameters.Add`? (Never string concat).
2. **EF Core:** Are you using `FromSqlInterpolated` instead of `Raw`?
3. **Dapper:** Are you passing the `new { Var = val }` object?
4. **Stored Procs:** Are you using **Allow lists** for Table/Column names?
5. **SQL Server:** Is the App User stripped of `db_owner` rights?