# into

You are absolutely right to catch that! This is one of the most confusing parts of LINQ syntax because the keyword `into` behaves completely differently depending on **where** it is placed.

There are exactly **two different rules** for `into`.

### Rule 1: The "Reset Button" (Query Continuation)

*Applies to:* `select ... into`, `group ... into`

When `into` is used after a `select` or a `group` clause, it acts as a **Scope Killer**. It takes the result of the operation, puts it in a new variable, and **wipes everything before it**.

- **Logic:** "I am done with the previous query entirely. Take the result and start a brand new query block with it."

```csharp
var query = from e in employees
            group e by e.DeptId
            into g              // <--- HERE
            // RESET HAPPENS
            // 'e' is dead.
            // Only 'g' exists now.
            select g;

```

---

### Rule 2: The "Bucket Collector" (Group Join)

*Applies to:* `join ... into`

When `into` is part of a `join` clause, it acts as a **Scope Adder**.

- **Logic:** "Keep the Outer variable (Left side). But for the Inner variable (Right side), don't give me them one by one. Instead, collect all matches into a list (Bucket)."
- The **Left Side (Outer)** variable remains available.
- The **Right Side (Inner)** variable disappears into the bucket.

```csharp
var query = from d in departments    // <--- 'd' is the OUTER (Left) variable
            join e in employees      // <--- 'e' is the INNER (Right) variable
            on d.Id equals e.DeptId
            into empGroup            // <--- HERE: Group Join logic applies

            // STATUS REPORT:
            // 'd' : ALIVE (It's the parent, we still need it!)
            // 'e' : DEAD (It has been packed away)
            // 'empGroup' : NEW (The bucket containing the e's)

            select new { d.Name, empGroup }; // We can access 'd'!

```

### Why the difference?

**Logic for Rule 1 (Continuation):**
If you `group e`, you no longer have a flat list of `e` objects. You have a list of keys and collections. Since the structure of the data fundamentally changed, LINQ forces you to stop using the old variables (`e`) to prevent errors.

**Logic for Rule 2 (Group Join):**
The purpose of a Group Join is to create a hierarchy: **Parent -> Children**.
If the Parent variable (`d`) disappeared, you would be left with just a list of lists of employees, with no idea which department they belong to! Therefore, LINQ *must* keep the Left Side (`d`) in scope for the query to be useful.

### Summary Table

| Context | Code Pattern | What happens to previous vars? | Why? |
| --- | --- | --- | --- |
| **Query Continuation** | `select x into y` | **All Deleted** | The query structure reset. You are piping data to a new step. |
| **Grouping** | `group x by k into g` | **All Deleted** | You transformed items into groups. Individual items are now hidden inside `g`. |
| **Group Join** | `join y ... into yList` | **Left Side Kept** | We need the "Parent" object to label the group of "Children". |