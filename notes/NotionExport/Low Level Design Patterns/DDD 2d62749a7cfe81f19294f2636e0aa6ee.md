# DDD

Here is your **Architect's Master Blueprint**. This summarizes everything we have discussed, structured to take you from "I know C#" to "I design DDD systems."

### **1. The Philosophy (Strategic Design)**

- **The Goal:** Align code with reality. The code should read like the business rules.
    - **Ubiquitous Language:** Developers and Business Experts must use the same words.
        - **Bad:** `UpdateStatus(id, 5)`
        - **Good:** `ConfirmOrder()`
    - **Bounded Context (The Logical Boundary):**
        - Do not try to build one huge User class for the whole system. Split the application based on **meaning**.
            - **Context A (Sales):** Product has Price, Image, Name.
            - **Context B (Inventory):** Product has Weight, ShelfLocation, Quantity.
            - **Rule:** If the same "noun" means something different in another department, create a new Context (Project/Namespace).

---

### **2. The Building Blocks (Tactical Design)**

- These live in the **Domain Layer**. They depend on **nothing**.
    - **Value Object**
        - *Definition:* Immutable measurements. No ID.
        - *Decision Rule (Equality by Value):* If I swap two objects with the same data, does it matter? No? It's a Value Object (Money, Address).
    - **Entity**
        - *Definition:* Mutable object with an ID.
        - *Decision Rule (Identity):* Does the object remain the "same" even if its name or data changes? Yes? It's an Entity (User).
    - **Aggregate Root**
        - *Definition:* The "Manager" Entity. Controls access to children.
        - *Decision Rule (Consistency):* Can I delete/modify a child without checking a rule on the parent? No? Then the parent is the Aggregate Root.

---

### **3. The Architecture (The Layers)**

- Imagine an Onion. **Dependencies point INWARDS only.**
    - **A. Domain Layer (Center)**
        - **What:** Business Logic, Entities, Enums, Exceptions, Repository Interfaces.
        - **Rule:** No dependencies (Pure C#).
        - **Note:** No database attributes ([Key]), no JSON tags, no HttpContext.
    - **B. Application Layer (Surrounding Domain)**
        - **What:** Workflow orchestrators (Services), DTOs, DTO Mapping logic.
        - **Rule:** No business rules here! Just coordination ("Load A, Do Logic on A, Save A, Send Email").
        - **Dependencies:** Domain, Infrastructure (Interfaces).
    - **C. Infrastructure Layer (Outer Ring)**
        - **What:** Technical implementation. SQL code, EF Core, SMTP implementations, File System.
        - **Rule:** Implements interfaces defined in Domain/Application.
        - **Dependencies:** Domain, Application, External Libraries.
    - **D. Presentation Layer (Surface)**
        - **What:** Controllers (API), UI.
        - **Rule:** Calls Application Services.
        - **Dependencies:** Application.

---

### **4. Dependencies in Domain Models**

- **The Question:** Can I inject a Service or Repository into an Entity?
    - **The Answer: No.**
        - Entities should be lightweight and self-contained. They hold state and logic calculated on that state.
            - **Bad:** `order.CalculateTotal()` connects to Database to get prices.
            - **Good:** `order.CalculateTotal(priceList)`. Pass the data into the method.

---

### **5. The "How-To" Operations**

- **A. Loading Data (Reconstitution) vs. Creating Data**
    - You need to distinguish between creating a *brand new* object and loading an *existing* one from the DB.
        - **Constructor:** For **New** objects. Enforce Rules (e.g., "Must have a name").
        - **Factory / Static Load:** For **Existing** objects coming from the DB. Bypasses "New Creation" checks because the data is already valid and saved.

```csharp
public class BankAccount
{
    public Guid Id { get; private set; }
    public decimal Balance { get; private set; }

    // SCENARIO 1: Creating a NEW account (Rules Apply)
    public BankAccount(Guid id)
    {
        Id = id;
        Balance = 0; // Default state
    }

    // SCENARIO 2: Loading from DB (Reconstitution)
    // Called by Repository/Factory. We just want to map data.
    public static BankAccount Load(Guid id, decimal balance)
    {
        return new BankAccount
        {
            Id = id,
            Balance = balance
        };
    }

    private BankAccount() { } // Empty constructor for ORMs like EF Core
}

```

- **B. DTOs and Conversion**
    - **Rule:** Never return the Aggregate Root to the UI. It exposes private rules and invites breaking them.
    - **Where to convert:** The **Application Service** or **Controller** converts Entity -> DTO.
- **C. The Repository Flow**
    - **1. Domain:** Define interface `IRepository { void Save(Account a); };`
    - **2. Infrastructure:** Implement class `SqlRepository : IRepository`.
    - **3. Mapper:** Inside SqlRepository, map the Domain Object to a Database Entity (a generic class that matches the SQL Table), then save using EF Core/Dapper.

---

### **6. The "Where Does Code Go?" Decision Matrix**

- When you have a new requirement, ask:
    - **1. Is this a core rule of the business (e.g., Math, Invariants, "Cannot withdraw if frozen")?**
        - üü† **Domain Layer** (Inside Entity or Value Object).
    - **2. Is this flow control (e.g., "Get Input, Check DB, Call Domain, Save")?**
        - ‚ö™ **Application Layer** (Service).
    - **3. Is this formatting data for a Screen/API (e.g., JSON, concealing IDs)?**
        - üü° **Application Layer** (DTO Mapping).
    - **4. Is this touching a Disk, Network, or Database (e.g., SQL, SMTP, Serialize)?**
        - üü§ **Infrastructure Layer**.

---

### **Final Expert Gist (The "Golden Rules")**

1. **Anemic Models are Enemies.** If your class is just public `{get; set;}`, you are not doing DDD. You are doing "Database Mapping."
2. **Private Setters.** Protect your data. Use methods (`.Deposit()`) to change state.
3. **Design for the Domain, not the Database.** Don't let SQL Table structures dictate how your C# Objects look.
4. **Aggregates are Transaction Boundaries.** When you save an Aggregate, you save the whole thing (Root + Children) to ensure consistency.

---

Here is the complete C# reference implementation. I have grouped the code into **Namespaces** to simulate the physical **Layers** of your project.

Read the comments carefully‚Äîthey explain the **"Why"** and the **"What NOT to do"**.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

// =======================================================================
// LAYER 1: DOMAIN
// The Core. Zero Dependencies on Database, UI, or External Libs.
// =======================================================================
namespace Bank.Domain
{
    // [PATTERN: VALUE OBJECT]
    // 1. Immutable. 2. No Identity. 3. Holds logic (Math).
    public record Money(decimal Amount, string Currency)
    {
        public static Money Zero(string currency) => new(0, currency);

        // Domain Logic inside Value Object (Self-contained)
        public static Money operator +(Money a, Money b)
        {
            if (a.Currency != b.Currency) throw new InvalidOperationException("Currency mismatch");
            return new Money(a.Amount + b.Amount, a.Currency);
        }
    }

    // [PATTERN: AGGREGATE ROOT - USER]
    // Represents Identity Context.
    public class User
    {
        public Guid Id { get; }
        public string Name { get; private set; }

        public User(string name)
        {
            Id = Guid.NewGuid();
            Name = name;
        }

        // ‚ùå WHAT NOT TO DO:
        // public List<BankAccount> Accounts { get; set; }
        // Why? Because loading a User shouldn't load their entire financial history.
        // These are separate Aggregates linked by ID.
    }

    // [PATTERN: AGGREGATE ROOT - BANK ACCOUNT]
    // Represents Financial Context.
    public class BankAccount
    {
        // 1. Identity
        public Guid Id { get; private set; }

        // 2. Reference to another Aggregate (User) by ID Only
        public Guid OwnerUserId { get; private set; }

        // 3. State protected by "private set"
        public Money Balance { get; private set; }
        public bool IsFrozen { get; private set; }

        // ‚ùå WHAT NOT TO DO: Dependency Injection here.
        // public BankAccount(IEmailService emailService) { ... }
        // Entities should NOT depend on Services. Pass needed data into methods instead.

        // [SCENARIO A: CREATION]
        // Used when a Customer actually opens a new account. Enforces Rules.
        public BankAccount(Guid ownerId, string currency)
        {
            if (ownerId == Guid.Empty) throw new ArgumentException("Owner required");

            Id = Guid.NewGuid();
            OwnerUserId = ownerId;
            Balance = Money.Zero(currency);
            IsFrozen = false;
        }

        // [SCENARIO B: RECONSTITUTION (Static Load)]
        // Used by Repository to load EXISTING data from DB.
        // Bypasses "New Account" logic. Trust the DB data.
        public static BankAccount LoadFromHistory(Guid id, Guid ownerId, decimal amount, string currency, bool isFrozen)
        {
            return new BankAccount
            {
                Id = id,
                OwnerUserId = ownerId,
                Balance = new Money(amount, currency),
                IsFrozen = isFrozen
            };
        }

        // Private constructor for the Static Load method to use
        private BankAccount() { }

        // [BEHAVIOR: MUTATING STATE]
        public void Deposit(Money amount)
        {
            // Business Rule: Invariant check
            if (IsFrozen) throw new InvalidOperationException("Account is frozen");

            Balance += amount;
        }

        public void Freeze()
        {
            IsFrozen = true;
        }
    }

    // [PATTERN: REPOSITORY INTERFACE]
    // Defines contract.
    public interface IBankAccountRepository
    {
        BankAccount GetById(Guid id);
        void Save(BankAccount account);
    }
}

// =======================================================================
// LAYER 2: INFRASTRUCTURE
// The Plumbing. Knows about SQL, EF Core, etc.
// =======================================================================
namespace Bank.Infrastructure
{
    using Bank.Domain;

    // [DATABASE MODEL]
    // This looks like your SQL Table. Anemic. Public Setters.
    // ‚ùå DO NOT use this in your Business Logic.
    public class BankAccountSqlEntity
    {
        public Guid Id { get; set; }
        public Guid OwnerUserId { get; set; }
        public decimal BalanceAmount { get; set; } // Flattened Value Object
        public string BalanceCurrency { get; set; }
        public bool IsFrozen { get; set; }
    }

    // [PATTERN: REPOSITORY IMPLEMENTATION]
    public class SqlBankAccountRepository : IBankAccountRepository
    {
        // Specific DB Context would be injected here
        private static List<BankAccountSqlEntity> _fakeDb = new();

        public BankAccount GetById(Guid id)
        {
            // 1. Fetch from DB (SQL Entity)
            var dbRow = _fakeDb.FirstOrDefault(x => x.Id == id);
            if (dbRow == null) return null;

            // 2. MAP: SQL Entity -> Domain Entity
            // Uses the "Static Load" method we defined in Domain
            return BankAccount.LoadFromHistory(
                dbRow.Id,
                dbRow.OwnerUserId,
                dbRow.BalanceAmount,
                dbRow.BalanceCurrency,
                dbRow.IsFrozen
            );
        }

        public void Save(BankAccount domainAccount)
        {
            // 1. MAP: Domain Entity -> SQL Entity
            var dbRow = new BankAccountSqlEntity
            {
                Id = domainAccount.Id,
                OwnerUserId = domainAccount.OwnerUserId,
                BalanceAmount = domainAccount.Balance.Amount, // Extract value
                BalanceCurrency = domainAccount.Balance.Currency,
                IsFrozen = domainAccount.IsFrozen
            };

            // 2. Save to DB Logic...
            _fakeDb.RemoveAll(x => x.Id == dbRow.Id); // simplistic upsert
            _fakeDb.Add(dbRow);

            Console.WriteLine($"[DB] Saved Account {dbRow.Id} with Balance {dbRow.BalanceAmount}");
        }
    }
}

// =======================================================================
// LAYER 3: APPLICATION
// The Orchestrator. Coordinates Workflow.
// =======================================================================
namespace Bank.Application
{
    using Bank.Domain;

    // [PATTERN: DTO]
    // Dumb data container for the UI/API.
    public class AccountSummaryDto
    {
        public Guid AccountId { get; set; }
        public decimal TotalBalance { get; set; } // Primitives only
        public string Status { get; set; }
    }

    // [PATTERN: SERVICE]
    public class BankService
    {
        private readonly IBankAccountRepository _repo;

        public BankService(IBankAccountRepository repo)
        {
            _repo = repo;
        }

        // FLOW: The "Deposit" Use Case
        public AccountSummaryDto DepositMoney(Guid accountId, decimal amount)
        {
            // 1. Load Domain Aggregate
            var account = _repo.GetById(accountId);
            if (account == null) throw new Exception("Account not found");

            // 2. Perform Business Logic (In Domain)
            // Notice we don't do math here. We call the domain method.
            var money = new Money(amount, "USD");
            account.Deposit(money);

            // 3. Save State (Infrastructure)
            _repo.Save(account);

            // 4. Convert to DTO
            // ‚ùå WHAT NOT TO DO: return account; (Don't leak Domain to UI)
            return new AccountSummaryDto
            {
                AccountId = account.Id,
                TotalBalance = account.Balance.Amount,
                Status = account.IsFrozen ? "Frozen" : "Active"
            };
        }
    }
}

// =======================================================================
// MAIN PROGRAM (Simulating the Controller/UI)
// =======================================================================
public class Program
{
    public static void Main()
    {
        // 1. Setup Dependency Injection
        Bank.Domain.IBankAccountRepository repo = new Bank.Infrastructure.SqlBankAccountRepository();
        Bank.Application.BankService service = new Bank.Application.BankService(repo);

        // 2. Create some initial data (simulating a DB entry)
        var newAcc = new Bank.Domain.BankAccount(Guid.NewGuid(), "USD");
        repo.Save(newAcc);

        // 3. Execute Flow
        try
        {
            Console.WriteLine("\\nAttempting Deposit...");
            var result = service.DepositMoney(newAcc.Id, 500.00m);

            Console.WriteLine($"[Success] DTO Returned: ID={result.AccountId}, Balance={result.TotalBalance}");
        }
        catch(Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}

```

### **Key "Anti-Patterns" to Avoid (Summary of Comments)**

1. **Do Not Nest Aggregates:**
    - **Bad:** `User.Accounts.Add(account)`
    - **Good:** User and BankAccount are separate. They share an OwnerUserId.
2. **Do Not Put Logic in Services:**
    - **Bad:** `service.Balance = service.Balance + amount;`
    - **Good:** `account.Deposit(amount);`
3. **Do Not Leak Domain Models:**
    - **Bad:** `public BankAccount GetAccountAPI() { ... }`
    - **Good:** `public AccountDto GetAccountAPI() { ... }`
4. **Do Not Put SQL in Domain:**
    - **Bad:** `public class BankAccount { [Key] public int Id ... }`
    - **Good:** Mapping happens inside the Repository implementation in Infrastructure.

[Example](DDD/Example%202d62749a7cfe8133b4e7e4dea488c100.md)