# CTE

Here is the comprehensive **Beginner to Expert** guide to **Common Table Expressions (CTE)** in SQL Server.

---

# üìò Phase 1: The Basics (What & Why)

**Definition:** A CTE is a **temporary, named result set** that exists only for the duration of a single SQL statement (Select, Insert, Update, Delete). Think of it as a **"Disposable View"** or a way to organize complex "Spaghetti Code" into neat blocks.

### 1. Basic Syntax

It uses the keyword `WITH`.

- **The Golden Rule:** The statement **preceding** the CTE *must* end with a semicolon `;`. It is best practice to always start your CTE with `;WITH`.

```sql
-- ; indicates end of previous batch
;WITH Sales_CTE AS
(
    -- 1. Define the Logic
    SELECT ProductID, SUM(TotalDue) as TotalSales
    FROM SalesOrderHeader
    GROUP BY ProductID
)
-- 2. Use it immediately
SELECT *
FROM Sales_CTE
WHERE TotalSales > 1000;

```

### 2. Why use it?

- **Readability:** It replaces complex subqueries/derived tables.
- **Maintenance:** You define the logic once at the top, then reference it below.

---

# ‚öôÔ∏è Phase 2: Advanced Usage (Intermediate)

### 1. Defining Multiple CTEs

You can chain multiple logic blocks together in one go. You references them sequentially.

```sql
;WITH
  Products_CTE AS (
      SELECT Id, Name, Price FROM Products
  ),
  Sales_CTE AS (
      SELECT ProductId, Count(*) as Qty FROM Sales GROUP BY ProductId
  )
-- Join the two virtual blocks
SELECT P.Name, S.Qty
FROM Products_CTE P
JOIN Sales_CTE S ON P.Id = S.ProductId;

```

### 2. Inserting/Updating via CTE

You can actually update the underlying table *through* the CTE. This is powerful.

```sql
;WITH TargetRows AS (
    SELECT * FROM Employees WHERE Department = 'Interns'
)
DELETE FROM TargetRows; -- This actually deletes from the 'Employees' table!

```

---

# üîÅ Phase 3: Recursive CTEs (The Superpower)

This is the feature that separates CTEs from simple Views or Subqueries. A **Recursive CTE** can reference *itself*. This is used for **Hierarchical Data** (Org Charts, Folder Structures, Parts Lists).

### 1. The Anatomy of Recursion

1. **Anchor Member:** The starting point (e.g., The CEO).
2. **UNION ALL:** The glue.
3. **Recursive Member:** The query that references the CTE name (The Loop).

### 2. Example: Organization Chart

- Table `Employees` has `EmployeeID` and `ManagerID`.

```sql
;WITH OrgChart_CTE AS
(
    -- üè∞ 1. Anchor: Find the Boss (ManagerID is NULL)
    SELECT EmployeeID, Name, ManagerID, 0 AS Level
    FROM Employees
    WHERE ManagerID IS NULL

    UNION ALL

    -- üîÑ 2. Recursive Member: Find people reporting to the results above
    SELECT E.EmployeeID, E.Name, E.ManagerID, O.Level + 1
    FROM Employees E
    INNER JOIN OrgChart_CTE O ON E.ManagerID = O.EmployeeID
)
SELECT * FROM OrgChart_CTE
ORDER BY Level;

```

**How it works:**

1. Run Anchor -> Returns CEO.
2. Run Recursive (Pass 1) -> Joins Employees with CEO -> Returns VP.
3. Run Recursive (Pass 2) -> Joins Employees with VP -> Returns Managers.
4. Repeats until no rows are returned.

---

# üß† Phase 4: Expert Internals & Performance

### 1. No Materialization (Important!)

- **Myth:** "CTEs cache data in memory so they are faster."
- **Reality:** SQL Server usually **inlines** (unfolds) the CTE definition into the main query.
    - If you reference the CTE twice in the main query (`JOIN CTE c1 ... JOIN CTE c2`), SQL Server will likely execute the underlying logic **twice**.
    - *Comparison:* A **Temp Table** runs once and stores the result. A **CTE** is just a shorthand for the code.

### 2. The "De-Dupe" Pattern (Interview Standard)

The most common practical use of CTEs is removing duplicate rows while keeping one original.

```sql
;WITH Duplicates_CTE AS (
    SELECT
        Name,
        Email,
        -- Generate ID: 1 for first occurrence, 2, 3 for duplicates
        ROW_NUMBER() OVER (PARTITION BY Email ORDER BY CreatedDate DESC) as RowNum
    FROM Users
)
-- Delete only the clones (RowNum > 1)
DELETE FROM Duplicates_CTE
WHERE RowNum > 1;

```

### 3. Infinite Loops (`MAXRECURSION`)

If your Recursive CTE logic is bad (e.g., A reports to B, B reports to A), it will loop forever until it crashes.

- **Safety Net:** SQL Server defaults to 100 loops.
- **Override:** `OPTION (MAXRECURSION 32767)` or `0` (No Limit).

```sql
;WITH Numbers AS (
    SELECT 1 AS N
    UNION ALL
    SELECT N + 1 FROM Numbers
)
SELECT * FROM Numbers
OPTION (MAXRECURSION 500); -- Prevents crash after 100

```

---

# üõë Phase 5: Limitations (The Gotchas)

1. **Scope is Limited:** A CTE only lives for the **immediate next statement**. You cannot define a CTE, run a SELECT, and then run another SELECT on it 5 lines later.
    - *Solution:* Use a Temp Table (`#Table`) if you need reuse across multiple statements.
2. **No Indexing:** You cannot put an index on a CTE (because it doesn't physically exist). If performance is bad, dump the CTE results into a `#TempTable` and index that.
3. **Nesting Rules:** You cannot write `WITH A AS ( WITH B AS ... )`. You must write `WITH A AS (...), B AS (...)`.

---

# üèÜ Summary: When to use CTE?

| Use Case | Solution | Why? |
| --- | --- | --- |
| **Hierarchies** | ‚úÖ **Recursive CTE** | Best tool for Parent-Child relationships. |
| **Code Cleanup** | ‚úÖ **Standard CTE** | Makes large SQL blocks readable. |
| **Removing Duplicates** | ‚úÖ **CTE + ROW_NUMBER** | Allows deleting based on window logic. |
| **Heavy Re-use** | ‚ùå **Temp Table** | If data is needed 5 times, CTE recalculates 5 times. Temp table calcs once. |
| **Massive Data** | ‚ùå **Temp Table** | CTEs can't be indexed. Temp tables can. |