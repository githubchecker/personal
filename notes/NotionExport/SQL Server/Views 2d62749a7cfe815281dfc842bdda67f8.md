# Views

Here is the comprehensive **Beginner to Expert** guide to **Views** in SQL Server.

---

# üìò Phase 1: The Basics (What & Why)

**Definition:** A View is a **Virtual Table**. It is not data stored on a hard drive; it is a **saved SQL query**. When you `SELECT` from a view, SQL Server takes the view's definition, combines it with your query, and executes the underlying logic.

### 1. Basic Syntax

```sql
CREATE VIEW dbo.vw_ActiveUsers
AS
    -- The Logic
    SELECT Id, Username, Email, Department
    FROM Users
    WHERE IsActive = 1;

```

### 2. Why use them? (The Big 3)

1. **Security (Row/Column Level):** You can grant a user permission to select from `vw_ActiveUsers` without giving them access to the main `Users` table (hiding Salary, SSN, or PasswordHash columns).
2. **Abstraction/Simplicity:** Hide complex `JOIN`s. Instead of writing a 10-line Join every time, you just type `SELECT * FROM vw_AllCustomerData`.
3. **Consistency:** Ensure every developer uses the same logic for "Active User" (e.g., ensuring `IsDeleted = 0` AND `IsActive = 1`).

---

# ‚öôÔ∏è Phase 2: Options & Configurations (Intermediate)

Views have specific attributes that change their behavior significantly.

### 1. `WITH SCHEMABINDING` (Crucial)

By default, views are "loose." If you drop a table the view depends on, the view stays but crashes when run.

- **The Fix:** Schemabinding locks the underlying table. You **cannot** drop or alter columns in the underlying table while the view exists.

```sql
CREATE VIEW dbo.vw_SolidView
WITH SCHEMABINDING -- üîí Locks the schema
AS
    -- Must use two-part names (dbo.Table)
    SELECT u.Id, u.Name
    FROM dbo.Users u;

```

- *Performance Note:* This is required if you want to create an **Indexed View**.

### 2. `WITH ENCRYPTION`

- Obfuscates the code so users cannot Right-Click -> "Modify" to see the source SQL.
- *Warning:* Just like SPs, this is weak security.

### 3. `WITH CHECK OPTION` (Data Integrity)

This prevents "Disappearing Rows."

- **Scenario:** You have a view showing only 'IT' staff. You Insert a user via the View but set Dept = 'HR'.
- **Result:** The insert succeeds, but the row immediately disappears from the view.
- **Fix:** `WITH CHECK OPTION` blocks this insert.

```sql
CREATE VIEW dbo.vw_IT_Staff
AS
    SELECT Id, Name, Department FROM Users WHERE Department = 'IT'
WITH CHECK OPTION; -- üõ°Ô∏è Blocks inserts/updates if Dept != 'IT'

```

---

# üìà Phase 3: Indexed Views (Performance Superpower)

Standard views calculate data **every time** you run them. **Indexed Views** (Materialized Views) store the result physically on disk.

### How it works

1. You create a view with `SCHEMABINDING`.
2. You create a **Clustered Index** on the View.
3. **Result:** The calculation (JOINS, SUMS) is done **once** and saved. When you query the view, SQL reads the saved result instantly.

### The Catch (Trade-off)

- **Write Penalty:** Every time you update the underlying table (`Users`), SQL must also update the Indexed View. Use only for data that is read often but updated rarely (Warehousing).
- **Restrictions:**
    - No `COUNT(*)` (Must use `COUNT_BIG(*)`).
    - No `LEFT JOIN`, `UNION`, `DISTINCT`, or `MAX/MIN`.
    - Must use standard `INNER JOIN`.

---

# ‚öîÔ∏è Phase 4: Updating Data through Views

Can you `INSERT`, `UPDATE`, or `DELETE` using a view? **Yes, but with strict rules.**

### 1. The Simple Rule

If the view maps directly to **one** underlying table without modifying data, you can update it.

```sql
UPDATE vw_ActiveUsers SET Email = 'new@test.com' WHERE Id = 10;
-- ‚úÖ Works: Passes through to the Users table.

```

### 2. The Complex Rule (Joins)

If a view joins Table A and Table B:

- You can only update columns from **one** table in a single statement.
- You generally **cannot** `DELETE` from a multi-table view (because SQL doesn't know if you want to delete the row from Table A, Table B, or just the association).

### 3. INSTEAD OF Triggers (The Workaround)

If you need to make a complex View (e.g., joins, calculations) writable, you add an **INSTEAD OF TRIGGER**.

- The User updates the View.
- The Trigger catches the request and manually performs the necessary logic on Tables A and B.

---

# üìâ Phase 5: Performance Myths & Reality

### 1. "Views are faster"

**FALSE.** A standard view is just a saved query. `SELECT * FROM View` is exactly as fast (or slow) as pasting the inner query definition. It offers **zero** performance boost unless it is an *Indexed View*.

### 2. View Nesting (The "Vomit" Topology)

- **Scenario:** View A selects from Table. View B selects from View A. View C selects from View B.
- **Result:** The SQL Optimizer has to unpack layers of logic.
- **Risk:** Once you go deeper than 3 levels, the Optimizer can get confused, leading to terrible execution plans and inability to use indexes correctly.
- **Best Practice:** Never nest views deep. Always reference base tables if possible.

---

# üìù Summary Checklist

| Feature | Standard View | Indexed View |
| --- | --- | --- |
| **Storage** | Virtual (Logic only) | Physical (Saved on Disk) |
| **Performance** | Same as running query manually | Fast (Pre-calculated) |
| **Maintenance** | None | Slows down Insert/Update on base tables |
| **Requirements** | None | `SCHEMABINDING`, `COUNT_BIG`, No Outer Joins |
| **Best For** | Security, Abstraction, Reuse | Reporting, Aggregations (SUM/AVG) |

### Expert Tip

When tuning a slow query that uses a View, look at the Execution Plan. You won't see "View" in the plan; you will see the underlying Tables. To know *which* view is causing issues, checking the standard SQL text often isn't enough‚Äîyou have to unwrap the definition.

# Update using Views Detailed

Here is a deep dive into **Updating Tables via Views**.

To an Expert, an "Updatable View" is a **Pass-Through Mechanism**. When you run an `UPDATE` on a View, SQL Server tries to push that update down to the physical table. However, since a View can alter the appearance of data (Joins, Aggregates), there are strict **Constraints** on when this pass-through is allowed.

---

# üõë Constraint 1: The "Single Base Table" Rule (Joins)

This is the most critical constraint.

- **The Rule:** If a View joins multiple tables (Table A + Table B), you can only update columns belonging to **ONE** of those tables in a single `UPDATE` statement.
- **The Error:** If you try to update columns from both A and B simultaneously, SQL throws error 4405: *"View or function is not updatable because the modification affects multiple base tables."*

### ‚ùå The Failure Scenario

**Setup:** A View joining `Employees` and `Departments`.

```sql
CREATE VIEW vw_EmpDept AS
SELECT
    E.EmpID,
    E.Name,      -- From Employees Table
    D.DeptName   -- From Departments Table
FROM Employees E
JOIN Departments D ON E.DeptID = D.DeptID;

```

**The Attempt:**

```sql
-- Trying to move Employee 'John' to a new Department name 'Mega-IT'
-- This touches TWO physical tables at once.
UPDATE vw_EmpDept
SET Name = 'John Doe',         -- Employees Table
    DeptName = 'Mega-IT'       -- Departments Table
WHERE EmpID = 1;

-- üí• ERROR 4405: Modification affects multiple base tables.

```

### ‚úÖ The Fix (Split the Operation)

You must execute two separate statements.

```sql
-- 1. Update Employee
UPDATE vw_EmpDept SET Name = 'John Doe' WHERE EmpID = 1;

-- 2. Update Department
UPDATE vw_EmpDept SET DeptName = 'Mega-IT' WHERE EmpID = 1;

```

---

# üõë Constraint 2: The "Key Preservation" Rule (Deletes)

Updating is one thing, but **Deleting** via a Joined View is much stricter.

- **The Rule:** You **cannot** `DELETE` from a View that joins multiple tables. Period.
- **Why?** SQL Server doesn't know your intent.
    - If you delete a row from `vw_EmpDept`, do you want to delete the **Employee**?
    - Do you want to delete the **Department**?
    - Do you want to delete **Both**?
- **Constraint:** SQL disables DELETEs on multi-table views entirely to prevent accidental data loss.

---

# üõë Constraint 3: Modification of Computed Columns

You cannot update a column that doesn't physically exist (is derived).

### Scenario

```sql
CREATE VIEW vw_Sales AS
SELECT
    Price,
    Quantity,
    (Price * Quantity) AS Total -- Calculated
FROM Orders;

```

**The Attempt:**

```sql
-- "I want the total to be 100. SQL, you figure out the price/qty."
UPDATE vw_Sales SET Total = 100 WHERE OrderId = 1;

```

**Constraint:** SQL cannot reverse-engineer the math. It doesn't know if you want `10 * 10` or `50 * 2`.
**Result:** *Error: Column 'Total' cannot be modified because it is a computed column.*

---

# üõë Constraint 4: The "Non-Existent" Columns (INSERT)

If you insert data *into* a View, what happens to the columns inside the physical table that are **hiding** (not present in the View)?

- **The Constraint:** An `INSERT` into a View will **FAIL** unless:
    1. The hidden columns in the physical table allow `NULL`.
    2. **OR** the hidden columns have a `DEFAULT` constraint defined.
    3. **OR** the hidden columns are `IDENTITY` columns.

**Example:**

- **Table:** `Users (ID, Name, PasswordHash NOT NULL)`
- **View:** `SELECT ID, Name FROM Users` (PasswordHash is hidden).
- **Action:** `INSERT INTO View (Name) VALUES ('Bob')`
- **Result:** üí• **Error.** SQL tries to insert into `Users`, but it doesn't have a `PasswordHash`. The insert crashes.

---

# üõë Constraint 5: `WITH CHECK OPTION` (Self-imposed Constraint)

This forces the View to adhere to its own `WHERE` clause during updates.

**Scenario:** View only shows "Seattle" employees.

```sql
CREATE VIEW vw_SeattleOnly AS
SELECT * FROM Employees WHERE City = 'Seattle'
WITH CHECK OPTION; -- üîí Force compliance

```

**The Attempt:**

```sql
-- Try to use the Seattle View to move Bob to New York
UPDATE vw_SeattleOnly
SET City = 'New York'
WHERE ID = 100;

```

**Result:** üí• **Error.** "The attempted insert or update failed because the target view specifies WITH CHECK OPTION."
**Why:** If SQL allowed this, the row would vanish from `vw_SeattleOnly` immediately after the update.

---

# üîì The Solution: INSTEAD OF Triggers (The Master Key)

If you absolutely must update a Complex View (Joins, Calculated Cols, Deletes), you bypass all constraints using an **INSTEAD OF** Trigger.

You tell SQL: *"Ignore the standard error. Let me handle the update logic manually in code."*

### Example: Making a "Total" Column Updatable

We want to allow `UPDATE vw_Sales SET Total = 100`. We decide the logic is: "Keep Quantity static, adjust Price to match."

```sql
CREATE TRIGGER trg_UpdateSalesView
ON vw_Sales
INSTEAD OF UPDATE -- ‚ö° Run this INSTEAD of standard SQL error
AS
BEGIN
    SET NOCOUNT ON;

    -- Update the Base Table manually using logic
    UPDATE O
    SET Price = i.Total / O.Quantity -- Reverse Engineer logic
    FROM Orders O
    INNER JOIN inserted i ON O.ID = i.ID;
END

```

---

# üìù Summary Constraints Table

| Operation | View Type | Constraint / Result |
| --- | --- | --- |
| **UPDATE** | Simple (1 Table) | ‚úÖ Works. (Hidden cols must be nullable/default). |
| **UPDATE** | Joined (2 Tables) | ‚ö†Ô∏è **One Table Only.** Can only update cols from one base table per statement. |
| **UPDATE** | Computed Col | ‚ùå **Fail.** Math logic is one-way. |
| **UPDATE** | Aggregate (`GROUP BY`) | ‚ùå **Fail.** Cannot update a SUM/AVG. |
| **DELETE** | Joined (2 Tables) | ‚ùå **Fail.** SQL doesn't know which row to delete. |
| **INSERT** | Joined (2 Tables) | ‚ùå **Fail.** Cannot Insert into multiple base tables in one shot. |
| **ANY** | With `CHECK OPTION` | ‚ö†Ô∏è **Restricted.** Cannot change data so that it leaves the View's scope. |

### Expert Takeaway

- **Views are mostly for Reading.**
- Updating **Simple Views** is fine and useful for security (column hiding).
- Updating **Complex Views** is painful. If you find yourself writing complex `INSTEAD OF` triggers just to make a View updatable, you probably have a bad architecture. It is usually better to use a **Stored Procedure** to handle the complex update logic.