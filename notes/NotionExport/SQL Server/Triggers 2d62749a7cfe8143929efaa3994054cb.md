# Triggers

Here is the comprehensive **Beginner to Expert** guide to **Triggers** in SQL Server.

---

# üìò Phase 1: The Foundation (What & Why)

**Definition:** A Trigger is a special type of Stored Procedure that is **automatically fired** by SQL Server when a specific event occurs (INSERT, UPDATE, DELETE, or Table creation).

- **Analogy:** It is exactly like an Event Listener in C# (`btn_Click`) or JavaScript (`onClick`). You don't call it; the system calls it.
- **The Scope:** A Trigger effectively runs **within the same transaction** as the SQL statement that fired it.
    - *Crucial Consequence:* If the Trigger fails (errors out), the original `INSERT/UPDATE` statement **rolls back**.

### Basic Syntax (`AFTER TRIGGER`)

```sql
CREATE TRIGGER trg_User_Audit
ON Users
AFTER INSERT, DELETE -- Fire on both events
AS
BEGIN
    SET NOCOUNT ON; -- ‚ö†Ô∏è Critical to stop EF Core crashes

    INSERT INTO AuditLog (Msg, Date)
    VALUES ('Changes happened in Users table', GETDATE());
END

```

---

# ‚öîÔ∏è Phase 2: The Two Types (After vs. Instead Of)

Understanding the difference controls whether you are "Auditing" data or "Hijacking" data.

### 1. AFTER Trigger (The Standard)

- **Execution:** Runs **after** the data is inserted/updated in the table and **after** Constraint checks (PK, FK, Check).
- **Usage:** Auditing, cascading updates to other tables, calculating summaries.
- **Restriction:** You cannot catch a Constraint Violation here. If the PK check fails, the Trigger never runs.

### 2. INSTEAD OF Trigger (The Hijacker)

- **Execution:** Runs **instead** of the standard SQL operation. SQL Server completely ignores the original `INSERT` statement and runs your code instead.
- **Usage:**
    - Updating complicated **Views** (Making a read-only View writable).
    - Blocking deletes entirely (Soft Delete logic).
    - Fixing data format *before* it hits constraints.

**Example: Soft Delete (Instead of Delete)**

```sql
CREATE TRIGGER trg_PreventPhysicalDelete
ON Users
INSTEAD OF DELETE
AS
BEGIN
    SET NOCOUNT ON;

    -- Instead of deleting the row, just update the 'IsActive' flag
    UPDATE U
    SET IsActive = 0
    FROM Users U
    JOIN deleted d ON U.Id = d.Id; -- Join 'deleted' magic table
END

```

---

# üé© Phase 3: Working with Data (Magic Tables)

As covered in the previous "Magic Tables" section, Triggers are blind without `inserted` and `deleted`.

### The Set-Based Trap (Common Rookie Mistake)

Beginners write triggers assuming they fire **Once Per Row**.

- **Fact:** Triggers fire **Once Per Batch**.
- **Scenario:** If you execute `UPDATE Users SET Age = 30` (affecting 10,000 rows), the Trigger runs **1 time**. The `inserted` table contains **10,000 rows**.

**‚ùå BAD Code (Scalar Variable Trap)**

```sql
-- This assumes only 1 row was updated. Fails on bulk updates.
SELECT @Id = Id FROM inserted;
INSERT INTO Log...

```

**‚úÖ GOOD Code (Set-Based)**

```sql
-- Handles 1 row or 1 Million rows equally well
INSERT INTO AuditLog (UserId, NewVal)
SELECT Id, Age
FROM inserted;

```

---

# üõ†Ô∏è Phase 4: DDL & Logon Triggers (Scope Levels)

Triggers aren't just for data tables (DML). They work for Server events too.

### 1. DDL Triggers (Schema Safety)

Fires on `CREATE TABLE`, `DROP TABLE`, `ALTER PROCEDURE`.

- **Use Case:** Prevent developers from Dropping tables in Production.

```sql
CREATE TRIGGER trg_Safety_NoDrops
ON DATABASE
FOR DROP_TABLE
AS
BEGIN
    PRINT 'You are not allowed to drop tables!';
    ROLLBACK; -- Undo the Drop
END

```

### 2. Logon Triggers

Fires when a user establishes a connection.

- **Use Case:** Security (Block users after 8:00 PM or specific IPs).
- **Danger:** If you mess this up (e.g., bug in code), **NO ONE** can log in to the server. You might lock yourself out!

---

# üß† Phase 5: Internals & Performance (Expert)

### 1. The Transaction Chain

The Trigger inherits the Transaction from the caller.

- Client starts `BEGIN TRAN`.
- Client runs `INSERT` -> Locks Table.
- Trigger starts.
- Trigger updates Table B -> Locks Table B.
- Trigger finishes.
- Client `COMMIT`.
- **Performance:** The locks on Table A and Table B are held for the **entire duration**. Long-running triggers kill system concurrency.

### 2. Recursion (The Loop)

- **Direct Recursion:** Table A triggers update Table A (Loops).
- **Indirect Recursion:** Table A triggers update Table B, which triggers update Table A.
- **Control:** Default limit is 32 levels deep. Configurable via `sp_configure 'nested triggers'`.
- **Advice:** Avoid recursive triggers unless absolutely necessary.

### 3. Order of Execution

If you have multiple triggers on one table (e.g., 3 `AFTER INSERT` triggers), which runs first?

- By default: Random order.
- **Force Order:** Use `sp_settriggerorder @triggername, @order='First'`.

---

# üõë Phase 6: Best Practices & Pitfalls

### 1. `SET NOCOUNT ON`

**ALWAYS** put this at the top.

- **Why?** If your trigger updates 5 tables, it sends 5 "Rows Affected" messages back to C#. Entity Framework expects exactly one message for the original INSERT. Receiving 6 confuses EF and throws a `DbUpdateConcurrencyException`.

### 2. Check for 0 Rows

Don't run logic if nothing happened.

```sql
IF NOT EXISTS (SELECT 1 FROM inserted) AND NOT EXISTS (SELECT 1 FROM deleted)
    RETURN;

```

### 3. Keep Business Logic OUT

- **Opinion:** Expert Architects dislike Triggers for heavy business logic.
- **Why?** They are "Invisible". A developer updates a table, and suddenly an error pops up from a different table because of a trigger hidden in the background. It is a nightmare to debug.
- **Exception:** Use Triggers strictly for **Data Integrity** and **Auditing**. Put Business Rules in Stored Procedures.

### 4. Don't Return Results

Never write a `SELECT * FROM table` inside a trigger. It sends a result set to the application that wasn't expecting it, often crashing APIs.

---

# üìù Summary Comparison

| Feature | Stored Procedure | Trigger |
| --- | --- | --- |
| **Execution** | Manual (`EXEC`) | Automatic (Event-Driven) |
| **Visibility** | Visible code | Hidden (runs in background) |
| **Transactions** | Explicit control | Inherited / Nested Transaction |
| **Best For** | Business Logic, CRUD | Auditing, Complex Validation |
| **Input** | Parameters | `inserted` / `deleted` Tables |
| **Output** | Tables, Scalar | None (Should stay silent) |

[Skip Trigger](Triggers/Skip%20Trigger%202d62749a7cfe81929674effef507c33b.md)