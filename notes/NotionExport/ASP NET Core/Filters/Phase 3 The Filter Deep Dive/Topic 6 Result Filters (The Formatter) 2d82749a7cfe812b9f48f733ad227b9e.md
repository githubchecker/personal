# Topic 6: Result Filters (The Formatter)

The **Result Filter** is your last chance to influence the request before the response is sent to the client. Its single purpose is to interact with the `IActionResult` returned by your action method.

**Its Position:**

- Runs **only after** an action method has executed **successfully**.
- It "wraps" the execution of the `IActionResult` itself (the part that serializes JSON or renders a view).

It will **NOT** run if:

- An Authorization, Resource, or Action filter short-circuited the pipeline.
- An unhandled exception was thrown in the action method (the `IExceptionFilter` would run instead).

---

### **1. The Interfaces: `IResultFilter` and `IAsyncResultFilter`**

As with other filters, there are synchronous and asynchronous versions.

- `IResultFilter`
    - `OnResultExecuting(ResultExecutingContext context)`: Runs **before** the result is executed. You can change the result here.
    - `OnResultExecuted(ResultExecutedContext context)`: Runs **after** the result has been executed. It's too late to change the response body here, but you can add headers or log the final outcome.
- `IAsyncResultFilter` (Recommended)
    - `OnResultExecutionAsync(ResultExecutingContext context, ResultExecutionDelegate next)`

The `ResultExecutingContext` is key:

- `context.Result`: This is the `OkObjectResult`, `NotFoundResult`, etc., that your action returned.
- `context.Controller`: The instance of the controller.

---

### **2. Production Use Case 1: The "Envelope" Wrapper**

Many APIs adopt a standard response format for consistency. Instead of just returning a raw object, they wrap it in an "envelope" that includes metadata.

**The Goal:**
Transform a response like this:

```json
{ "productName": "Widget", "price": 99.99 }
```

...into a standardized envelope like this:

```json
{
  "isSuccess": true,
  "data": {
    "productName": "Widget",
    "price": 99.99
  },
  "error": null,
  "timestamp": "2023-10-27T10:00:00Z"
}

```

**The Filter Code:**
This is a perfect job for `OnResultExecuting` because we need to replace the original result with a new one.

```csharp
public class ApiResponseWrapperFilter : IResultFilter
{
    public void OnResultExecuting(ResultExecutingContext context)
    {
        // We only want to wrap successful results that contain data.
        if (context.Result is ObjectResult objectResult && (objectResult.StatusCode >= 200 && objectResult.StatusCode < 300))
        {
            // Create the new envelope structure.
            var envelope = new
            {
                IsSuccess = true,
                Data = objectResult.Value, // <-- The original object goes here
                Error = (string)null,
                Timestamp = DateTime.UtcNow
            };

            // Replace the original result with a new one containing the envelope.
            context.Result = new ObjectResult(envelope)
            {
                StatusCode = objectResult.StatusCode
            };
        }
        else if (context.Result is StatusCodeResult statusCodeResult && statusCodeResult.StatusCode >= 400)
        {
            // You could also wrap error responses in a similar envelope.
            var envelope = new { IsSuccess = false, Data = (object)null, Error = "An error occurred." };
            context.Result = new ObjectResult(envelope) { StatusCode = statusCodeResult.StatusCode };
        }
    }

    public void OnResultExecuted(ResultExecutedContext context)
    {
        // This runs after the new result has been written to the response body.
        // It's too late to change the body, but perfect for adding headers.
    }
}

```

**Registration:** This is typically a **global** filter, registered in `Program.cs`, to ensure every successful API response has a consistent format.

---

### **3. Production Use Case 2: Adding Global Response Headers**

**The Goal:**
Every single response from your API must include a `X-Correlation-Id` header to help with distributed tracing and logging.

**The Filter Code:**`OnResultExecuted` is the best place for this because it runs after all other logic is complete, ensuring the header is added even to error responses that were generated by other filters.

```csharp
public class AddCorrelationIdHeaderFilter : IResultFilter
{
    public void OnResultExecuting(ResultExecutingContext context)
    {
        // We don't need to do anything before the result executes.
    }

    public void OnResultExecuted(ResultExecutedContext context)
    {
        // It is safe to add headers here because the response stream is still open,
        // even though the body has been written.

        // Get the TraceIdentifier, which is unique for every request.
        var correlationId = context.HttpContext.TraceIdentifier;

        if (!context.HttpContext.Response.Headers.ContainsKey("X-Correlation-Id"))
        {
            context.HttpContext.Response.Headers.Add("X-Correlation-Id", correlationId);
        }
    }
}

```

**Middleware vs. Result Filter for Headers:**
You *could* also do this in middleware.

- **Use Middleware:** For simple headers that don't depend on the MVC result. Middleware is slightly more performant as it has less overhead.
- **Use a Result Filter:** When the header's value might depend on the `IActionResult` itself. For example, adding an `ETag` header based on the hash of the response object. A filter is a better choice for this because it has access to `context.Result`.

---

### **4. Preventing Caching (`[ResponseCache]`)**

Interestingly, one of the most common result filters is one you've likely seen before: `[ResponseCache]`.

When you write `[ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]`, you are applying a result filter that adds caching-related headers (like `Cache-Control` and `Pragma`) to the final HTTP response. This demonstrates how a filter can be used to control client-side (browser) behavior.

---

### **Summary of Result Filters**

| Feature | Description |
| --- | --- |
| **Position** | Wraps the execution of the `IActionResult`. |
| **Key Context** | `context.Result` (the object returned by the action). |
| **Best Use Cases** | **Modifying the response body** (wrapping in an envelope), adding **context-aware response headers**, controlling client caching behavior. |
| **When it runs** | Only on successful action execution (no exceptions or short-circuits from previous filters). |

You have now completed the deep dive into all five filter types and their expert-level use cases in [ASP.NET](http://asp.net/) Core