# Example

You are asking for the ultimate reference document. This is an excellent request because it forces the YAML to be self-documenting.

Here is the revised "Giant Reference YAML". I have expanded the comments significantly to explain the "what," "why," and "when" for nearly every line and keyword. I have also added:

1. A detailed explanation of `strategy` types (`runOnce`, `canary`, `rolling`).
2. An explicit task for creating an `imagePullSecret` in the AKS deployment stage.
3. A **third deployment stage** that shows how to deploy the **same build artifact** to a traditional **Azure Web App**, demonstrating a hybrid deployment scenario.
4. A deeper explanation of how the `condition` on the deployment stages works to skip PR builds.

---

### **The Ultimate Reference `azure-pipelines.yml`**

```yaml
# =================================================================================
#                 ENTERPRISE MASTER REFERENCE AZURE PIPELINE (v2)
# =================================================================================
# This is a heavily commented blueprint for a complex CI/CD workflow. It covers:
# - CI/CD triggers with conditions.
# - Reusable templates from another repository.
# - Multi-OS builds using a matrix strategy.
# - Caching, code analysis, and containerization.
# - Parallel deployments to AKS (Dev) and a traditional Web App (QA).
# - Secure handling of secrets and container registry access.

# ---------------------------------------------------------------------------------
# 1. TRIGGER CONFIGURATION: When does this pipeline run?
# ---------------------------------------------------------------------------------
# `trigger` defines the Continuous Integration (CI) trigger. It automatically starts
# the pipeline when code is pushed to specific branches.
trigger:
  branches:
    include:
    - main         # Primary branch for production-ready code.
    - 'release/*'    # Wildcard for any release branches (e.g., 'release/v2.1').
  paths:
    include:
    - 'src/'         # Only trigger a build if files under the 'src' directory change.
    exclude:
    - 'src/docs/'    # Ignore changes to documentation.

# `pr` defines the Pull Request (PR) validation trigger. It runs on PRs targeting
# specific branches to ensure code quality BEFORE it gets merged.
pr:
  branches:
    include:
    - main

# ---------------------------------------------------------------------------------
# 2. RESOURCES: What external resources does this pipeline need?
# ---------------------------------------------------------------------------------
resources:
  repositories:
    # Allows checking out code from another repository. Essential for using shared
    # YAML templates and maintaining a DRY (Don't Repeat Yourself) pipeline structure.
    - repository: PipelineTemplates  # A friendly alias used with the '@' symbol.
      type: git
      name: 'MyProject/DevOpsTemplates' # The name of the templates repository in Azure DevOps.
      ref: 'refs/heads/main'          # The branch to use from the templates repo.

# ---------------------------------------------------------------------------------
# 3. VARIABLES: Reusable values for this pipeline.
# ---------------------------------------------------------------------------------
variables:
  # `- group` links to a Variable Group from Pipelines -> Library. Use this for
  # storing shared values and secrets (like service connection names, ACR details).
  - group: 'Global-Service-Variables'

  # `name/value` pairs define variables local to this pipeline.
  - name: buildConfiguration
    value: 'Release'
  - name: projectPath
    value: 'src/MyApi/MyApi.csproj'
  - name: dockerfilePath
    value: 'src/MyApi/Dockerfile'
  - name: imageRepository
    value: 'my-dotnet-api'
  - name: imageTag
    value: '$(Build.BuildId)' # Uses a unique, built-in variable for the tag.

# =================================================================================
#                                  STAGES
# =================================================================================
stages:

# ---------------------------------------------------------------------------------
# STAGE 1: Build & Static Analysis on Multiple Operating Systems
# ---------------------------------------------------------------------------------
- stage: Build
  displayName: 'Build, Test & Package'
  jobs:
  # This job uses a 'matrix' strategy to amplify its execution. The entire job
  # (pool, steps) will be run for each key in the matrix, in parallel.
  # WHEN TO USE: Use a matrix when you need to validate that your code builds and
  # tests correctly across different environments (OS, library versions, configs).
  - job: BuildAndTest
    strategy:
      matrix:
        # Each key here defines one "leg" of the parallel run.
        Linux:
          vmImageName: 'ubuntu-latest' # This OS is standard for container builds.
        Windows:
          vmImageName: 'windows-latest' # To validate against the Windows platform.
    pool:
      # The vmImage is dynamically set by the 'vmImageName' variable from the matrix.
      vmImage: $(vmImageName)

    steps:
      - task: Cache@2
        displayName: 'Cache NuGet Packages'
        inputs:
          key: 'nuget | "$(Agent.OS)" | **/packages.lock.json'
          path: $(NUGET_PACKAGES)
          cacheHitVar: 'CACHE_RESTORED'

      # Example of using a shared template from the 'PipelineTemplates' repo.
      # This keeps the main pipeline clean and centralizes build logic.
      # - template: dotnet-build-test.yml@PipelineTemplates
      #   parameters:
      #     buildConfiguration: $(buildConfiguration)

      # --- Steps are inline here for reference ---
      - task: DotNetCoreCLI@2
        displayName: 'Restore'
        condition: ne(variables.CACHE_RESTORED, 'true')
        inputs: { command: 'restore', projects: '$(projectPath)' }
      - task: DotNetCoreCLI@2
        displayName: 'Build'
        inputs: { command: 'build', projects: '$(projectPath)', arguments: '--configuration $(buildConfiguration) --no-restore' }
      - task: DotNetCoreCLI@2
        displayName: 'Test'
        inputs: { command: 'test', projects: '**/*Tests.csproj', arguments: '--configuration $(buildConfiguration) --no-build' }

      # The Docker image only needs to be built and pushed once. We use a 'condition'
      # to ensure these steps run ONLY on the Linux leg of the matrix.
      - task: Docker@2
        displayName: 'Build and Push Docker Image to ACR'
        condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))
        inputs:
          containerRegistry: 'MyACRServiceConnection' # A Service Connection of type "Docker Registry".
          repository: $(imageRepository)
          command: 'buildAndPush'
          dockerfile: $(dockerfilePath)
          tags: $(imageTag)

      - task: PublishPipelineArtifact@1
        displayName: 'Publish K8s Manifests & Web App Package'
        condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))
        inputs:
          # We publish multiple artifacts for our different deployment targets.
          # NOTE: The DotNetCoreCLI@2 'publish' task would run before this to create the zip.
          pathToPublish: 'kubernetes' # The path to the kubernetes manifests folder
          artifactName: 'k8s-manifests'
      # Example of publishing a second artifact for the Web App deployment.
      # - task: PublishPipelineArtifact@1
      #   ...
      #   pathToPublish: '$(Build.ArtifactStagingDirectory)/app.zip'
      #   artifactName: 'web-app-package'

# ---------------------------------------------------------------------------------
# STAGE 2: Deploy to AKS (Development)
# ---------------------------------------------------------------------------------
- stage: DeployAKS
  displayName: 'Deploy to AKS (Dev)'
  dependsOn: Build # Ensures this stage only runs after 'Build' is successful.

  # EXPLANATION OF 'condition': This is the logic that skips deployment on PRs.
  # - succeeded(): Only run if previous stages succeeded.
  # - ne(variables['Build.Reason'], 'PullRequest'): Checks the built-in variable that
  #   explains WHY the build was started. If it was for a 'PullRequest', this condition
  #   is false, and the stage is skipped. Other values include 'Manual', 'IndividualCI', etc.
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))

  jobs:
  # A 'deployment' job is special. It tracks deployment history to an 'environment'.
  - deployment: DeployToAKS_Dev
    environment: 'AKS-Dev.dev' # Targets the 'dev' namespace in the 'AKS-Dev' environment.
    pool:
      vmImage: 'ubuntu-latest'

    # STRATEGY: Defines how the deployment happens.
    # - runOnce: The simplest strategy. All steps run sequentially on one agent.
    # Other strategies include 'canary' and 'rolling' for gradual rollouts.
    # WHEN TO USE: Use 'runOnce' for standard deployments. Use 'canary' to test
    # a new version on a small subset of users before a full rollout.
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: none # Source code is not needed for deployment.

            # This is one way to create the imagePullSecret. It uses a Docker Registry
            # service connection to create the secret in your AKS namespace.
            - task: Kubernetes@1
              displayName: 'Create Image Pull Secret'
              inputs:
                command: 'create'
                secretType: 'dockerRegistry'
                secretName: 'acr-pull-secret'
                namespace: 'dev'
                dockerRegistryEndpoint: 'MyACRServiceConnection'
                # Uses the k8s service connection linked to the 'environment'

            - task: DownloadPipelineArtifact@1
              inputs: { artifactName: 'k8s-manifests', downloadPath: '$(Pipeline.Workspace)/manifests' }

            # The KubernetesManifest task is the standard for deploying.
            - task: KubernetesManifest@1
              displayName: 'Deploy to AKS'
              inputs:
                action: 'deploy'
                namespace: 'dev'
                manifests: '$(Pipeline.Workspace)/manifests/deployment.yaml'
                # This 'containers' input finds the container spec in the manifest
                # and replaces its image with the one we just built.
                containers: '$(ACRLoginServer)/$(imageRepository):$(imageTag)'

# ---------------------------------------------------------------------------------
# STAGE 3: Deploy to Azure Web App (QA)
# ---------------------------------------------------------------------------------
# This stage runs in PARALLEL with the AKS deployment stage.
- stage: DeployWebApp
  displayName: 'Deploy to Web App (QA)'
  dependsOn: Build
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))

  jobs:
  - deployment: DeployToWebApp_QA
    environment: 'WebApp-QA' # Targets a different logical environment for approvals.
    pool:
      vmImage: 'ubuntu-latest'
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: none
            - task: DownloadPipelineArtifact@1
              inputs: { artifactName: 'web-app-package', downloadPath: '$(Pipeline.Workspace)/webapp' }

            # This task deploys a .zip file to a standard Azure App Service (Web App).
            - task: AzureWebApp@1
              displayName: 'Deploy to Azure Web App'
              inputs:
                # This must be an 'Azure Resource Manager' service connection.
                azureSubscription: 'MyWebAppServiceConnection'
                appType: 'webAppLinux'
                appName: 'my-qa-webapp'
                package: '$(Pipeline.Workspace)/webapp/**/*.zip'
                # Environment variables can be injected here for App Service configuration.
                appSettings: '-ConnectionStrings__DefaultConnection $(QA_DB_CONNECTION_STRING)'

```