# Oauth2 - Auth Code  Flow

Let's build you into an expert on the standard Authorization Code flow.

# **The "Why": The Security Principle**

The entire purpose of this flow is to ensure that the valuable `access_token` is **never exposed to the user's browser**. It moves from the Authorization Server (Azure AD) directly to your secure backend server. This protects it from all kinds of browser-based attacks. This flow is specifically designed for **Confidential Clients**â€”applications that have a backend and are capable of securely storing a secret.

# **The Practical Example: "TaskMaster Pro" Web App**

Imagine a classic web application architecture:

- **TaskMaster Pro Web App:** A server-side rendered application (e.g., built with [ASP.NET](http://asp.net/) Core, Django, Java Spring). The user interacts with this application in their browser.
- **Tasks API:** Your custom, protected backend API. This is a separate service that manages the actual task data. It only trusts requests from the "TaskMaster Pro Web App".

## **The Actors in Our Story**

1. **Resource Owner (The User):** The person whose tasks are being managed.
2. **Client Application (The Confidential Client):** The "TaskMaster Pro Web App". It has a secure backend where it can store secrets.
3. **Authorization Server:** Azure Active Directory (AAD).
4. **Resource Server:** Your custom "Tasks API". This is what we need to protect.

## **The Analogy: The Secure Valet Service**

Think of this like a secure valet parking service for a high-security garage.

- **You (User):** You want to park your car.
- **The Valet (Web App):** The friendly person you talk to.
- **The Licensing Office (Azure AD):** Verifies who you are and gives permission.
- **The Secure Garage (Tasks API):** Where your car (data) is stored. The garage door only opens with a special electronic key fob.
- **The Valet Ticket (Authorization Code):** A temporary ticket the valet gets. A thief who steals this ticket can't get your car with it.
- **The Key Fob (Access Token):** The valet takes the ticket back to a secure booth (the backend) to exchange it for the real key fob that opens the garage door. The key fob is never brought out to the street (the browser).

# **The Step-by-Step Flow in Action**

### **Step 1: The User Initiates Login**

The user navigates to your "TaskMaster Pro Web App" and clicks "Log In".

### **Step 2: The Web App Redirects the User to Azure AD**

Your Web App's backend constructs a URL and redirects the user's browser to Azure AD to handle the authentication.

- **Browser Redirects to Azure AD:**
    
    ```
    GET <https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/authorize>
      ?client_id={web_app_client_id}
      &response_type=code
      &redirect_uri=https://taskmaster.com/callback
      &scope=api://{tasks_api_client_id}/tasks.read
      &state=xyz123
    
    ```
    
    - `response_type=code`: "I want to do the Authorization Code flow."
    - `scope`: This is critical. You are not requesting `user.read`. You are requesting the specific, custom permission you defined for your own API.
    - `state`: A random value to prevent Cross-Site Request Forgery (CSRF) attacks.

### **Step 3: The User Authenticates and Consents**

The user is now on a Microsoft login page.

1. They enter their credentials and perform MFA.
2. If it's the first time, they see a consent screen: *"TaskMaster Pro Web App would like to: Read your tasks"* (This text comes directly from the custom scope you will define).
3. The user accepts.

### **Step 4: Azure AD Redirects Back with the Authorization Code**

Azure AD redirects the user's browser back to the `redirect_uri` you specified, carrying the single-use `authorization_code` (the valet ticket).

- **Browser is Redirected Back to the Web App:**`https://taskmaster.com/callback?code=0.AXA...8aQc&state=xyz123`

### **Step 5: The Web App's Backend Exchanges the Code for a Token**

This is the most important step and happens entirely on the server, hidden from the user.

1. Your Web App's backend receives the request at `/callback`.
2. It validates that the `state` parameter matches what it sent in Step 2.
3. It now makes a direct, secure, server-to-server POST request to Azure AD's `/token` endpoint.
- **Backend Server sends a POST Request to Azure AD:**
    
    ```
    POST <https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/token>
    
    Content-Type: application/x-www-form-urlencoded
    
    grant_type=authorization_code
    &client_id={web_app_client_id}
    &client_secret={the_web_app's_secret}
    &code={the_code_from_step_4}
    &redirect_uri=https://taskmaster.com/callback
    &scope=api://{tasks_api_client_id}/tasks.read
    
    ```
    
    - `client_secret`: This is the proof that the request is coming from your real "TaskMaster Pro Web App" and not an impostor. This is what makes it a **confidential client**.

### **Step 6: Azure AD Validates and Returns Tokens to the Backend**

Azure AD validates the code, client_id, and client_secret. If everything matches, it returns the tokens directly to your backend server's memory.

- **Azure AD's JSON Response to the Backend:**
    
    ```json
    {
      "access_token": "eyJ0eXAiOiJKV...",
      "token_type": "Bearer",
      "expires_in": 3599,
      "refresh_token": "0.AXA..."
    }
    
    ```
    

### **Step 7: The Web App's Backend Calls Your Custom API**

Your Web App now has the `access_token` (the garage key fob). It can now make a secure, server-to-server call to your "Tasks API" to fetch the user's data.

- **Backend calls the Tasks API:**
    
    ```
    GET <https://api.taskmaster.com/tasks>
    
    Authorization: Bearer eyJ0eXAiOiJKV...
    
    ```
    
- Your "Tasks API" will receive this token, validate it, and see that it has the `tasks.read` scope, then return the data.

---

# **What Needs to be Done in Azure?**

You need two separate App Registrations.

### **1. App Registration for the "Tasks API" (The Resource Server):**

- Go to Azure AD -> App Registrations -> New registration. Name it `Tasks-API`.
- **The Crucial Part:** Go to the **"Expose an API"** blade.
    - Click "Set" next to Application ID URI. It will default to something like `api://{client_id}`. This URI is the unique identifier for your API.
    - Click **"Add a scope"**. This is how you define a **Delegated Permission**.
        - **Scope name:** `tasks.read`
        - **Who can consent?:** Admins and users
        - **Admin consent display name:** Read tasks
        - **User consent description:** Allows the application to read the user's tasks.
    - Create another scope called `tasks.write` for writing data.

### **2. App Registration for the "TaskMaster Pro Web App" (The Client):**

- Create another registration named `TaskMaster-WebApp`.
- Go to the **"Authentication"** blade.
    - Click "Add a platform" and select **"Web"**.
    - Enter your redirect URI: `https://taskmaster.com/callback`.
- Go to the **"Certificates & secrets"** blade.
    - Click "New client secret". Give it a name and copy the value immediately. This is the secret your backend will use.
- Go to the **"API permissions"** blade.
    - Click "Add a permission".
    - Select the **"My APIs"** tab.
    - Find and select your `Tasks-API`.
    - Choose **Delegated permissions**. You will see the `tasks.read` and `tasks.write` scopes you created. Check the boxes for the ones your web app needs.
    - Click "Add permissions".

---

# **Becoming an Expert: Key Concepts**

- **The Role of the `client_secret`:** The presence of the `client_secret` in the token exchange is the defining feature of this flow. It's why the client MUST be confidential. Never put a client secret in a JavaScript or mobile app.
- **Token Audience (`aud` claim):** The `access_token` issued in Step 6 has an "audience" claim (`aud`). Its value will be the Application ID URI of your `Tasks-API` (e.g., `api://{tasks_api_client_id}`). Your API code **must** validate this claim to ensure the token was intended for it and not some other API.
- **Refresh Tokens:** The `refresh_token` is extremely important. Your Web App's backend should securely cache it. When the `access_token` (which is short-lived, ~1 hour) expires, your backend can use the `refresh_token` to silently get a new `access_token` from Azure AD without forcing the user to log in again. This is crucial for a good user experience.
- **User Sessions:** Your Web App backend will typically use a standard session mechanism (like a cookie) to manage the user's logged-in state with the browser. The OAuth tokens should be stored securely on the server, associated with that user's session, ready to be used for API calls.