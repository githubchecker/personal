# 34. Property Configuration in Entity Framework Core using Fluent API

# Property Configuration in EF Core (Fluent API)

**Property Configurations** allow you to define rules specific to individual columns in your database. This includes mapping column names, setting data types, enforcing constraints, and configuring value generation.

---

### 1. Column Mapping and Data Types

By default, EF Core maps properties to columns with the same name and chooses a database type based on the .NET type. Use `HasColumnName` and `HasColumnType` to override these defaults.

```csharp
modelBuilder.Entity<Customer>()
    .Property(c => c.FirstName)
    .HasColumnName("First_Name")
    .HasColumnType("varchar(100)");
```

---

### 2. Constraints and Nullability

Define if a column is required (`NOT NULL`) and its maximum length.

```csharp
modelBuilder.Entity<Customer>()
    .Property(c => c.Email)
    .IsRequired()
    .HasMaxLength(255);

modelBuilder.Entity<Product>()
    .Property(p => p.Description)
    .IsRequired(false); // Nullable
```

---

### 3. Precision and Scale

Crucial for decimal types (e.g., currency, measurements) to avoid rounding errors.

```csharp
modelBuilder.Entity<Product>()
    .Property(p => p.Price)
    .HasPrecision(18, 2);
```

---

### 4. Default Values

Set static default values or use SQL functions for dynamic defaults.

```csharp
modelBuilder.Entity<Order>()
    .Property(o => o.Status)
    .HasDefaultValue("Pending");

modelBuilder.Entity<Order>()
    .Property(o => o.CreatedAt)
    .HasDefaultValueSql("GETUTCDATE()");
```

---

### 5. Computed Columns

Columns whose values are calculated by the database engine based on other columns.

```csharp
modelBuilder.Entity<OrderItem>()
    .Property(oi => oi.LineItemTotal)
    .HasComputedColumnSql("[Quantity] * [UnitPrice]");
```

---

### 6. Concurrency Tokens

Used for **Optimistic Concurrency** control to prevent users from overwriting each otherâ€™s changes.

### RowVersion (SQL Server)

Automatically updated by the database on every insert/update.

```csharp
modelBuilder.Entity<Product>()
    .Property(p => p.RowVersion)
    .IsRowVersion();
```

### Generic Concurrency Token

Mark any property as a token; EF will include it in the `WHERE` clause during updates.

```csharp
modelBuilder.Entity<Customer>()
    .Property(c => c.Email)
    .IsConcurrencyToken();
```

---

### 7. Value Conversions

Mapping a .NET type to a different storage format in the database.

```csharp
modelBuilder.Entity<Order>()
    .Property(o => o.Status)
    .HasConversion<string>(); // Stores enum names instead of integers
```

---

### 8. Value Generation Strategies

Control how and when values are generated by the database provider.

| Method | Description |
| --- | --- |
| `ValueGeneratedOnAdd()` | Generated for new records (e.g., Identity/Auto-increment). |
| `ValueGeneratedOnAddOrUpdate()` | Managed by the DB on every change (e.g., Computed/RowVersion). |
| `ValueGeneratedNever()` | Explicitly disables automatic value generation for a property. |

---

### 9. Shadow Properties

Properties that exist in the database and the EF Model but **not** in your physical C# entity class. Useful for audit metadata.

```csharp
// Configuration
modelBuilder.Entity<Product>()
    .Property<DateTime>("LastModifiedDate");

// Accessing/Setting in code
context.Entry(product).Property("LastModifiedDate").CurrentValue = DateTime.UtcNow;
```

---

### 10. Ignoring Properties

Exclude a specific property from being mapped to the database schema.

```csharp
modelBuilder.Entity<Product>()
    .Ignore(p => p.LocalValidationStatus);
```