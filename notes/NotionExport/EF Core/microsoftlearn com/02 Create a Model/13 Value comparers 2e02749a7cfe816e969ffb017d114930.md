# 13. Value comparers

# Value Comparers

**Value Comparers** define how EF Core snapshots and compares property values to detect changes. While EF Core handles most primitive types automatically, custom comparers are essential for **mutable reference types** or complex types mapped via value converters.

## 1. Why are they needed?

EF Core tracks changes by comparing a **snapshot** of an entity (taken when loaded) with its current state.

- **Value Types:** EF Core performs a memberwise copy and comparison by default.
- **Reference Types:** EF Core uses **Reference Equality** by default. If you modify a property of a reference type without replacing the instance (e.g., adding an item to a `List`), EF Core won't detect the change unless a custom comparer is used.

## 2. Implementing a Value Comparer

A `ValueComparer<T>` requires three logic pieces:

- **Equality:** How to determine if two values are the same.
- **Hash Code:** How to generate a stable hash for the value.
- **Snapshot:** How to create a deep copy of the value (crucial for mutable types).

### Example: `List<int>` mapped to JSON

```csharp
modelBuilder.Entity<User>()
    .Property(e => e.Roles)
    .HasConversion(
        v => JsonSerializer.Serialize(v, (JsonSerializerOptions)null),
        v => JsonSerializer.Deserialize<List<string>>(v, (JsonSerializerOptions)null),
        new ValueComparer<List<string>>(
            (c1, c2) => c1.SequenceEqual(c2), // Equality
            c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())), // Hash Code
            c => c.ToList() // Deep Copy Snapshot
        ));

```

## 3. Best Practices

### Prefer Immutability

If you use **immutable** types (e.g., `readonly struct` or a class with only `init` properties), EF Core can safely reuse the reference as a snapshot, and you don't need a custom comparer.

### Byte Arrays

By default, EF Core uses reference equality for byte arrays (efficient for large blobs like images). To detect changes within the array, you must apply a deep-comparison comparer:

```csharp
modelBuilder.Entity<User>()
    .Property(e => e.Avatar)
    .Metadata.SetValueComparer(new ValueComparer<byte[]>(
        (c1, c2) => c1.SequenceEqual(c2),
        c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
        c => c.ToArray()));

```

## 4. Key Summary

| Type Category | Default Comparison | Default Snapshot | Custom Comparer Required? |
| --- | --- | --- | --- |
| **Simple Value Types** | Equality Operator | Value Copy | No |
| **Immutable Ref Types** | Reference Equality | Reference Copy | No (if Equals is overridden) |
| **Mutable Ref Types** | Reference Equality | Reference Copy | **Yes** (to detect internal changes) |
| **Byte Arrays (Non-key)** | Reference Equality | Reference Copy | Optional (if internal mutation detection is needed) |