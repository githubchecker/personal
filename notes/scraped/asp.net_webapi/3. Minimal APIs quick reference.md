# Minimal APIs quick reference








This document:

* Provides a quick reference for Minimal APIs.
* Is intended for experienced developers. For an introduction, see [Tutorial: Create a Minimal API with ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/tutorials/min-web-api?view=aspnetcore-10.0).

The Minimal APIs consist of:

* [ `WebApplication`  and  `WebApplicationBuilder` ](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/webapplication?view=aspnetcore-10.0)
* [Route Handlers](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/route-handlers?view=aspnetcore-10.0)

## `WebApplication`

The following code is generated by an ASP.NET Core template:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

The preceding code can be created via  `dotnet new web`  on the command line or selecting the Empty Web template in Visual Studio.

The following code creates a [WebApplication](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication) ( `app` ) without explicitly creating a [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder):

```csharp
var app = WebApplication.Create(args);

app.MapGet("/", () => "Hello World!");

app.Run();
```

[ `WebApplication.Create` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.create) initializes a new instance of the [WebApplication](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication) class with preconfigured defaults.

### Working with ports

When a web app is created with Visual Studio or  `dotnet new` , a  `Properties/launchSettings.json`  file is created that specifies the ports the app responds to. In the port setting samples that follow, running the app from Visual Studio returns an error dialog  `Unable to connect to web server 'AppName'` . Visual Studio returns an error because it's expecting the port specified in  `Properties/launchSettings.json` , but the app is using the port specified by  `app.Run("http://localhost:3000")` . Run the following port changing samples from the command line.

The following sections set the port the app responds to.

```csharp
var app = WebApplication.Create(args);

app.MapGet("/", () => "Hello World!");

app.Run("http://localhost:3000");
```

In the preceding code, the app responds to port  `3000` .

#### Multiple ports

In the following code, the app responds to port  `3000`  and  `4000` .

```csharp
var app = WebApplication.Create(args);

app.Urls.Add("http://localhost:3000");
app.Urls.Add("http://localhost:4000");

app.MapGet("/", () => "Hello World");

app.Run();
```

#### Set the port from the command line

The following command makes the app respond to port  `7777` :

```dotnetcli
dotnet run --urls="https://localhost:7777"
```

If the Kestrel endpoint is also configured in the  `appsettings.json`  file, the  `appsettings.json`  file specified URL is used. For more information, see [Kestrel endpoint configuration](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0#kestrel)

#### Read the port from environment

The following code reads the port from the environment:

```csharp
var app = WebApplication.Create(args);

var port = Environment.GetEnvironmentVariable("PORT") ?? "3000";

app.MapGet("/", () => "Hello World");

app.Run($"http://localhost:{port}");
```

The preferred way to set the port from the environment is to use the  `ASPNETCORE_URLS`  environment variable, which is shown in the following section.

#### Set the ports via the ASPNETCORE\_URLS environment variable

The  `ASPNETCORE_URLS`  environment variable is available to set the port:

```
ASPNETCORE_URLS=http://localhost:3000
```

`ASPNETCORE_URLS`  supports multiple URLs:

```
ASPNETCORE_URLS=http://localhost:3000;https://localhost:5000
```

### Listen on all interfaces

The following samples demonstrate listening on all interfaces

#### http://\*:3000

```csharp
var app = WebApplication.Create(args);

app.Urls.Add("http://*:3000");

app.MapGet("/", () => "Hello World");

app.Run();
```

#### http://+:3000

```csharp
var app = WebApplication.Create(args);

app.Urls.Add("http://+:3000");

app.MapGet("/", () => "Hello World");

app.Run();
```

#### `http://0.0.0.0:3000`

```csharp
var app = WebApplication.Create(args);

app.Urls.Add("http://0.0.0.0:3000");

app.MapGet("/", () => "Hello World");

app.Run();
```

### Listen on all interfaces using ASPNETCORE\_URLS

The preceding samples can use  `ASPNETCORE_URLS`

```
ASPNETCORE_URLS=http://*:3000;https://+:5000;http://0.0.0.0:5005
```

### Listen on all interfaces using ASPNETCORE\_HTTPS\_PORTS

The preceding samples can use  `ASPNETCORE_HTTPS_PORTS`  and  `ASPNETCORE_HTTP_PORTS` .

```
ASPNETCORE_HTTP_PORTS=3000;5005
ASPNETCORE_HTTPS_PORTS=5000
```

For more information, see [Configure endpoints for the ASP.NET Core Kestrel web server](https://learn.microsoft.com/en-us/aspnet/core/servers/kestrel/endpoints?view=aspnetcore-10.0)

### Specify HTTPS with development certificate

```csharp
var app = WebApplication.Create(args);

app.Urls.Add("https://localhost:3000");

app.MapGet("/", () => "Hello World");

app.Run();
```

For more information on the development certificate, see [Trust the ASP.NET Core HTTPS development certificate on Windows and macOS](https://learn.microsoft.com/en-us/aspnet/security/enforcing-ssl?view=aspnetcore-10.0#trust).

### Specify HTTPS using a custom certificate

The following sections show how to specify the custom certificate using the  `appsettings.json`  file and via configuration.

#### Specify the custom certificate with `appsettings.json`

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "Certificates": {
      "Default": {
        "Path": "cert.pem",
        "KeyPath": "key.pem"
      }
    }
  }
}
```

#### Specify the custom certificate via configuration

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configure the cert and the key
builder.Configuration["Kestrel:Certificates:Default:Path"] = "cert.pem";
builder.Configuration["Kestrel:Certificates:Default:KeyPath"] = "key.pem";

var app = builder.Build();

app.Urls.Add("https://localhost:3000");

app.MapGet("/", () => "Hello World");

app.Run();
```

#### Use the certificate APIs

```csharp
using System.Security.Cryptography.X509Certificates;

var builder = WebApplication.CreateBuilder(args);

builder.WebHost.ConfigureKestrel(options =>
{
    options.ConfigureHttpsDefaults(httpsOptions =>
    {
        var certPath = Path.Combine(builder.Environment.ContentRootPath, "cert.pem");
        var keyPath = Path.Combine(builder.Environment.ContentRootPath, "key.pem");

        httpsOptions.ServerCertificate = X509Certificate2.CreateFromPemFile(certPath, 
                                         keyPath);
    });
});

var app = builder.Build();

app.Urls.Add("https://localhost:3000");

app.MapGet("/", () => "Hello World");

app.Run();
```

### Read the environment

```csharp
var app = WebApplication.Create(args);

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/oops");
}

app.MapGet("/", () => "Hello World");
app.MapGet("/oops", () => "Oops! An error happened.");

app.Run();
```

For more information using the environment, see [ASP.NET Core runtime environments](https://learn.microsoft.com/en-us/aspnet/core/environments?view=aspnetcore-10.0)

### Configuration

The following code reads from the configuration system:

```csharp
var app = WebApplication.Create(args);

var message = app.Configuration["HelloKey"] ?? "Config failed!";

app.MapGet("/", () => message);

app.Run();
```

For more information, see [Configuration in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0)

### Logging

The following code writes a message to the log on application startup:

```csharp
var app = WebApplication.Create(args);

app.Logger.LogInformation("The app started");

app.MapGet("/", () => "Hello World");

app.Run();
```

For more information, see [Logging in .NET and ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/logging/?view=aspnetcore-10.0)

### Access the Dependency Injection (DI) container

The following code shows how to get services from the DI container during application startup:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddScoped<SampleService>();

var app = builder.Build();

app.MapControllers();

using (var scope = app.Services.CreateScope())
{
    var sampleService = scope.ServiceProvider.GetRequiredService<SampleService>();
    sampleService.DoSomething();
}

app.Run();
```

The following code shows how to access keys from the DI container using the [ `[FromKeyedServices]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.fromkeyedservicesattribute) attribute:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddKeyedSingleton<ICache, BigCache>("big");
builder.Services.AddKeyedSingleton<ICache, SmallCache>("small");

var app = builder.Build();

app.MapGet("/big", ([FromKeyedServices("big")] ICache bigCache) => bigCache.Get("date"));

app.MapGet("/small", ([FromKeyedServices("small")] ICache smallCache) => smallCache.Get("date"));

app.Run();

public interface ICache
{
    object Get(string key);
}
public class BigCache : ICache
{
    public object Get(string key) => $"Resolving {key} from big cache.";
}

public class SmallCache : ICache
{
    public object Get(string key) => $"Resolving {key} from small cache.";
}
```

For more information on DI, see [Dependency injection in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/dependency-injection?view=aspnetcore-10.0).

## WebApplicationBuilder

This section contains sample code using [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder).

### Change the content root, application name, and environment

The following code sets the content root, application name, and environment:

```csharp
var builder = WebApplication.CreateBuilder(new WebApplicationOptions
{
    Args = args,
    ApplicationName = typeof(Program).Assembly.FullName,
    ContentRootPath = Directory.GetCurrentDirectory(),
    EnvironmentName = Environments.Staging,
    WebRootPath = "customwwwroot"
});

Console.WriteLine($"Application Name: {builder.Environment.ApplicationName}");
Console.WriteLine($"Environment Name: {builder.Environment.EnvironmentName}");
Console.WriteLine($"ContentRoot Path: {builder.Environment.ContentRootPath}");
Console.WriteLine($"WebRootPath: {builder.Environment.WebRootPath}");

var app = builder.Build();
```

[WebApplication.CreateBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createbuilder) initializes a new instance of the [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) class with preconfigured defaults.

For more information, see [ASP.NET Core fundamentals overview](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-10.0)

### Change the content root, app name, and environment by using environment variables or command line

The following table shows the environment variable and command-line argument used to change the content root, app name, and environment:

| feature | Environment variable | Command-line argument |
| --- | --- | --- |
| Application name | ASPNETCORE\_APPLICATIONNAME | --applicationName |
| Environment name | ASPNETCORE\_ENVIRONMENT | --environment |
| Content root | ASPNETCORE\_CONTENTROOT | --contentRoot |

### Add configuration providers

The following sample adds the INI configuration provider:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Configuration.AddIniFile("appsettings.ini");

var app = builder.Build();
```

For detailed information, see [File configuration providers](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0#file-configuration-provider) in [Configuration in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0).

### Read configuration

By default the [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) reads configuration from multiple sources, including:

* `appSettings.json`  and  `appSettings.{environment}.json`
* Environment variables
* The command line

For a complete list of configuration sources read, see [Default configuration](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0#default-configuration) in [Configuration in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0).

The following code reads  `HelloKey`  from configuration and displays the value at the  `/`  endpoint. If the configuration value is null, "Hello" is assigned to  `message` :

```csharp
var builder = WebApplication.CreateBuilder(args);

var message = builder.Configuration["HelloKey"] ?? "Hello";

var app = builder.Build();

app.MapGet("/", () => message);

app.Run();
```

### Read the environment

```csharp
var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsDevelopment())
{
    Console.WriteLine($"Running in development.");
}

var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

### Add logging providers

```csharp
var builder = WebApplication.CreateBuilder(args);

// Configure JSON logging to the console.
builder.Logging.AddJsonConsole();

var app = builder.Build();

app.MapGet("/", () => "Hello JSON console!");

app.Run();
```

### Add services

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add the memory cache services.
builder.Services.AddMemoryCache();

// Add a custom scoped service.
builder.Services.AddScoped<ITodoRepository, TodoRepository>();
var app = builder.Build();
```

### Customize the IHostBuilder

Existing extension methods on [IHostBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostbuilder) can be accessed using the [Host property](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostbuilder.properties#microsoft-extensions-hosting-ihostbuilder-properties):

```csharp
var builder = WebApplication.CreateBuilder(args);

// Wait 30 seconds for graceful shutdown.
builder.Host.ConfigureHostOptions(o => o.ShutdownTimeout = TimeSpan.FromSeconds(30));

var app = builder.Build();

app.MapGet("/", () => "Hello World!");

app.Run();
```

### Customize the IWebHostBuilder

Extension methods on [IWebHostBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.iwebhostbuilder) can be accessed using the [WebApplicationBuilder.WebHost](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder.webhost#microsoft-aspnetcore-builder-webapplicationbuilder-webhost) property.

```csharp
var builder = WebApplication.CreateBuilder(args);

// Change the HTTP server implemenation to be HTTP.sys based
builder.WebHost.UseHttpSys();

var app = builder.Build();

app.MapGet("/", () => "Hello HTTP.sys");

app.Run();
```

### Change the web root

By default, the web root is relative to the content root in the  `wwwroot`  folder. Web root is where the Static File Middleware looks for static files. Web root can be changed with  `WebHostOptions` , the command line, or with the [UseWebRoot](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.hostingabstractionswebhostbuilderextensions.usewebroot) method:

```csharp
var builder = WebApplication.CreateBuilder(new WebApplicationOptions
{
    Args = args,
    // Look for static files in webroot
    WebRootPath = "webroot"
});

var app = builder.Build();

app.Run();
```

### Custom dependency injection (DI) container

The following example uses [Autofac](https://autofac.readthedocs.io/en/latest/integration/aspnetcore.html):

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Host.UseServiceProviderFactory(new AutofacServiceProviderFactory());

// Register services directly with Autofac here. Don't
// call builder.Populate(), that happens in AutofacServiceProviderFactory.
builder.Host.ConfigureContainer<ContainerBuilder>(builder => builder.RegisterModule(new MyApplicationModule()));

var app = builder.Build();
```

### Add Middleware

Any existing ASP.NET Core middleware can be configured on the  `WebApplication` :

```csharp
var app = WebApplication.Create(args);

// Setup the file server to serve static files.
app.UseFileServer();

app.MapGet("/", () => "Hello World!");

app.Run();
```

For more information, see [ASP.NET Core Middleware](https://learn.microsoft.com/en-us/aspnet/core/middleware/?view=aspnetcore-10.0)

### Developer exception page

[WebApplication.CreateBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createbuilder) initializes a new instance of the [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) class with preconfigured defaults. The developer exception page is enabled in the preconfigured defaults. When the following code is run in the [development environment](https://learn.microsoft.com/en-us/aspnet/core/environments?view=aspnetcore-10.0), navigating to  `/`  renders a friendly page that shows the exception.

```csharp
var builder = WebApplication.CreateBuilder(args);

var app = builder.Build();

app.MapGet("/", () =>
{
    throw new InvalidOperationException("Oops, the '/' route has thrown an exception.");
});

app.Run();
```

## ASP.NET Core Middleware

The following table lists some of the middleware frequently used with Minimal APIs.

| Middleware | Description | API |
| --- | --- | --- |
| [Authentication](https://learn.microsoft.com/en-us/aspnet/security/authentication/?view=aspnetcore-10.0) | Provides authentication support. | [UseAuthentication](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication) |
| [Authorization](https://learn.microsoft.com/en-us/aspnet/security/authorization/introduction?view=aspnetcore-10.0) | Provides authorization support. | [UseAuthorization](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authorizationappbuilderextensions.useauthorization) |
| [CORS](https://learn.microsoft.com/en-us/aspnet/security/cors?view=aspnetcore-10.0) | Configures Cross-Origin Resource Sharing. | [UseCors](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.corsmiddlewareextensions.usecors) |
| [Exception Handler](https://learn.microsoft.com/en-us/aspnet/core/error-handling-api?view=aspnetcore-10.0) | Globally handles exceptions thrown by the middleware pipeline. | [UseExceptionHandler](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler) |
| [Forwarded Headers](https://learn.microsoft.com/en-us/aspnet/core/middleware/?view=aspnetcore-10.0#forwarded-headers-middleware-order) | Forwards proxied headers onto the current request. | [UseForwardedHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.forwardedheadersextensions.useforwardedheaders) |
| [HTTPS Redirection](https://learn.microsoft.com/en-us/aspnet/security/enforcing-ssl?view=aspnetcore-10.0) | Redirects all HTTP requests to HTTPS. | [UseHttpsRedirection](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httpspolicybuilderextensions.usehttpsredirection) |
| [HTTP Strict Transport Security (HSTS)](https://learn.microsoft.com/en-us/aspnet/core/middleware/?view=aspnetcore-10.0#middleware-order) | Security enhancement middleware that adds a special response header. | [UseHsts](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.hstsbuilderextensions.usehsts) |
| [Request Logging](https://learn.microsoft.com/en-us/aspnet/core/logging/?view=aspnetcore-10.0) | Provides support for logging HTTP requests and responses. | [UseHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httploggingbuilderextensions.usehttplogging) |
| [Request Timeouts](https://learn.microsoft.com/en-us/aspnet/performance/timeouts?view=aspnetcore-10.0) | Provides support for configuring request timeouts, global default and per endpoint. | `UseRequestTimeouts` |
| [W3C Request Logging](https://www.w3.org/TR/WD-logfile.html) | Provides support for logging HTTP requests and responses in the [W3C format](https://www.w3.org/TR/WD-logfile.html). | [UseW3CLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httploggingbuilderextensions.usew3clogging) |
| [Response Caching](https://learn.microsoft.com/en-us/aspnet/performance/caching/middleware?view=aspnetcore-10.0) | Provides support for caching responses. | [UseResponseCaching](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.responsecachingextensions.useresponsecaching) |
| [Response Compression](https://learn.microsoft.com/en-us/aspnet/performance/response-compression?view=aspnetcore-10.0) | Provides support for compressing responses. | [UseResponseCompression](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.responsecompressionbuilderextensions.useresponsecompression) |
| [Session](https://learn.microsoft.com/en-us/aspnet/core/app-state?view=aspnetcore-10.0) | Provides support for managing user sessions. | [UseSession](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.sessionmiddlewareextensions.usesession) |
| [Static Files](https://learn.microsoft.com/en-us/aspnet/core/static-files?view=aspnetcore-10.0) | Provides support for serving static files and directory browsing. | [UseStaticFiles](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles), [UseFileServer](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.fileserverextensions.usefileserver) |
| [WebSockets](https://learn.microsoft.com/en-us/aspnet/core/websockets?view=aspnetcore-10.0) | Enables the WebSockets protocol. | [UseWebSockets](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.websocketmiddlewareextensions.usewebsockets) |

The following sections cover request handling: routing, parameter binding, and responses.

## Routing

A configured  `WebApplication`  supports  `Map{Verb}`  and [MapMethods](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mapmethods) where  `{Verb}`  is a camel-cased HTTP method like  `Get` ,  `Post` ,  `Put` , or  `Delete` :

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", () => "This is a GET");
app.MapPost("/", () => "This is a POST");
app.MapPut("/", () => "This is a PUT");
app.MapDelete("/", () => "This is a DELETE");

app.MapMethods("/options-or-head", new[] { "OPTIONS", "HEAD" }, 
                          () => "This is an options or head request ");

app.Run();
```

The [Delegate](https://learn.microsoft.com/en-us/dotnet/api/system.delegate) arguments passed to these methods are called "route handlers".

### Route Handlers

Route handlers are methods that execute when the route matches. Route handlers can be a lambda expression, a local function, an instance method or a static method. Route handlers can be synchronous or asynchronous.

### Lambda expression

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/inline", () => "This is an inline lambda");

var handler = () => "This is a lambda variable";

app.MapGet("/", handler);

app.Run();
```

### Local function

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

string LocalFunction() => "This is local function";

app.MapGet("/", LocalFunction);

app.Run();
```

### Instance method

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var handler = new HelloHandler();

app.MapGet("/", handler.Hello);

app.Run();

class HelloHandler
{
    public string Hello()
    {
        return "Hello Instance method";
    }
}
```

### Static method

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/", HelloHandler.Hello);

app.Run();

class HelloHandler
{
    public static string Hello()
    {
        return "Hello static method";
    }
}
```

### Endpoint defined outside of `Program.cs`

Minimal APIs don't have to be located in  `Program.cs` .

`Program.cs`

```csharp
using MinAPISeparateFile;

var builder = WebApplication.CreateSlimBuilder(args);

var app = builder.Build();

TodoEndpoints.Map(app);

app.Run();
```

`TodoEndpoints.cs`

```csharp
namespace MinAPISeparateFile;

public static class TodoEndpoints
{
    public static void Map(WebApplication app)
    {
        app.MapGet("/", async context =>
        {
            // Get all todo items
            await context.Response.WriteAsJsonAsync(new { Message = "All todo items" });
        });

        app.MapGet("/{id}", async context =>
        {
            // Get one todo item
            await context.Response.WriteAsJsonAsync(new { Message = "One todo item" });
        });
    }
}
```

See also [Route groups](https://learn.microsoft.com/en-us/aspnet/core/#route-groups) later in this article.

### Named endpoints and link generation

Endpoints can be given names in order to generate URLs to the endpoint. Using a named endpoint avoids having to hard code paths in an app:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/hello", () => "Hello named route")
   .WithName("hi");

app.MapGet("/", (LinkGenerator linker) => 
        $"The link to the hello route is {linker.GetPathByName("hi", values: null)}");

app.Run();
```

The preceding code displays  `The link to the hello route is /hello`  from the  `/`  endpoint.

**NOTE**: Endpoint names are case sensitive.

Endpoint names:

* Must be globally unique.
* Are used as the OpenAPI operation id when OpenAPI support is enabled. For more information, see [OpenAPI](https://learn.microsoft.com/en-us/aspnet/core/openapi/aspnetcore-openapi?view=aspnetcore-10.0).

### Route Parameters

Route parameters can be captured as part of the route pattern definition:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/users/{userId}/books/{bookId}", 
    (int userId, int bookId) => $"The user id is {userId} and book id is {bookId}");

app.Run();
```

The preceding code returns  `The user id is 3 and book id is 7`  from the URI  `/users/3/books/7` .

The route handler can declare the parameters to capture. When a request is made to a route with parameters declared to capture, the parameters are parsed and passed to the handler. This makes it easy to capture the values in a type safe way. In the preceding code,  `userId`  and  `bookId`  are both  `int` .

In the preceding code, if either route value cannot be converted to an  `int` , an exception is thrown. The GET request  `/users/hello/books/3`  throws the following exception:

** `BadHttpRequestException: Failed to bind parameter "int userId" from "hello".` **

### Wildcard and catch all routes

The following catch all route returns  `Routing to hello`  from the `/posts/hello' endpoint:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/posts/{*rest}", (string rest) => $"Routing to {rest}");

app.Run();
```

### Route constraints

Route constraints constrain the matching behavior of a route.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/todos/{id:int}", (int id) => db.Todos.Find(id));
app.MapGet("/todos/{text}", (string text) => db.Todos.Where(t => t.Text.Contains(text));
app.MapGet("/posts/{slug:regex(^[a-z0-9_-]+$)}", (string slug) => $"Post {slug}");

app.Run();
```

The following table demonstrates the preceding route templates and their behavior:

| Route Template | Example Matching URI |
| --- | --- |
| `/todos/{id:int}` | `/todos/1` |
| `/todos/{text}` | `/todos/something` |
| `/posts/{slug:regex(^[a-z0-9_-]+$)}` | `/posts/mypost` |

For more information, see [Route constraint reference](https://learn.microsoft.com/en-us/aspnet/core/routing?view=aspnetcore-10.0) in [Routing in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/routing?view=aspnetcore-10.0).

### Route groups

The [MapGroup](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutebuilderextensions.mapgroup) extension method helps organize groups of endpoints with a common prefix. It reduces repetitive code and allows for customizing entire groups of endpoints with a single call to methods like [RequireAuthorization](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authorizationendpointconventionbuilderextensions.requireauthorization) and [WithMetadata](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.routingendpointconventionbuilderextensions.withmetadata) which add [endpoint metadata](https://learn.microsoft.com/en-us/aspnet/core/routing?view=aspnetcore-10.0#endpoint-metadata).

For example, the following code creates two similar groups of endpoints:

```csharp
app.MapGroup("/public/todos")
    .MapTodosApi()
    .WithTags("Public");

app.MapGroup("/private/todos")
    .MapTodosApi()
    .WithTags("Private")
    .AddEndpointFilterFactory(QueryPrivateTodos)
    .RequireAuthorization();


EndpointFilterDelegate QueryPrivateTodos(EndpointFilterFactoryContext factoryContext, EndpointFilterDelegate next)
{
    var dbContextIndex = -1;

    foreach (var argument in factoryContext.MethodInfo.GetParameters())
    {
        if (argument.ParameterType == typeof(TodoDb))
        {
            dbContextIndex = argument.Position;
            break;
        }
    }

    // Skip filter if the method doesn't have a TodoDb parameter.
    if (dbContextIndex < 0)
    {
        return next;
    }

    return async invocationContext =>
    {
        var dbContext = invocationContext.GetArgument<TodoDb>(dbContextIndex);
        dbContext.IsPrivate = true;

        try
        {
            return await next(invocationContext);
        }
        finally
        {
            // This should only be relevant if you're pooling or otherwise reusing the DbContext instance.
            dbContext.IsPrivate = false;
        }
    };
}
```

```csharp
public static RouteGroupBuilder MapTodosApi(this RouteGroupBuilder group)
{
    group.MapGet("/", GetAllTodos);
    group.MapGet("/{id}", GetTodo);
    group.MapPost("/", CreateTodo);
    group.MapPut("/{id}", UpdateTodo);
    group.MapDelete("/{id}", DeleteTodo);

    return group;
}
```

In this scenario, you can use a relative address for the  `Location`  header in the  `201 Created`  result:

```csharp
public static async Task<Created<Todo>> CreateTodo(Todo todo, TodoDb database)
{
    await database.AddAsync(todo);
    await database.SaveChangesAsync();

    return TypedResults.Created($"{todo.Id}", todo);
}
```

The first group of endpoints will only match requests prefixed with  `/public/todos`  and are accessible without any authentication. The second group of endpoints will only match requests prefixed with  `/private/todos`  and require authentication.

The  `QueryPrivateTodos`  [endpoint filter factory](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/min-api-filters?view=aspnetcore-10.0) is a local function that modifies the route handler's  `TodoDb`  parameters to allow to access and store private todo data.

Route groups also support nested groups and complex prefix patterns with route parameters and constraints. In the following example, and route handler mapped to the  `user`  group can capture the  `{org}`  and  `{group}`  route parameters defined in the outer group prefixes.

The prefix can also be empty. This can be useful for adding endpoint metadata or filters to a group of endpoints without changing the route pattern.

```csharp
var all = app.MapGroup("").WithOpenApi();
var org = all.MapGroup("{org}");
var user = org.MapGroup("{user}");
user.MapGet("", (string org, string user) => $"{org}/{user}");
```

Adding filters or metadata to a group behaves the same way as adding them individually to each endpoint before adding any extra filters or metadata that may have been added to an inner group or specific endpoint.

```csharp
var outer = app.MapGroup("/outer");
var inner = outer.MapGroup("/inner");

inner.AddEndpointFilter((context, next) =>
{
    app.Logger.LogInformation("/inner group filter");
    return next(context);
});

outer.AddEndpointFilter((context, next) =>
{
    app.Logger.LogInformation("/outer group filter");
    return next(context);
});

inner.MapGet("/", () => "Hi!").AddEndpointFilter((context, next) =>
{
    app.Logger.LogInformation("MapGet filter");
    return next(context);
});
```

In the above example, the outer filter will log the incoming request before the inner filter even though it was added second. Because the filters were applied to different groups, the order they were added relative to each other does not matter. The order filters are added does matter if applied to the same group or specific endpoint.

A request to  `/outer/inner/`  will log the following:

```dotnetcli
/outer group filter
/inner group filter
MapGet filter
```

## Parameter binding

Parameter binding is the process of converting request data into strongly typed parameters that are expressed by route handlers. A binding source determines where parameters are bound from. Binding sources can be explicit or inferred based on HTTP method and parameter type.

Supported binding sources:

* Route values
* Query string
* Header
* Body (as JSON)
* Form values
* Services provided by dependency injection
* Custom

The following GET route handler uses some of these parameter binding sources:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Added as service
builder.Services.AddSingleton<Service>();

var app = builder.Build();

app.MapGet("/{id}", (int id,
                     int page,
                     [FromHeader(Name = "X-CUSTOM-HEADER")] string customHeader,
                     Service service) => { });

class Service { }
```

### Key parameter binding features

* **Explicit binding**: Use attributes like  `[FromRoute]` ,  `[FromQuery]` ,  `[FromHeader]` ,  `[FromBody]` ,  `[FromForm]` , and  `[FromServices]`  to explicitly specify binding sources.
* **Form binding**: Bind form values using  `[FromForm]`  attribute, including support for  `IFormFile`  and  `IFormFileCollection`  for file uploads.
* **Complex types**: Bind to collections and complex types from forms, query strings, and headers.
* **Custom binding**: Implement custom binding logic using  `TryParse` ,  `BindAsync` , or the  `IBindableFromHttpContext<T>`  interface.
* **Optional parameters**: Support nullable types and default values for optional parameters.
* **Dependency injection**: Parameters are automatically bound from services registered in the DI container.
* **Special types**: Automatic binding for  `HttpContext` ,  `HttpRequest` ,  `HttpResponse` ,  `CancellationToken` ,  `ClaimsPrincipal` ,  `Stream` , and  `PipeReader` .

---

**Learn more:** For detailed information on parameter binding including advanced scenarios, validation, binding precedence, and troubleshooting, see [Parameter binding in Minimal API applications](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/parameter-binding?view=aspnetcore-10.0).

## Json+PipeReader deserialization in Minimal APIs

Starting in .NET 10, the following functional areas of ASP.NET Core use overloads of [JsonSerializer.DeserializeAsync](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializer.deserializeasync) based on PipeReader instead of Stream:

* Minimal APIs (parameter binding, read request body)
* MVC (input formatters, model)
* The [HttpRequestJsonExtensions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httprequestjsonextensions) Extension methods to read the request body as JSON.

For most applications, a transition from Stream to PipeReader provides better performance without requiring changes in application code. But if your application has a custom converter, the converter might not handle [Utf8JsonReader.HasValueSequence](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.utf8jsonreader.hasvaluesequence) correctly. If it doesn't, the result could be errors such as [ArgumentOutOfRangeException](https://learn.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception) or missing data when deserializing. You have the following options for getting your converter to work without PipeReader-related errors.

### Option 1: Temporary workaround

The quick workaround is to go back to using Stream without PipeReader support. To implement this option, set the "Microsoft.AspNetCore.UseStreamBasedJsonParsing" AppContext switch to "true". We recommend that you do this only as a temporary workaround, and update your converter to support  `HasValueSequence`  as soon as possible. The switch might be removed in .NET 11. Its only purpose was to give developers time to get their converters updated.

### Option 2: A quick fix for `JsonConverter` implementations

For this fix, you allocate an array from the  `ReadOnlySequence` . This example shows what the code would look like:

```csharp
public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
{
    var span = reader.HasValueSequence ? reader.ValueSequence.ToArray() : reader.ValueSpan;
    // previous code
}
```

### Option 3: A more complicated but better performing fix

This fix involves setting up a separate code path for the  `ReadOnlySequence`  handling:

```csharp
public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
{
    if (reader.HasValueSequence)
    {
        reader.ValueSequence;
        // ReadOnlySequence optimized path
    }
    else
    {
        reader.ValueSpan;
        // ReadOnlySpan optimized path
    }
}
```

For more information, see

* [System.Text.Json.Serialization.JsonConverter](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonconverter)
* [github.com/dotnet/aspnetcore/pull/62895](https://github.com/dotnet/aspnetcore/pull/62895)

## Validation support in Minimal APIs

Enabling validation allows the ASP.NET Core runtime to perform validations defined on the:

* Query
* Header
* Request body

Validations are defined using attributes in the [ `DataAnnotations` ](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations) namespace.

When a parameter to a Minimal API endpoint is a class or record type, validation attributes are automatically applied. For example:

```csharp
public record Product(
    [Required] string Name,
    [Range(1, 1000)] int Quantity);
```

Developers customize the behavior of the validation system by:

* Creating custom [ `[Validation]`  attribute](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.validationattribute) implementations.
* Implementing the [ `IValidatableObject` ](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.ivalidatableobject) interface for complex validation logic.

If validation fails, the runtime returns a *400 - Bad Request* response with details of the validation errors.

### Enable built-in validation support for Minimal APIs

Enable the built-in validation support for Minimal APIs by calling the  `AddValidation`  extension method to register the required services in the service container for your application:

```csharp
builder.Services.AddValidation();
```

The implementation automatically discovers types that are defined in Minimal API handlers or as base types of types defined in Minimal API handlers. An endpoint filter performs validation on these types and is added for each endpoint.

Validation can be disabled for specific endpoints by using the  `DisableValidation`  extension method, as in the following example:

```csharp
app.MapPost("/products",
    ([EvenNumber(ErrorMessage = "Product ID must be even")] int productId, [Required] string name)
        => TypedResults.Ok(productId))
    .DisableValidation();
```

### Customize validation error responses using IProblemDetailsService

Customize error responses from Minimal API validation logic with an [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) implementation. Register this service in your application's service collection to enable more consistent and user-specific error responses. Support for Minimal API validation was introduced in ASP.NET Core in .NET 10.

To implement custom validation error responses:

* Implement [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) or use the default implementation
* Register the service in the DI container
* The validation system automatically uses the registered service to format validation error responses

For more information on customizing validation error responses with IProblemDetailsService, see [Create responses in Minimal API applications](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/responses?view=aspnetcore-10.0#customize-validation-error-responses-using-iproblemdetailsservice).

## Responses

Route handlers support the following types of return values:

1. `IResult`  based - This includes  `Task<IResult>`  and  `ValueTask<IResult>`
2. `string`  - This includes  `Task<string>`  and  `ValueTask<string>`
3. `T`  (Any other type) - This includes  `Task<T>`  and  `ValueTask<T>`

| Return value | Behavior | Content-Type |
| --- | --- | --- |
| `IResult` | The framework calls [IResult.ExecuteAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult.executeasync) | Decided by the  `IResult`  implementation |
| `string` | The framework writes the string directly to the response | `text/plain` |
| `T`  (Any other type) | The framework JSON-serializes the response | `application/json` |

For a more in-depth guide to route handler return values see [Create responses in Minimal API applications](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/responses?view=aspnetcore-10.0)

### Example return values

#### string return values

```csharp
app.MapGet("/hello", () => "Hello World");
```

#### JSON return values

```csharp
app.MapGet("/hello", () => new { Message = "Hello World" });
```

#### Return TypedResults

The following code returns a [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults):

```csharp
app.MapGet("/hello", () => TypedResults.Ok(new Message() {  Text = "Hello World!" }));
```

Returning  `TypedResults`  is preferred to returning [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results). For more information, see [TypedResults vs Results](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses#typedresults-vs-results).

#### IResult return values

```csharp
app.MapGet("/hello", () => Results.Ok(new { Message = "Hello World" }));
```

The following example uses the built-in result types to customize the response:

```csharp
app.MapGet("/api/todoitems/{id}", async (int id, TodoDb db) =>
         await db.Todos.FindAsync(id) 
         is Todo todo
         ? Results.Ok(todo) 
         : Results.NotFound())
   .Produces<Todo>(StatusCodes.Status200OK)
   .Produces(StatusCodes.Status404NotFound);
```

#### JSON

```csharp
app.MapGet("/hello", () => Results.Json(new { Message = "Hello World" }));
```

#### Custom Status Code

```csharp
app.MapGet("/405", () => Results.StatusCode(405));
```

#### Text

```csharp
app.MapGet("/text", () => Results.Text("This is some text"));
```

#### Stream

```csharp
var proxyClient = new HttpClient();
app.MapGet("/pokemon", async () => 
{
    var stream = await proxyClient.GetStreamAsync("http://contoso/pokedex.json");
    // Proxy the response as JSON
    return Results.Stream(stream, "application/json");
});
```

See [Create responses in Minimal API applications](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/responses?view=aspnetcore-10.0#stream7) for more examples.

#### Redirect

```csharp
app.MapGet("/old-path", () => Results.Redirect("/new-path"));
```

#### File

```csharp
app.MapGet("/download", () => Results.File("myfile.text"));
```

### Built-in results

Common result helpers exist in the [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results) and [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) static classes. Returning  `TypedResults`  is preferred to returning  `Results` . For more information, see [TypedResults vs Results](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses#typedresults-vs-results).

### Modifying Headers

Use the  `HttpResponse`  object to modify response headers:

```csharp
app.MapGet("/", (HttpContext context) => {
    // Set a custom header
    context.Response.Headers["X-Custom-Header"] = "CustomValue";

    // Set a known header
    context.Response.Headers.CacheControl = $"public,max-age=3600";

    return "Hello World";
});
```

### Customizing results

Applications can control responses by implementing a custom [IResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult) type. The following code is an example of an HTML result type:

```csharp
using System.Net.Mime;
using System.Text;
static class ResultsExtensions
{
    public static IResult Html(this IResultExtensions resultExtensions, string html)
    {
        ArgumentNullException.ThrowIfNull(resultExtensions);

        return new HtmlResult(html);
    }
}

class HtmlResult : IResult
{
    private readonly string _html;

    public HtmlResult(string html)
    {
        _html = html;
    }

    public Task ExecuteAsync(HttpContext httpContext)
    {
        httpContext.Response.ContentType = MediaTypeNames.Text.Html;
        httpContext.Response.ContentLength = Encoding.UTF8.GetByteCount(_html);
        return httpContext.Response.WriteAsync(_html);
    }
}
```

We recommend adding an extension method to [Microsoft.AspNetCore.Http.IResultExtensions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresultextensions) to make these custom results more discoverable.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/html", () => Results.Extensions.Html(@$"<!doctype html>
<html>
    <head><title>miniHTML</title></head>
    <body>
        <h1>Hello World</h1>
        <p>The time on the server is {DateTime.Now:O}</p>
    </body>
</html>"));

app.Run();
```

### Typed results

The [IResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult) interface can represent values returned from Minimal APIs that don't utilize the implicit support for JSON serializing the returned object to the HTTP response. The static [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results) class is used to create varying  `IResult`  objects that represent different types of responses. For example, setting the response status code or redirecting to another URL.

The types implementing  `IResult`  are public, allowing for type assertions when testing. For example:

```csharp
[TestClass()]
public class WeatherApiTests
{
    [TestMethod()]
    public void MapWeatherApiTest()
    {
        var result = WeatherApi.GetAllWeathers();
        Assert.IsInstanceOfType(result, typeof(Ok<WeatherForecast[]>));
    }      
}
```

You can look at the return types of the corresponding methods on the static [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) class to find the correct public  `IResult`  type to cast to.

See [Create responses in Minimal API applications](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/responses?view=aspnetcore-10.0) for more examples.

## Filters

For more information, see [Filters in Minimal API apps](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/min-api-filters?view=aspnetcore-10.0).

## Authorization

Routes can be protected using authorization policies. These can be declared via the [ `[Authorize]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizeattribute) attribute or by using the [RequireAuthorization](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authorizationendpointconventionbuilderextensions.requireauthorization) method:

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using WebRPauth.Data;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddAuthorization(o => o.AddPolicy("AdminsOnly", 
                                  b => b.RequireClaim("admin", "true")));

var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();

builder.Services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores<ApplicationDbContext>();

var app = builder.Build();

app.UseAuthorization();

app.MapGet("/auth", [Authorize] () => "This endpoint requires authorization.");
app.MapGet("/", () => "This endpoint doesn't require authorization.");
app.MapGet("/Identity/Account/Login", () => "Sign in page at this endpoint.");

app.Run();
```

The preceding code can be written with [RequireAuthorization](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.authorizationendpointconventionbuilderextensions.requireauthorization):

```csharp
app.MapGet("/auth", () => "This endpoint requires authorization")
   .RequireAuthorization();
```

The following sample uses [policy-based authorization](https://learn.microsoft.com/en-us/aspnet/security/authorization/policies?view=aspnetcore-10.0):

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using WebRPauth.Data;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddAuthorization(o => o.AddPolicy("AdminsOnly", 
                                  b => b.RequireClaim("admin", "true")));

var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(connectionString));
builder.Services.AddDatabaseDeveloperPageExceptionFilter();

builder.Services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores<ApplicationDbContext>();

var app = builder.Build();

app.UseAuthorization();

app.MapGet("/admin", [Authorize("AdminsOnly")] () => 
                             "The /admin endpoint is for admins only.");

app.MapGet("/admin2", () => "The /admin2 endpoint is for admins only.")
   .RequireAuthorization("AdminsOnly");

app.MapGet("/", () => "This endpoint doesn't require authorization.");
app.MapGet("/Identity/Account/Login", () => "Sign in page at this endpoint.");

app.Run();
```

### Allow unauthenticated users to access an endpoint

The [ `[AllowAnonymous]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.allowanonymousattribute)
allows unauthenticated users to access endpoints:

```csharp
app.MapGet("/login", [AllowAnonymous] () => "This endpoint is for all roles.");


app.MapGet("/login2", () => "This endpoint also for all roles.")
   .AllowAnonymous();
```

## CORS

Routes can be [CORS](https://learn.microsoft.com/en-us/aspnet/security/cors?view=aspnetcore-10.0) enabled using [CORS policies](https://learn.microsoft.com/en-us/aspnet/security/cors?view=aspnetcore-10.0#cors-policy-options). CORS can be declared via the [ `[EnableCors]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.cors.enablecorsattribute) attribute or by using the
[RequireCors](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.corsendpointconventionbuilderextensions.requirecors) method. The following samples enable CORS:

```csharp
const string MyAllowSpecificOrigins = "_myAllowSpecificOrigins";

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCors(options =>
{
    options.AddPolicy(name: MyAllowSpecificOrigins,
                      builder =>
                      {
                          builder.WithOrigins("http://example.com",
                                              "http://www.contoso.com");
                      });
});

var app = builder.Build();
app.UseCors();

app.MapGet("/",() => "Hello CORS!");

app.Run();
```

```csharp
using Microsoft.AspNetCore.Cors;

const string MyAllowSpecificOrigins = "_myAllowSpecificOrigins";

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddCors(options =>
{
    options.AddPolicy(name: MyAllowSpecificOrigins,
                      builder =>
                      {
                          builder.WithOrigins("http://example.com",
                                              "http://www.contoso.com");
                      });
});

var app = builder.Build();
app.UseCors();

app.MapGet("/cors", [EnableCors(MyAllowSpecificOrigins)] () => 
                           "This endpoint allows cross origin requests!");
app.MapGet("/cors2", () => "This endpoint allows cross origin requests!")
                     .RequireCors(MyAllowSpecificOrigins);

app.Run();
```

For more information, see [Enable Cross-Origin Requests (CORS) in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/security/cors?view=aspnetcore-10.0)

## ValidateScopes and ValidateOnBuild

[ValidateScopes](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.serviceprovideroptions.validatescopes#microsoft-extensions-dependencyinjection-serviceprovideroptions-validatescopes) and [ValidateOnBuild](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.serviceprovideroptions.validateonbuild#microsoft-extensions-dependencyinjection-serviceprovideroptions-validateonbuild) are enabled by default in the [Development](https://learn.microsoft.com/en-us/aspnet/core/environments?view=aspnetcore-10.0) environment but disabled in other environments.

When  `ValidateOnBuild`  is  `true` , the DI container validates the service configuration at build time. If the service configuration is invalid, the build fails at app startup, rather than at runtime when the service is requested.

When  `ValidateScopes`  is  `true` , the DI container validates that a scoped service isn't resolved from the root scope. Resolving a scoped service from the root scope can result in a memory leak because the service is retained in memory longer than the scope of the request.

`ValidateScopes`  and  `ValidateOnBuild`  are false by default in non-Development modes for performance reasons.

The following code shows  `ValidateScopes`  is enabled by default in development mode but disabled in release mode:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddScoped<MyScopedService>();

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    Console.WriteLine("Development environment");
}
else
{
    Console.WriteLine("Release environment");
}

app.MapGet("/", context =>
{
    // Intentionally getting service provider from app, not from the request
    // This causes an exception from attempting to resolve a scoped service
    // outside of a scope.
    // Throws System.InvalidOperationException:
    // 'Cannot resolve scoped service 'MyScopedService' from root provider.'
    var service = app.Services.GetRequiredService<MyScopedService>();
    return context.Response.WriteAsync("Service resolved");
});

app.Run();

public class MyScopedService { }
```

The following code shows  `ValidateOnBuild`  is enabled by default in development mode but disabled in release mode:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddScoped<MyScopedService>();
builder.Services.AddScoped<AnotherService>();

// System.AggregateException: 'Some services are not able to be constructed (Error
// while validating the service descriptor 'ServiceType: AnotherService Lifetime:
// Scoped ImplementationType: AnotherService': Unable to resolve service for type
// 'BrokenService' while attempting to activate 'AnotherService'.)'
var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    Console.WriteLine("Development environment");
}
else
{
    Console.WriteLine("Release environment");
}

app.MapGet("/", context =>
{
    var service = context.RequestServices.GetRequiredService<MyScopedService>();
    return context.Response.WriteAsync("Service resolved correctly!");
});

app.Run();

public class MyScopedService { }

public class AnotherService
{
    public AnotherService(BrokenService brokenService) { }
}

public class BrokenService { }
```

The following code disables  `ValidateScopes`  and  `ValidateOnBuild`  in  `Development` :

```csharp
var builder = WebApplication.CreateBuilder(args);

if (builder.Environment.IsDevelopment())
{
    Console.WriteLine("Development environment");
    // Doesn't detect the validation problems because ValidateScopes is false.
    builder.Host.UseDefaultServiceProvider(options =>
    {
        options.ValidateScopes = false;
        options.ValidateOnBuild = false;
    });
}
```