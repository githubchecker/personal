# How to create responses in Minimal API apps






This article explains how to create responses for Minimal API endpoints in ASP.NET Core. Minimal APIs provide several ways to return data and HTTP status codes.

Minimal endpoints support the following types of return values:

1. `string`  - This includes  `Task<string>`  and  `ValueTask<string>` .
2. `T`  (Any other type) - This includes  `Task<T>`  and  `ValueTask<T>` .
3. `IResult`  based - This includes  `Task<IResult>`  and  `ValueTask<IResult>` .

> [!IMPORTANT]
> Starting with ASP.NET Core 10, known API endpoints no longer redirect to login pages when using cookie authentication. Instead, they return 401/403 status codes. For details, see [API endpoint authentication behavior in ASP.NET Core](https://learn.microsoft.com/en-us/security/authentication/api-endpoint-auth?view=aspnetcore-10.0).

## `string` return values

| Behavior | Content-Type |
| --- | --- |
| The framework writes the string directly to the response. | `text/plain` |

Consider the following route handler, which returns a  `Hello world`  text.

```csharp
app.MapGet("/hello", () => "Hello World");
```

The  `200`  status code is returned with  `text/plain`  Content-Type header and the following content.

```text
Hello World
```

## `T` (Any other type) return values

| Behavior | Content-Type |
| --- | --- |
| The framework JSON-serializes the response. | `application/json` |

Consider the following route handler, which returns an anonymous type containing a  `Message`  string property.

```csharp
app.MapGet("/hello", () => new { Message = "Hello World" });
```

The  `200`  status code is returned with  `application/json`  Content-Type header and the following content.

```json
{"message":"Hello World"}
```

## `IResult` return values

| Behavior | Content-Type |
| --- | --- |
| The framework calls [IResult.ExecuteAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult.executeasync). | Decided by the  `IResult`  implementation. |

The  `IResult`  interface defines a contract that represents the result of an HTTP endpoint. The static [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results) class and the static [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) are used to create various  `IResult`  objects that represent different types of responses.

### TypedResults vs Results

The [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results) and [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) static classes provide similar sets of results helpers. The  `TypedResults`  class is the *typed* equivalent of the  `Results`  class. However, the  `Results`  helpers' return type is [IResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult), while each  `TypedResults`  helper's return type is one of the  `IResult`  implementation types. The difference means that for  `Results`  helpers a conversion is needed when the concrete type is needed, for example, for unit testing. The implementation types are defined in the [Microsoft.AspNetCore.Http.HttpResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresults) namespace.

Returning  `TypedResults`  rather than  `Results`  has the following advantages:

* `TypedResults`  helpers return strongly typed objects, which can improve code readability, unit testing, and reduce the chance of runtime errors.
* The implementation type [automatically provides the response type metadata for OpenAPI](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/aspnetcore-openapi#describe-response-types) to describe the endpoint.

Consider the following endpoint, for which a  `200 OK`  status code with the expected JSON response is produced.

```csharp
app.MapGet("/hello", () => Results.Ok(new Message() { Text = "Hello World!" }))
    .Produces<Message>();
```

In order to document this endpoint correctly the extensions method  `Produces`  is called. However, it's not necessary to call  `Produces`  if  `TypedResults`  is used instead of  `Results` , as shown in the following code.  `TypedResults`  automatically provides the metadata for the endpoint.

```csharp
app.MapGet("/hello2", () => TypedResults.Ok(new Message() { Text = "Hello World!" }));
```

For more information about describing a response type, see [OpenAPI support in Minimal APIs](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/aspnetcore-openapi#describe-response-types-1).

For examples on testing result types, see the [Test documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/test-min-api#unit-test-iresult-implementation-types).

Because all methods on  `Results`  return  `IResult`  in their signature, the compiler automatically infers that as the request delegate return type when returning different results from a single endpoint.  `TypedResults`  requires the use of  `Results<T1, TN>`  from such delegates.

The following method compiles because both [ `Results.Ok` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.ok) and [ `Results.NotFound` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.notfound) are declared as returning  `IResult` , even though the actual concrete types of the objects returned are different:

```csharp
app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
    await db.Todos.FindAsync(id)
        is Todo todo
            ? Results.Ok(todo)
            : Results.NotFound());
```

The following method does not compile, because  `TypedResults.Ok`  and  `TypedResults.NotFound`  are declared as returning different types and the compiler won't attempt to infer the best matching type:

```csharp
app.MapGet("/todoitems/{id}", async (int id, TodoDb db) =>
     await db.Todos.FindAsync(id)
     is Todo todo
        ? TypedResults.Ok(todo)
        : TypedResults.NotFound());
```

To use  `TypedResults` , the return type must be fully declared; when the method is asynchronous, the declaration requires wrapping the return type in a  `Task<>` . Using  `TypedResults`  is more verbose, but that's the trade-off for having the type information be statically available and thus capable of self-describing to OpenAPI:

```csharp
app.MapGet("/todoitems/{id}", async Task<Results<Ok<Todo>, NotFound>> (int id, TodoDb db) =>
   await db.Todos.FindAsync(id)
    is Todo todo
       ? TypedResults.Ok(todo)
       : TypedResults.NotFound());
```

### Results<TResult1, TResultN>

Use [ `Results<TResult1, TResultN>` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresults.results-2) as the endpoint handler return type instead of  `IResult`  when:

* Multiple  `IResult`  implementation types are returned from the endpoint handler.
* The static  `TypedResult`  class is used to create the  `IResult`  objects.

This alternative is better than returning  `IResult`  because the generic union types automatically retain the endpoint metadata. And since the  `Results<TResult1, TResultN>`  union types implement implicit cast operators, the compiler can automatically convert the types specified in the generic arguments to an instance of the union type.

This has the added benefit of providing compile-time checking that a route handler actually only returns the results that it declares it does. Attempting to return a type that isn't declared as one of the generic arguments to  `Results<>`  results in a compilation error.

Consider the following endpoint, for which a  `400 BadRequest`  status code is returned when the  `orderId`  is greater than  `999` . Otherwise, it produces a  `200 OK`  with the expected content.

```csharp
app.MapGet("/orders/{orderId}", IResult (int orderId)
    => orderId > 999 ? TypedResults.BadRequest() : TypedResults.Ok(new Order(orderId)))
    .Produces(400)
    .Produces<Order>();
```

In order to document this endpoint correctly the extension method  `Produces`  is called. However, since the  `TypedResults`  helper automatically includes the metadata for the endpoint, you can return the  `Results<T1, Tn>`  union type instead, as shown in the following code.

```csharp
app.MapGet("/orders/{orderId}", Results<BadRequest, Ok<Order>> (int orderId)
    => orderId > 999 ? TypedResults.BadRequest() : TypedResults.Ok(new Order(orderId)));
```

### Built-in results

Common result helpers exist in the [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results) and [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) static classes. Returning  `TypedResults`  is preferred to returning  `Results` . For more information, see [TypedResults vs Results](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/responses#typedresults-vs-results).

The following sections demonstrate the usage of the common result helpers.

#### JSON

```csharp
app.MapGet("/hello", () => Results.Json(new { Message = "Hello World" }));
```

[WriteAsJsonAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponsejsonextensions.writeasjsonasync) is an alternative way to return JSON:

```csharp
app.MapGet("/", (HttpContext context) => context.Response.WriteAsJsonAsync
    (new { Message = "Hello World" }));
```

#### Custom Status Code

```csharp
app.MapGet("/405", () => Results.StatusCode(405));
```

#### Internal Server Error

```csharp
app.MapGet("/500", () => Results.InternalServerError("Something went wrong!"));
```

The preceding example returns a 500 status code.

#### Problem and ValidationProblem

```csharp
app.MapGet("/problem", () =>
{
    var extensions = new List<KeyValuePair<string, object?>> { new("test", "value") };
    return TypedResults.Problem("This is an error with extensions", 
                                                extensions: extensions);
});
```

#### Customize validation error responses using IProblemDetailsService

Customize error responses from Minimal API validation logic with an [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) implementation. Register this service in your application's service collection to enable more consistent and user-specific error responses. Support for Minimal API validation was introduced in ASP.NET Core in .NET 10.

To implement custom validation error responses:

* Implement [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) or use the default implementation
* Register the service in the DI container
* The validation system automatically uses the registered service to format validation error responses

The following example shows how to register and configure the [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) to customize validation error responses:

```csharp
using System.ComponentModel.DataAnnotations;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddProblemDetails(options =>
{
    options.CustomizeProblemDetails = context =>
    {
        if (context.ProblemDetails.Status == 400)
        {
            context.ProblemDetails.Title = "Validation error occurred";
            context.ProblemDetails.Extensions["support"] = "Contact support@example.com";
            context.ProblemDetails.Extensions["traceId"] = Guid.NewGuid().ToString();
        }
    };
});
```

When a validation error occurs, the [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) will be used to generate the error response, including any customizations added in the  `CustomizeProblemDetails`  callback.

For a complete app example, see the [Minimal API sample app](https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/fundamentals/minimal-apis/10.0-samples/MinApiIproblemDetailsService/Program.cs) demonstrating how to customize validation error responses using the [IProblemDetailsService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iproblemdetailsservice) in ASP.NET Core Minimal APIs.

#### Text

```csharp
app.MapGet("/text", () => Results.Text("This is some text"));
```

#### Stream

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

var proxyClient = new HttpClient();
app.MapGet("/pokemon", async () => 
{
    var stream = await proxyClient.GetStreamAsync("http://contoso/pokedex.json");
    // Proxy the response as JSON
    return Results.Stream(stream, "application/json");
});

app.Run();
```

[ `Results.Stream` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.stream?view=aspnetcore-7.0&preserve-view=true) overloads allow access to the underlying HTTP response stream without buffering. The following example uses [ImageSharp](https://sixlabors.com/products/imagesharp) to return a reduced size of the specified image:

```csharp
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Formats.Jpeg;
using SixLabors.ImageSharp.Processing;

var builder = WebApplication.CreateBuilder(args);

var app = builder.Build();

app.MapGet("/process-image/{strImage}", (string strImage, HttpContext http, CancellationToken token) =>
{
    http.Response.Headers.CacheControl = $"public,max-age={TimeSpan.FromHours(24).TotalSeconds}";
    return Results.Stream(stream => ResizeImageAsync(strImage, stream, token), "image/jpeg");
});

async Task ResizeImageAsync(string strImage, Stream stream, CancellationToken token)
{
    var strPath = $"wwwroot/img/{strImage}";
    using var image = await Image.LoadAsync(strPath, token);
    int width = image.Width / 2;
    int height = image.Height / 2;
    image.Mutate(x =>x.Resize(width, height));
    await image.SaveAsync(stream, JpegFormat.Instance, cancellationToken: token);
}
```

The following example streams an image from [Azure Blob storage](https://learn.microsoft.com/en-us/azure/storage/blobs/storage-blobs-introduction):

```csharp
app.MapGet("/stream-image/{containerName}/{blobName}", 
    async (string blobName, string containerName, CancellationToken token) =>
{
    var conStr = builder.Configuration["blogConStr"];
    BlobContainerClient blobContainerClient = new BlobContainerClient(conStr, containerName);
    BlobClient blobClient = blobContainerClient.GetBlobClient(blobName);
    return Results.Stream(await blobClient.OpenReadAsync(cancellationToken: token), "image/jpeg");
});
```

The following example streams a video from an Azure Blob:

```csharp
// GET /stream-video/videos/earth.mp4
app.MapGet("/stream-video/{containerName}/{blobName}",
     async (HttpContext http, CancellationToken token, string blobName, string containerName) =>
{
    var conStr = builder.Configuration["blogConStr"];
    BlobContainerClient blobContainerClient = new BlobContainerClient(conStr, containerName);
    BlobClient blobClient = blobContainerClient.GetBlobClient(blobName);
    
    var properties = await blobClient.GetPropertiesAsync(cancellationToken: token);
    
    DateTimeOffset lastModified = properties.Value.LastModified;
    long length = properties.Value.ContentLength;
    
    long etagHash = lastModified.ToFileTime() ^ length;
    var entityTag = new EntityTagHeaderValue('\"' + Convert.ToString(etagHash, 16) + '\"');
    
    http.Response.Headers.CacheControl = $"public,max-age={TimeSpan.FromHours(24).TotalSeconds}";

    return Results.Stream(await blobClient.OpenReadAsync(cancellationToken: token), 
        contentType: "video/mp4",
        lastModified: lastModified,
        entityTag: entityTag,
        enableRangeProcessing: true);
});
```

#### Server-Sent Events (SSE)

The [TypedResults.ServerSentEvents](https://source.dot.net/#Microsoft.AspNetCore.Http.Results/TypedResults.cs,051e6796e1492f84) API supports returning a [ServerSentEvents](https://learn.microsoft.com/en-us/dotnet/api/system.net.serversentevents) result.

[Server-Sent Events](https://developer.mozilla.org/docs/Web/API/Server-sent_events) is a server push technology that allows a server to send a stream of event messages to a client over a single HTTP connection. In .NET, the event messages are represented as [ `SseItem<T>` ](https://learn.microsoft.com/en-us/dotnet/api/system.net.serversentevents.sseitem-1) objects, which may contain an event type, an ID, and a data payload of type  `T` .

The [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) class has a static method called [ServerSentEvents](https://source.dot.net/#Microsoft.AspNetCore.Http.Results/TypedResults.cs,ceb980606eb9e295) that can be used to return a  `ServerSentEvents`  result. The first parameter to this method is an  `IAsyncEnumerable<SseItem<T>>`  that represents the stream of event messages to be sent to the client.

The following example illustrates how to use the  `TypedResults.ServerSentEvents`  API to return a stream of heart rate events as JSON objects to the client:

```csharp
app.MapGet("sse-item", (CancellationToken cancellationToken) =>
{
    async IAsyncEnumerable<SseItem<int>> GetHeartRate(
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            var heartRate = Random.Shared.Next(60, 100);
            yield return new SseItem<int>(heartRate, eventType: "heartRate")
            {
                ReconnectionInterval = TimeSpan.FromMinutes(1)
            };
            await Task.Delay(2000, cancellationToken);
        }
    }

    return TypedResults.ServerSentEvents(GetHeartRate(cancellationToken));
});
```

For more information, see the [Minimal API sample app](https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/fundamentals/minimal-apis/10.0-samples/MinimalServerSentEvents/Program.cs) using the  `TypedResults.ServerSentEvents`  API to return a stream of heart rate events as string,  `ServerSentEvents` , and JSON objects to the client.

#### Redirect

```csharp
app.MapGet("/old-path", () => Results.Redirect("/new-path"));
```

#### File

```csharp
app.MapGet("/download", () => Results.File("myfile.text"));
```

### HttpResult interfaces

The following interfaces in the [Microsoft.AspNetCore.Http](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http) namespace provide a way to detect the  `IResult`  type at runtime, which is a common pattern in filter implementations:

* [IContentTypeHttpResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.icontenttypehttpresult)
* [IFileHttpResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.ifilehttpresult)
* [INestedHttpResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.inestedhttpresult)
* [IStatusCodeHttpResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.istatuscodehttpresult)
* [IValueHttpResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.ivaluehttpresult)
* [IValueHttpResult<TValue>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.ivaluehttpresult-1)

Here's an example of a filter that uses one of these interfaces:

```csharp
app.MapGet("/weatherforecast", (int days) =>
{
    if (days <= 0)
    {
        return Results.BadRequest();
    }

    var forecast = Enumerable.Range(1, days).Select(index =>
       new WeatherForecast(DateTime.Now.AddDays(index), Random.Shared.Next(-20, 55), "Cool"))
        .ToArray();
    return Results.Ok(forecast);
}).
AddEndpointFilter(async (context, next) =>
{
    var result = await next(context);

    return result switch
    {
        IValueHttpResult<WeatherForecast[]> weatherForecastResult => new WeatherHttpResult(weatherForecastResult.Value),
        _ => result
    };
});
```

For more information, see [Filters in Minimal API apps](https://learn.microsoft.com/en-us/aspnet/core/min-api-filters?view=aspnetcore-10.0) and [IResult implementation types](https://learn.microsoft.com/en-us/aspnet/core/test-min-api?view=aspnetcore-10.0#iresult-implementation-types).

## Modifying Headers

Use the  `HttpResponse`  object to modify response headers:

```csharp
app.MapGet("/", (HttpContext context) => {
    // Set a custom header
    context.Response.Headers["X-Custom-Header"] = "CustomValue";

    // Set a known header
    context.Response.Headers.CacheControl = $"public,max-age=3600";

    return "Hello World";
});
```

## Customizing responses

Applications can control responses by implementing a custom [IResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult) type. The following code is an example of an HTML result type:

```csharp
using System.Net.Mime;
using System.Text;
static class ResultsExtensions
{
    public static IResult Html(this IResultExtensions resultExtensions, string html)
    {
        ArgumentNullException.ThrowIfNull(resultExtensions);

        return new HtmlResult(html);
    }
}

class HtmlResult : IResult
{
    private readonly string _html;

    public HtmlResult(string html)
    {
        _html = html;
    }

    public Task ExecuteAsync(HttpContext httpContext)
    {
        httpContext.Response.ContentType = MediaTypeNames.Text.Html;
        httpContext.Response.ContentLength = Encoding.UTF8.GetByteCount(_html);
        return httpContext.Response.WriteAsync(_html);
    }
}
```

We recommend adding an extension method to [Microsoft.AspNetCore.Http.IResultExtensions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresultextensions) to make these custom results more discoverable.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/html", () => Results.Extensions.Html(@$"<!doctype html>
<html>
    <head><title>miniHTML</title></head>
    <body>
        <h1>Hello World</h1>
        <p>The time on the server is {DateTime.Now:O}</p>
    </body>
</html>"));

app.Run();
```

Also, a custom  `IResult`  type can provide its own annotation by implementing the [IEndpointMetadataProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.metadata.iendpointmetadataprovider) interface. For example, the following code adds an annotation to the preceding  `HtmlResult`  type that describes the response produced by the endpoint.

```csharp
class HtmlResult : IResult, IEndpointMetadataProvider
{
    private readonly string _html;

    public HtmlResult(string html)
    {
        _html = html;
    }

    public Task ExecuteAsync(HttpContext httpContext)
    {
        httpContext.Response.ContentType = MediaTypeNames.Text.Html;
        httpContext.Response.ContentLength = Encoding.UTF8.GetByteCount(_html);
        return httpContext.Response.WriteAsync(_html);
    }

    public static void PopulateMetadata(MethodInfo method, EndpointBuilder builder)
    {
        builder.Metadata.Add(new ProducesHtmlMetadata());
    }
}
```

The  `ProducesHtmlMetadata`  is an implementation of [IProducesResponseTypeMetadata](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.metadata.iproducesresponsetypemetadata) that defines the produced response content type  `text/html`  and the status code  `200 OK` .

```csharp
internal sealed class ProducesHtmlMetadata : IProducesResponseTypeMetadata
{
    public Type? Type => null;

    public int StatusCode => 200;

    public IEnumerable<string> ContentTypes { get; } = new[] { MediaTypeNames.Text.Html };
}
```

An alternative approach is using the [Microsoft.AspNetCore.Mvc.ProducesAttribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.producesattribute) to describe the produced response. The following code changes the  `PopulateMetadata`  method to use  `ProducesAttribute` .

```csharp
public static void PopulateMetadata(MethodInfo method, EndpointBuilder builder)
{
    builder.Metadata.Add(new ProducesAttribute(MediaTypeNames.Text.Html));
}
```

## Configure JSON serialization options

By default, Minimal API apps use [ `Web defaults` ](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-configure-options#web-defaults-for-jsonserializeroptions) options during JSON serialization and deserialization.

### Configure JSON serialization options globally

Options can be configured globally for an app by invoking [ConfigureHttpJsonOptions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httpjsonserviceextensions.configurehttpjsonoptions). The following example includes public fields and formats JSON output.

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.ConfigureHttpJsonOptions(options => {
    options.SerializerOptions.WriteIndented = true;
    options.SerializerOptions.IncludeFields = true;
});

var app = builder.Build();

app.MapPost("/", (Todo todo) => {
    if (todo is not null) {
        todo.Name = todo.NameField;
    }
    return todo;
});

app.Run();

class Todo {
    public string? Name { get; set; }
    public string? NameField;
    public bool IsComplete { get; set; }
}
// If the request body contains the following JSON:
//
// {"nameField":"Walk dog", "isComplete":false}
//
// The endpoint returns the following JSON:
//
// {
//    "name":"Walk dog",
//    "nameField":"Walk dog",
//    "isComplete":false
// }
```

Since fields are included, the preceding code reads  `NameField`  and includes it in the output JSON.

### Configure JSON serialization options for an endpoint

To configure serialization options for an endpoint, invoke [Results.Json](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.json) and pass to it a [JsonSerializerOptions](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions) object, as shown in the following example:

```csharp
using System.Text.Json;

var app = WebApplication.Create();

var options = new JsonSerializerOptions(JsonSerializerDefaults.Web)
    { WriteIndented = true };

app.MapGet("/", () => 
    Results.Json(new Todo { Name = "Walk dog", IsComplete = false }, options));

app.Run();

class Todo
{
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}
// The endpoint returns the following JSON:
//
// {
//   "name":"Walk dog",
//   "isComplete":false
// }
```

As an alternative, use an overload of [WriteAsJsonAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponsejsonextensions.writeasjsonasync) that accepts a [JsonSerializerOptions](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions) object. The following example uses this overload to format the output JSON:

```csharp
using System.Text.Json;

var app = WebApplication.Create();

var options = new JsonSerializerOptions(JsonSerializerDefaults.Web) {
    WriteIndented = true };

app.MapGet("/", (HttpContext context) =>
    context.Response.WriteAsJsonAsync<Todo>(
        new Todo { Name = "Walk dog", IsComplete = false }, options));

app.Run();

class Todo
{
    public string? Name { get; set; }
    public bool IsComplete { get; set; }
}
// The endpoint returns the following JSON:
//
// {
//   "name":"Walk dog",
//   "isComplete":false
// }
```

## Additional Resources

* [Authentication and authorization in Minimal APIs](https://learn.microsoft.com/en-us/aspnet/core/security?view=aspnetcore-10.0)
