# Controller action return types in ASP.NET Core web API






[View or download sample code](https://github.com/dotnet/AspNetCore.Docs.Samples/tree/main/mvc/action-return-types/) ([how to download](https://learn.microsoft.com/en-us/aspnet/fundamentals/?view=aspnetcore-10.0#how-to-download-a-sample))

ASP.NET Core provides the following options for web API controller action return types:

* [Specific type](https://learn.microsoft.com/en-us/aspnet/core/#specific-type)
* [IActionResult](https://learn.microsoft.com/en-us/aspnet/core/#iactionresult-type)
* [ActionResult<T>](https://learn.microsoft.com/en-us/aspnet/core/#actionresultt-type)
* [HttpResults](https://learn.microsoft.com/en-us/aspnet/core/#httpresults-type)

This article explains when it's most appropriate to use each return type.

## Specific type

The most basic action returns a primitive or complex data type, for example,  `string`  or a custom object. Consider the following action, which returns a collection of custom  `Product`  objects:

```csharp
[HttpGet]
public Task<List<Product>> Get() =>
    _productContext.Products.OrderBy(p => p.Name).ToListAsync();
```

Without known conditions to safeguard against, returning a specific type could suffice. The preceding action accepts no parameters, so parameter constraints validation isn't needed.

When multiple return types are possible, it's common to mix an [ActionResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult) return type with the primitive or complex return type. Either [IActionResult](https://learn.microsoft.com/en-us/aspnet/core/#iactionresult-type) or [ActionResult<T>](https://learn.microsoft.com/en-us/aspnet/core/#actionresultt-type) are necessary to accommodate this type of action. Several samples of multiple return types are provided in this article.

### Return IEnumerable<T> or IAsyncEnumerable<T>

See [Return  `IEnumerable<T>`  or  `IAsyncEnumerable<T>` ](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/best-practices#return-ienumerablet-or-iasyncenumerablet) for performance considerations.

ASP.NET Core buffers the result of actions that return [IEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1) before writing them to the response. Consider declaring the action signature's return type as [IAsyncEnumerable<T>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1) to guarantee asynchronous iteration. Ultimately, the iteration mode is based on the underlying concrete type being returned and the selected formatter affects how the result is processed:

* When using  `System.Text.Json`  formatter, MVC relies on the support that  `System.Text.Json`  added to **stream** the result.
* When using  `Newtonsoft.Json`  or with  `XML-based`  formatters the result is buffered.

Consider the following action, which returns sale-priced product records as  `IEnumerable<Product>` :

```csharp
[HttpGet("syncsale")]
public IEnumerable<Product> GetOnSaleProducts()
{
    var products = _productContext.Products.OrderBy(p => p.Name).ToList();

    foreach (var product in products)
    {
        if (product.IsOnSale)
        {
            yield return product;
        }
    }
}
```

The  `IAsyncEnumerable<Product>`  equivalent of the preceding action is:

```csharp
[HttpGet("asyncsale")]
public async IAsyncEnumerable<Product> GetOnSaleProductsAsync()
{
    var products = _productContext.Products.OrderBy(p => p.Name).AsAsyncEnumerable();

    await foreach (var product in products)
    {
        if (product.IsOnSale)
        {
            yield return product;
        }
    }
}
```

## IActionResult type

The [IActionResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iactionresult) return type is appropriate when multiple  `ActionResult`  return types are possible in an action. The  `ActionResult`  types represent various HTTP status codes. Any non-abstract class deriving from  `ActionResult`  qualifies as a valid return type. Some common return types in this category are [BadRequestResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.badrequestresult) (400), [NotFoundResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.notfoundresult) (404), and [OkObjectResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.okobjectresult) (200). Alternatively, convenience methods in the [ControllerBase](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase) class can be used to return  `ActionResult`  types from an action. For example,  `return BadRequest();`  is a shorthand form of  `return new BadRequestResult();` .

Because there are multiple return types and paths in this type of action, liberal use of the [ `[ProducesResponseType]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.producesresponsetypeattribute) attribute is necessary. This attribute produces more descriptive response details for web API help pages generated by tools like [Swagger](https://learn.microsoft.com/en-us/aspnet/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-10.0).  `[ProducesResponseType]`  indicates the known types and HTTP status codes to be returned by the action.

### Synchronous action

Consider the following synchronous action in which there are two possible return types:

```csharp
[HttpGet("{id}")]
[ProducesResponseType<Product>(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public IActionResult GetById_IActionResult(int id)
{
    var product = _productContext.Products.Find(id);
    return product == null ? NotFound() : Ok(product);
}
```

In the preceding action:

* A 404 status code is returned when the product represented by  `id`  doesn't exist in the underlying data store. The [NotFound](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.notfound) convenience method is invoked as shorthand for  `return new NotFoundResult();` .
* A 200 status code is returned with the  `Product`  object when the product does exist. The [Ok](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.ok) convenience method is invoked as shorthand for  `return new OkObjectResult(product);` .

### Asynchronous action

Consider the following asynchronous action in which there are two possible return types:

```csharp
[HttpPost()]
[Consumes(MediaTypeNames.Application.Json)]
[ProducesResponseType(StatusCodes.Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task<IActionResult> CreateAsync_IActionResult(Product product)
{
    if (product.Description.Contains("XYZ Widget"))
    {
        return BadRequest();
    }

    _productContext.Products.Add(product);
    await _productContext.SaveChangesAsync();

    return CreatedAtAction(nameof(GetById_IActionResult), new { id = product.Id }, product);
}
```

In the preceding action:

* A 400 status code is returned when the product description contains "XYZ Widget". The [BadRequest](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.badrequest) convenience method is invoked as shorthand for  `return new BadRequestResult();` .
* A 201 status code is generated by the [CreatedAtAction](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.createdataction) convenience method when a product is created. The following code is an alternative to calling  `CreatedAtAction` :

  ```csharp
  return new CreatedAtActionResult(nameof(GetByIdAsync), 
                                  "Products", 
                                  new { id = product.Id }, 
                                  product);
  ```

  In the preceding code path, the  `Product`  object is provided in the response body. A  `Location`  response header containing the newly created product's URL is provided.

For example, the following model indicates that requests must include the  `Name`  and  `Description`  properties. Failure to provide  `Name`  and  `Description`  in the request causes model validation to fail.

```csharp
public class Product
{
    public int Id { get; set; }

    [Required]
    public string Name { get; set; } = string.Empty;

    [Required]
    public string Description { get; set; } = string.Empty;

    public bool IsOnSale { get; set; }
}
```

If the [ `[ApiController]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.apicontrollerattribute) attribute is applied, model validation errors result in a 400 status code. For more information, see [Automatic HTTP 400 responses](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-10.0#automatic-http-400-responses).

## ActionResult vs IActionResult

The following section compares  `ActionResult`  to  `IActionResult`

### ActionResult<T> type

ASP.NET Core includes the [ActionResult<T>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult-1) return type for web API controller actions. It enables returning a type deriving from [ActionResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult) or return a [specific type](https://learn.microsoft.com/en-us/aspnet/core/#specific-type).  `ActionResult<T>`  offers the following benefits over the [IActionResult type](https://learn.microsoft.com/en-us/aspnet/core/#iactionresult-type):

* The [ `[ProducesResponseType]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.producesresponsetypeattribute) attribute's  `Type`  property can be excluded. For example,  `[ProducesResponseType(200, Type = typeof(Product))]`  is simplified to  `[ProducesResponseType(200)]` . The action's expected return type is inferred from the  `T`  in  `ActionResult<T>` .
* [Implicit cast operators](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/implicit) support the conversion of both  `T`  and  `ActionResult`  to  `ActionResult<T>` .  `T`  converts to [ObjectResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.objectresult), which means  `return new ObjectResult(T);`  is simplified to  `return T;` .

C# doesn't support implicit cast operators on interfaces. Consequently, conversion of the interface to a concrete type is necessary to use  `ActionResult<T>` . For example, use of  `IEnumerable`  in the following example doesn't work:

```csharp
[HttpGet]
public ActionResult<IEnumerable<Product>> Get() =>
    _repository.GetProducts();
```

One option to fix the preceding code is to return  `_repository.GetProducts().ToList();` .

Most actions have a specific return type. Unexpected conditions can occur during action execution, in which case the specific type isn't returned. For example, an action's input parameter may fail model validation. In such a case, it's common to return the appropriate  `ActionResult`  type instead of the specific type.

### Synchronous action

Consider a synchronous action in which there are two possible return types:

```csharp
[HttpGet("{id}")]
[ProducesResponseType(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public ActionResult<Product> GetById_ActionResultOfT(int id)
{
    var product = _productContext.Products.Find(id);
    return product == null ? NotFound() : product;
}
```

In the preceding action:

* A 404 status code is returned when the product doesn't exist in the database.
* A 200 status code is returned with the corresponding  `Product`  object when the product does exist.

### Asynchronous action

Consider an asynchronous action in which there are two possible return types:

```csharp
[HttpPost()]
[Consumes(MediaTypeNames.Application.Json)]
[ProducesResponseType(StatusCodes.Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task<ActionResult<Product>> CreateAsync_ActionResultOfT(Product product)
{
    if (product.Description.Contains("XYZ Widget"))
    {
        return BadRequest();
    }

    _productContext.Products.Add(product);
    await _productContext.SaveChangesAsync();

    return CreatedAtAction(nameof(GetById_ActionResultOfT), new { id = product.Id }, product);
}
```

In the preceding action:

* A 400 status code ([BadRequest](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.badrequest)) is returned by the ASP.NET Core runtime when:
  + The [ `[ApiController]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.apicontrollerattribute) attribute has been applied and model validation fails.
  + The product description contains "XYZ Widget".
* A 201 status code is generated by the [CreatedAtAction](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.createdataction) method when a product is created. In this code path, the  `Product`  object is provided in the response body. A  `Location`  response header containing the newly created product's URL is provided.

## HttpResults type

In addition to the MVC-specific built-in result types ([IActionResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.iactionresult) and [ActionResult<T>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.actionresult-1)), ASP.NET Core includes the [HttpResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresults) types that can be used in both [Minimal APIs](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis) and Web API.

Different than the MVC-specific result types, the  `HttpResults` :

* Are a results implementation that is processed by a call to [IResult.ExecuteAsync](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult.executeasync).
* Does ***not*** leverage the configured [Formatters](https://learn.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting#format-specific-action-results). Not leveraging the configured formatters means:

  + Some features like  `Content negotiation`  aren't available.
  + The produced  `Content-Type`  is decided by the  `HttpResults`  implementation.

The  `HttpResults`  can be useful when sharing code between Minimal APIs and Web API.

### IResult type

The [Microsoft.AspNetCore.Http.HttpResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresults) namespace contains classes that implement the [IResult](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresult) interface. The  `IResult`  interface defines a contract that represents the result of an HTTP endpoint. The static [Results](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results) class is used to create varying  `IResult`  objects that represent different types of responses.

The [Built-in results](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis#built-in-results) table shows the common result helpers.

Consider the following code:

```csharp
[HttpGet("{id}")]
[ProducesResponseType<Product>(StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public IResult GetById(int id)
{
    var product = _productContext.Products.Find(id);
    return product == null ? Results.NotFound() : Results.Ok(product);
}
```

In the preceding action:

* A 404 status code is returned when the product doesn't exist in the database.
* A 200 status code is returned with the corresponding  `Product`  object when the product does exist, generated by the [Results.Ok<T>()](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.ok).

Consider the following code:

```csharp
[HttpPost]
[Consumes(MediaTypeNames.Application.Json)]
[ProducesResponseType<Product>(StatusCodes.Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task<IResult> CreateAsync(Product product)
{
    if (product.Description.Contains("XYZ Widget"))
    {
        return Results.BadRequest();
    }

    _productContext.Products.Add(product);
    await _productContext.SaveChangesAsync();

    var location = Url.Action(nameof(CreateAsync), new { id = product.Id }) ?? $"/{product.Id}";
    return Results.Created(location, product);
}
```

In the preceding action:

* A 400 status code is returned when:
  + The [ `[ApiController]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.apicontrollerattribute) attribute has been applied and model validation fails.
  + The product description contains "XYZ Widget".
* A 201 status code is generated by the [ `Results.Created` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.results.created) method when a product is created. In this code path, the  `Product`  object is provided in the response body. A  `Location`  response header containing the newly created product's URL is provided.

### Results<TResult1, TResultN> type

The static [TypedResults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults) class returns the concrete  `IResult`  implementation that allows using  `IResult`  as return type. The usage of the concrete  `IResult`  implementation offers the following benefit over the [IResult type](https://learn.microsoft.com/en-us/aspnet/core/#iresult-type):

* All the [ `[ProducesResponseType]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.producesresponsetypeattribute) attributes can be excluded, since the  `HttpResult`  implementation contributes automatically to the endpoint metadata.

When multiple  `IResult`  return types are needed, returning [ `Results<TResult1, TResultN>` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresults.results-2) is preferred over returning  `IResult` . Returning  `Results<TResult1, TResultN>`  is preferred because generic union types automatically retain the endpoint metadata.

The  `Results<TResult1, TResultN>`  union types implement implicit cast operators so that the compiler can automatically convert the types specified in the generic arguments to an instance of the union type. This has the added benefit of providing compile-time checking that a route handler actually only returns the results that it declares it does. Attempting to return a type that isnât declared as one of the generic arguments to  `Results<>`  results in a compilation error.

Consider the following code:

```csharp
[HttpGet("{id}")]
public Results<NotFound, Ok<Product>> GetById(int id)
{
    var product = _productContext.Products.Find(id);
    return product == null ? TypedResults.NotFound() : TypedResults.Ok(product);
}
```

In the preceding action:

* A 404 status code is returned when the product doesn't exist in the database.
* A 200 status code is returned with the corresponding  `Product`  object when the product does exist, generated by the [TypedResults.Ok<T>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults.ok#microsoft-aspnetcore-http-typedresults-ok).

```csharp
[HttpPost]
public async Task<Results<BadRequest, Created<Product>>> CreateAsync(Product product)
{
    if (product.Description.Contains("XYZ Widget"))
    {
        return TypedResults.BadRequest();
    }

    _productContext.Products.Add(product);
    await _productContext.SaveChangesAsync();

    var location = Url.Action(nameof(CreateAsync), new { id = product.Id }) ?? $"/{product.Id}";
    return TypedResults.Created(location, product);
}
```

In the preceding action:

* A 400 status code is returned when:
  + The [ `[ApiController]` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.apicontrollerattribute) attribute was applied and model validation fails.
  + The product description contains "XYZ Widget".
* A 201 status code is generated by the [ `TypedResults.Created` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.typedresults.created) method when a product is created. In this code path, the  `Product`  object is provided in the response body. A  `Location`  response header containing the newly created product's URL is provided.