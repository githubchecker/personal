# JSON Patch support in ASP.NET Core web API




This article explains how to handle JSON Patch requests in an ASP.NET Core web API.

JSON Patch support in ASP.NET Core web API is based on [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) serialization, and requires the [ `Microsoft.AspNetCore.JsonPatch.SystemTextJson` ](https://www.nuget.org/packages/Microsoft.AspNetCore.JsonPatch.SystemTextJson) NuGet package.

## What is the JSON Patch standard?

The JSON Patch standard:

* Is a standard format for describing changes to apply to a JSON document.
* Is defined in [RFC 6902](https://datatracker.ietf.org/doc/html/rfc6902) and is widely used in RESTful APIs to perform partial updates to JSON resources.
* Describes a sequence of operations that modify a JSON document such as:

  + `add`
  + `remove`
  + `replace`
  + `move`
  + `copy`
  + `test`

In web apps, JSON Patch is commonly used in a PATCH operation to perform partial updates of a resource. Rather than sending the entire resource for an update, clients can send a JSON Patch document containing only the changes. Patching reduces payload size and improves efficiency.

For an overview of the JSON Patch standard, see [jsonpatch.com](https://jsonpatch.com/).

## JSON Patch support in ASP.NET Core web API

JSON Patch support in ASP.NET Core web API is based on [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) serialization, starting with .NET 10, implementing [Microsoft.AspNetCore.JsonPatch](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch) based on [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) serialization. This feature:

* Requires the [ `Microsoft.AspNetCore.JsonPatch.SystemTextJson` ](https://www.nuget.org/packages/Microsoft.AspNetCore.JsonPatch.SystemTextJson) NuGet package.
* Aligns with modern .NET practices by leveraging the [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) library, which is optimized for .NET.
* Provides improved performance and reduced memory usage compared to the legacy  `Newtonsoft.Json` -based implementation. For more information on the legacy  `Newtonsoft.Json` -based implementation, see the [.NET 9 version of this article](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-9.0&preserve-view=true).

> [!NOTE]
> The implementation of [Microsoft.AspNetCore.JsonPatch](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch) based on [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) serialization isn't a drop-in replacement for the legacy  `Newtonsoft.Json` -based implementation. It doesn't support dynamic types, for example [ExpandoObject](https://learn.microsoft.com/en-us/dotnet/api/system.dynamic.expandoobject).

> [!IMPORTANT]
> The JSON Patch standard has ***inherent security risks***. Since these risks are inherent to the JSON Patch standard, the ASP.NET Core implementation ***doesn't attempt to mitigate inherent security risks***. It's the responsibility of the developer to ensure that the JSON Patch document is safe to apply to the target object. For more information, see the [Mitigating Security Risks](https://learn.microsoft.com/en-us/aspnet/core/#mitigating-security-risks) section.

## Enable JSON Patch support with [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json)

To enable JSON Patch support with [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json), install the [ `Microsoft.AspNetCore.JsonPatch.SystemTextJson` ](https://www.nuget.org/packages/Microsoft.AspNetCore.JsonPatch.SystemTextJson) NuGet package.

```dotnetcli
dotnet add package Microsoft.AspNetCore.JsonPatch.SystemTextJson --prerelease
```

This package provides a [JsonPatchDocument<TModel>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument-1) class to represent a JSON Patch document for objects of type  `T`  and custom logic for serializing and deserializing JSON Patch documents using [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json). The key method of the [JsonPatchDocument<TModel>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument-1) class is [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)), which applies the patch operations to a target object of type  `T` .

## Action method code applying JSON Patch

In an API controller, an action method for JSON Patch:

* Is annotated with the [HttpPatchAttribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.httppatchattribute) attribute.
* Accepts a [JsonPatchDocument<TModel>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument-1), typically with [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.frombodyattribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.frombodyattribute)[FromBodyAttribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.frombodyattribute).
* Calls [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)) on the patch document to apply the changes.

### Example Controller Action method:

```csharp
[HttpPatch("{id}", Name = "UpdateCustomer")]
public IActionResult Update(AppDb db, string id, [FromBody] JsonPatchDocument<Customer> patchDoc)
{
    // Retrieve the customer by ID
    var customer = db.Customers.FirstOrDefault(c => c.Id == id);

    // Return 404 Not Found if customer doesn't exist
    if (customer == null)
    {
        return NotFound();
    }

    patchDoc.ApplyTo(customer, jsonPatchError =>
        {
            var key = jsonPatchError.AffectedObject.GetType().Name;
            ModelState.AddModelError(key, jsonPatchError.ErrorMessage);
        }
    );

    if (!ModelState.IsValid)
    {
        return BadRequest(ModelState);
    }

    return new ObjectResult(customer);
}
```

This code from the sample app works with the following  `Customer`  and  `Order`  models:

```csharp
namespace App.Models;

public class Customer
{
    public string Id { get; set; }
    public string? Name { get; set; }
    public string? Email { get; set; }
    public string? PhoneNumber { get; set; }
    public string? Address { get; set; }
    public List<Order>? Orders { get; set; }

    public Customer()
    {
        Id = Guid.NewGuid().ToString();
    }
}
```

```csharp
namespace App.Models;

public class Order
{
    public string Id { get; set; }
    public DateTime? OrderDate { get; set; }
    public DateTime? ShipDate { get; set; }
    public decimal TotalAmount { get; set; }

    public Order()
    {
        Id = Guid.NewGuid().ToString();
    }
}
```

The sample action method's key steps:

* **Retrieve the Customer**:
  + The method retrieves a  `Customer`  object from the database  `AppDb`  using the provided id.
  + If no  `Customer`  object is found, it returns a  `404 Not Found`  response.
* **Apply JSON Patch**:
  + The [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)) method applies the JSON Patch operations from the patchDoc to the retrieved  `Customer`  object.
  + If errors occur during the patch application, such as invalid operations or conflicts, they are captured by an error handling delegate. This delegate adds error messages to the  `ModelState`  using the type name of the affected object and the error message.
* **Validate ModelState**:
  + After applying the patch, the method checks the  `ModelState`  for errors.
  + If the  `ModelState`  is invalid, such as due to patch errors, it returns a  `400 Bad Request`  response with the validation errors.
* **Return the Updated Customer**:
  + If the patch is successfully applied and the  `ModelState`  is valid, the method returns the updated  `Customer`  object in the response.

### Example error response:

The following example shows the body of a  `400 Bad Request`  response for a JSON Patch operation when the specified path is invalid:

```json
{
  "Customer": [
    "The target location specified by path segment 'foobar' was not found."
  ]
}
```

## Apply a JSON Patch document to an object

The following examples demonstrate how to use the [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)) method to apply a JSON Patch document to an object.

### Example: Apply a [JsonPatchDocument<TModel>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument-1) to an object

The following example demonstrates:

* The  `add` ,  `replace` , and  `remove`  operations.
* Operations on nested properties.
* Adding a new item to an array.
* Using a JSON String Enum Converter in a JSON patch document.

```csharp
// Original object
var person = new Person {
    FirstName = "John",
    LastName = "Doe",
    Email = "johndoe@gmail.com",
    PhoneNumbers = [new() {Number = "123-456-7890", Type = PhoneNumberType.Mobile}],
    Address = new Address
    {
        Street = "123 Main St",
        City = "Anytown",
        State = "TX"
    }
};

// Raw JSON patch document
string jsonPatch = """
[
    { "op": "replace", "path": "/FirstName", "value": "Jane" },
    { "op": "remove", "path": "/Email"},
    { "op": "add", "path": "/Address/ZipCode", "value": "90210" },
    { "op": "add", "path": "/PhoneNumbers/-", "value": { "Number": "987-654-3210",
                                                                "Type": "Work" } }
]
""";

// Deserialize the JSON patch document
var patchDoc = JsonSerializer.Deserialize<JsonPatchDocument<Person>>(jsonPatch);

// Apply the JSON patch document
patchDoc!.ApplyTo(person);

// Output updated object
Console.WriteLine(JsonSerializer.Serialize(person, serializerOptions));
```

The previous example results in the following output of the updated object:

```output
{
    "firstName": "Jane",
    "lastName": "Doe",
    "address": {
        "street": "123 Main St",
        "city": "Anytown",
        "state": "TX",
        "zipCode": "90210"
    },
    "phoneNumbers": [
        {
            "number": "123-456-7890",
            "type": "Mobile"
        },
        {
            "number": "987-654-3210",
            "type": "Work"
        }
    ]
}
```

The [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)) method generally follows the conventions and options of [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) for processing the [JsonPatchDocument<TModel>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument-1), including the behavior controlled by the following options:

* [JsonNumberHandling](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonnumberhandling): Whether numeric properties are read from strings.
* [PropertyNameCaseInsensitive](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.propertynamecaseinsensitive#system-text-json-jsonserializeroptions-propertynamecaseinsensitive): Whether property names are case-sensitive.

Key differences between [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) and the new [JsonPatchDocument<TModel>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument-1) implementation:

* The runtime type of the target object, not the declared type, determines which properties [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)) patches.
* [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json) deserialization relies on the declared type to identify eligible properties.

### Example: Apply a JsonPatchDocument with error handling

There are various errors that can occur when applying a JSON Patch document. For example, the target object may not have the specified property, or the value specified might be incompatible with the property type.

JSON  `Patch`  supports the  `test`  operation, which checks if a specified value equals the target property. If it doesn't, it returns an error.

The following example demonstrates how to handle these errors gracefully.

> [!IMPORTANT]
> The object passed to the [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)) method is modified in place. The caller is responsible for discarding changes if any operation fails.

```csharp
// Original object
var person = new Person {
    FirstName = "John",
    LastName = "Doe",
    Email = "johndoe@gmail.com"
};

// Raw JSON patch document
string jsonPatch = """
[
    { "op": "replace", "path": "/Email", "value": "janedoe@gmail.com"},
    { "op": "test", "path": "/FirstName", "value": "Jane" },
    { "op": "replace", "path": "/LastName", "value": "Smith" }
]
""";

// Deserialize the JSON patch document
var patchDoc = JsonSerializer.Deserialize<JsonPatchDocument<Person>>(jsonPatch);

// Apply the JSON patch document, catching any errors
Dictionary<string, string[]>? errors = null;
patchDoc!.ApplyTo(person, jsonPatchError =>
    {
        errors ??= new ();
        var key = jsonPatchError.AffectedObject.GetType().Name;
        if (!errors.ContainsKey(key))
        {
            errors.Add(key, new string[] { });
        }
        errors[key] = errors[key].Append(jsonPatchError.ErrorMessage).ToArray();
    });
if (errors != null)
{
    // Print the errors
    foreach (var error in errors)
    {
        Console.WriteLine($"Error in {error.Key}: {string.Join(", ", error.Value)}");
    }
}

// Output updated object
Console.WriteLine(JsonSerializer.Serialize(person, serializerOptions));
```

The previous example results in the following output:

```output
Error in Person: The current value 'John' at path 'FirstName' is not equal 
to the test value 'Jane'.
{
    "firstName": "John",
    "lastName": "Smith",              <<< Modified!
    "email": "janedoe@gmail.com",     <<< Modified!
    "phoneNumbers": []
}
```

## Mitigating security risks

When using the  `Microsoft.AspNetCore.JsonPatch.SystemTextJson`  package, it's critical to understand and mitigate potential security risks. The following sections outline the identified security risks associated with JSON Patch and provide recommended mitigations to ensure secure usage of the package.

> [!IMPORTANT]
> ***This is not an exhaustive list of threats.*** App developers must conduct their own threat model reviews to determine an app-specific comprehensive list and come up with appropriate mitigations as needed. For example, apps which expose collections to patch operations should consider the potential for algorithmic complexity attacks if those operations insert or remove elements at the beginning of the collection.

To minimize security risks when integrating JSON Patch functionality into their apps, developers should:

* Run comprehensive threat models for their own apps.
* Address identified threats.
* Follow the recommended mitigations in the following sections.

### Denial of Service (DoS) via memory amplification

* **Scenario**: A malicious client submits a  `copy`  operation that duplicates large object graphs multiple times, leading to excessive memory consumption.
* **Impact**: Potential Out-Of-Memory (OOM) conditions, causing service disruptions.
* **Mitigation**:
  + Validate incoming JSON Patch documents for size and structure before calling [ApplyTo(Object)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.jsonpatch.systemtextjson.jsonpatchdocument.applyto#microsoft-aspnetcore-jsonpatch-systemtextjson-jsonpatchdocument-applyto(system-object)).
  + The validation must be app specific, but an example validation can look similar to the following:

```csharp
public void Validate(JsonPatchDocument<T> patch)
{
    // This is just an example. It's up to the developer to make sure that
    // this case is handled properly, based on the app needs.
    if (patch.Operations.Where(op=>op.OperationType == OperationType.Copy).Count()
                              > MaxCopyOperationsCount)
    {
        throw new InvalidOperationException();
    }
}
```

### Business Logic Subversion

* **Scenario**: Patch operations can manipulate fields with implicit invariants (for example, internal flags, IDs, or computed fields), violating business constraints.
* **Impact**: Data integrity issues and unintended app behavior.
* **Mitigation**:
  + Use POCOs (Plain Old CLR Objects) with explicitly defined properties that are safe to modify.
    - Avoid exposing sensitive or security-critical properties in the target object.
    - If a POCO object isn't used, validate the patched object after applying operations to ensure business rules and invariants aren't violated.

### Authentication and authorization

* **Scenario**: Unauthenticated or unauthorized clients send malicious JSON Patch requests.
* **Impact**: Unauthorized access to modify sensitive data or disrupt app behavior.
* **Mitigation**:
  + Protect endpoints accepting JSON Patch requests with proper authentication and authorization mechanisms.
  + Restrict access to trusted clients or users with appropriate permissions.

## Get the code

[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/web-api/jsonpatch/samples). ([How to download](https://learn.microsoft.com/en-us/aspnet/fundamentals/?view=aspnetcore-10.0#how-to-download-a-sample)).

To test the sample, run the app and send HTTP requests with the following settings:

* URL:  `http://localhost:{port}/jsonpatch/jsonpatchwithmodelstate`
* HTTP method:  `PATCH`
* Header:  `Content-Type: application/json-patch+json`
* Body: Copy and paste one of the JSON patch document samples from the *JSON* project folder.