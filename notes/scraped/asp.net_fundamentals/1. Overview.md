# ASP.NET Core fundamentals overview

This article provides an overview of the fundamentals for building ASP.NET Core apps, including dependency injection (DI), configuration, middleware, and more.

For Blazor fundamentals guidance, which adds to or supersedes the guidance in this article, see [ASP.NET Core Blazor fundamentals](https://learn.microsoft.com/en-us/aspnet/blazor/fundamentals/?view=aspnetcore-10.0).

## Program.cs

ASP.NET Core apps created with the web templates contain the application startup code in the  `Program.cs`  file. The  `Program.cs`  file is where:

* Services required by the app are configured.
* The app's request handling pipeline is defined as a series of [middleware components](https://learn.microsoft.com/en-us/aspnet/core/middleware/?view=aspnetcore-10.0).

The following app startup code supports several app types:

* [Blazor Web Apps](https://learn.microsoft.com/en-us/aspnet/blazor/?view=aspnetcore-10.0)
* [Razor Pages](https://learn.microsoft.com/en-us/aspnet/tutorials/razor-pages/razor-pages-start?view=aspnetcore-10.0)
* [MVC controllers with views](https://learn.microsoft.com/en-us/aspnet/tutorials/first-mvc-app/start-mvc?view=aspnetcore-10.0)
* [Web API with controllers](https://learn.microsoft.com/en-us/aspnet/tutorials/first-web-api?view=aspnetcore-10.0)
* [Minimal web APIs](https://learn.microsoft.com/en-us/aspnet/tutorials/min-web-api?view=aspnetcore-10.0)

```csharp
using WebAll.Components;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();
builder.Services.AddRazorPages();
builder.Services.AddControllersWithViews();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseAuthorization();

app.MapGet("/hi", () => "Hello!");

app.MapDefaultControllerRoute();
app.MapRazorPages();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.UseAntiforgery();

app.Run();
```

## Dependency injection (services)

ASP.NET Core features built-in [dependency injection (DI)](https://learn.microsoft.com/en-us/aspnet/core/dependency-injection?view=aspnetcore-10.0) that makes configured services available throughout an app. Services are added to the DI container with [WebApplicationBuilder.Services](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder.services#microsoft-aspnetcore-builder-webapplicationbuilder-services),  `builder.Services`  in the preceding code. When the [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) is instantiated, many [framework-provided services](https://learn.microsoft.com/en-us/aspnet/core/dependency-injection?view=aspnetcore-10.0#framework-provided-services) are added automatically.  `builder`  is a  `WebApplicationBuilder`  in the following code:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddRazorPages();
builder.Services.AddControllersWithViews();

var app = builder.Build();
```

In the preceding code,  `CreateBuilder`  adds configuration, logging, and [many other services](https://learn.microsoft.com/en-us/aspnet/core/dependency-injection?view=aspnetcore-10.0#framework-provided-services) to the DI container. The DI framework provides an instance of a requested service at run time.

The following code adds a custom [DbContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.dbcontext) and Blazor components to the DI container:

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContextFactory<BlazorWebAppMoviesContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("MoviesContext") 
        ?? throw new InvalidOperationException("Connection string not found.")));

builder.Services.AddQuickGridEntityFrameworkAdapter();

builder.Services.AddDatabaseDeveloperPageExceptionFilter();

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

var app = builder.Build();
```

In Blazor Web Apps, services are often resolved from DI at run time by using the  `@inject`  directive in a Razor component, as shown in the following example:

```razor
@page "/movies"
@rendermode InteractiveServer
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Components.QuickGrid
@using BlazorWebAppMovies.Models
@using BlazorWebAppMovies.Data
@implements IAsyncDisposable
@inject IDbContextFactory<BlazorWebAppMovies.Data.BlazorWebAppMoviesContext> DbFactory

<PageTitle>Index</PageTitle>

<h1>Index</h1>

<div>
    <input type="search" @bind="titleFilter" @bind:event="oninput" />
</div>

<p>
    <a href="movies/create">Create New</a>
</p>

<QuickGrid Class="table" Items="FilteredMovies" Pagination="pagination">
    <PropertyColumn Property="movie => movie.Title" Sortable="true" />
    <PropertyColumn Property="movie => movie.ReleaseDate" Title="Release Date" />
    <PropertyColumn Property="movie => movie.Genre" />
    <PropertyColumn Property="movie => movie.Price" />
    <PropertyColumn Property="movie => movie.Rating" />

    <TemplateColumn Context="movie">
        <a href="@($"movies/edit?id={movie.Id}")">Edit</a> |
        <a href="@($"movies/details?id={movie.Id}")">Details</a> |
        <a href="@($"movies/delete?id={movie.Id}")">Delete</a>
    </TemplateColumn>
</QuickGrid>

<Paginator State="pagination" />

@code {
    private BlazorWebAppMoviesContext context = default!;
    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };
    private string titleFilter = string.Empty;

    private IQueryable<Movie> FilteredMovies =>
        context.Movie.Where(m => m.Title!.Contains(titleFilter));

    protected override void OnInitialized()
    {
        context = DbFactory.CreateDbContext();
    }

    public async ValueTask DisposeAsync() => await context.DisposeAsync();
}
```

In the preceding code:

* The  `@inject`  directive is used.
* The service is resolved in the  `OnInitialized`  method and assigned to the  `context`  variable.
* The  `context`  service creates the  `FilteredMovie`  list.

Another way to resolve a service from DI is by using constructor injection. The following Razor Pages code uses constructor injection to resolve the database context and a logger from DI:

```csharp
public class IndexModel : PageModel
{
    private readonly RazorPagesMovieContext _context;
    private readonly ILogger<IndexModel> _logger;

    public IndexModel(RazorPagesMovieContext context, ILogger<IndexModel> logger)
    {
        _context = context;
        _logger = logger;
    }

    public IList<Movie> Movie { get;set; }

    public async Task OnGetAsync()
    {
        _logger.LogInformation("IndexModel OnGetAsync.");
        Movie = await _context.Movie.ToListAsync();
    }
}
```

In the preceding code, the  `IndexModel`  constructor takes a parameter of type  `RazorPagesMovieContext` , which is resolved at run time into the  `_context`  variable. The context object is used to create a list of movies in the  `OnGetAsync`  method.

For more information, see [ASP.NET Core Blazor dependency injection](https://learn.microsoft.com/en-us/aspnet/blazor/fundamentals/dependency-injection?view=aspnetcore-10.0) and [Dependency injection in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/dependency-injection?view=aspnetcore-10.0).

## Middleware

The request handling pipeline is composed as a series of middleware components. Each component performs operations on an [ `HttpContext` ](http-context?view=aspnetcore-10.0) and either invokes the next middleware in the pipeline or terminates the request.

By convention, a middleware component is added to the pipeline by invoking a  `Use{Feature}`  extension method. The use of methods named  `Use{Feature}`  to add middleware to an app is illustrated in the following code:

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContextFactory<BlazorWebAppMoviesContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("MoviesContext") 
        ?? throw new InvalidOperationException("Connection string not found.")));

builder.Services.AddQuickGridEntityFrameworkAdapter();

builder.Services.AddDatabaseDeveloperPageExceptionFilter();

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

var app = builder.Build();

using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;

    SeedData.Initialize(services);
}

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    app.UseHsts();
    app.UseMigrationsEndPoint();
}
app.UseHttpsRedirection();

app.UseAntiforgery();

app.MapStaticAssets();
app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();
```

For more information, see [ASP.NET Core Middleware](https://learn.microsoft.com/en-us/aspnet/core/middleware/?view=aspnetcore-10.0).

## Host

On startup, an ASP.NET Core app builds a *host*. The host encapsulates all of the app's resources, such as:

* An HTTP server implementation
* Middleware components
* Logging
* Dependency injection (DI) services
* Configuration

There are three different hosts capable of running an ASP.NET Core app:

* [ASP.NET Core WebApplication](https://learn.microsoft.com/en-us/aspnet/core/minimal-apis/webapplication?view=aspnetcore-10.0), also known as the [Minimal Host](https://learn.microsoft.com/en-us/aspnet/migration/50-to-60?view=aspnetcore-10.0#new-hosting-model)
* [.NET Generic Host](https://learn.microsoft.com/en-us/aspnet/core/host/generic-host?view=aspnetcore-10.0) combined with ASP.NET Core's [ConfigureWebHostDefaults](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.generichostbuilderextensions.configurewebhostdefaults)
* [ASP.NET Core WebHost](https://learn.microsoft.com/en-us/aspnet/core/host/web-host?view=aspnetcore-10.0)

The ASP.NET Core [WebApplication](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication) and [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) types are recommended and are used in all the ASP.NET Core templates.  `WebApplication`  behaves similarly to the .NET Generic Host and exposes many of the same interfaces but requires fewer callbacks to configure. The ASP.NET Core [WebHost](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.webhost) is available only for backward compatibility.

The following example instantiates a  `WebApplication`  and assigns it to a variable named  `app` :

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddDbContextFactory<BlazorWebAppMoviesContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("MoviesContext") 
        ?? throw new InvalidOperationException("Connection string not found.")));

builder.Services.AddQuickGridEntityFrameworkAdapter();

builder.Services.AddDatabaseDeveloperPageExceptionFilter();

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

var app = builder.Build();
```

The [WebApplicationBuilder.Build](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder.build) method configures a host with a set of default options, such as:

* Use [Kestrel](https://learn.microsoft.com/en-us/aspnet/core/#servers) as the web server and enable IIS integration.
* Load [configuration](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0) from  `appsettings.json` , environment variables, command line arguments, and other configuration sources.
* Send logging output to the console and debug providers.

### Non-web scenarios

The Generic Host enables other types of apps to use cross-cutting framework extensions, such as logging, dependency injection (DI), configuration, and app lifetime management. For more information, see [.NET Generic Host in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/host/generic-host?view=aspnetcore-10.0) and [Background tasks with hosted services in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/host/hosted-services?view=aspnetcore-10.0).

## Servers

An ASP.NET Core app uses an HTTP server implementation to listen for HTTP requests. The server surfaces requests to the app as a set of [request features](https://learn.microsoft.com/en-us/aspnet/core/request-features?view=aspnetcore-10.0) composed into an [HttpContext](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext).

* [Windows](https://learn.microsoft.com/en-us/aspnet/core/#tabpanel_1_windows)
* [macOS](https://learn.microsoft.com/en-us/aspnet/core/#tabpanel_1_macos)
* [Linux](https://learn.microsoft.com/en-us/aspnet/core/#tabpanel_1_linux)

ASP.NET Core provides the following server implementations:

* *Kestrel* is a cross-platform web server. Kestrel is often run in a reverse proxy configuration using [IIS](https://www.iis.net/). In ASP.NET Core 2.0 or later, Kestrel can be run as a public-facing edge server exposed directly to the Internet.
* *IIS HTTP Server* is a server for Windows that uses IIS. With this server, the ASP.NET Core app and IIS run in the same process.
* *HTTP.sys* is a server for Windows that isn't used with IIS.

ASP.NET Core provides the *Kestrel* cross-platform server implementation. In ASP.NET Core 2.0 or later, Kestrel can run as a public-facing edge server exposed directly to the Internet. Kestrel is often run in a reverse proxy configuration with [Nginx](https://nginx.org) or [Apache](https://httpd.apache.org/).

ASP.NET Core provides the *Kestrel* cross-platform server implementation. In ASP.NET Core 2.0 or later, Kestrel can run as a public-facing edge server exposed directly to the Internet. Kestrel is often run in a reverse proxy configuration with [Nginx](https://nginx.org) or [Apache](https://httpd.apache.org/).

For more information, see [Web server implementations in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/servers/?view=aspnetcore-10.0).

## Configuration

ASP.NET Core provides a [configuration](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0) framework that gets settings as name-value pairs from an ordered set of configuration providers. Built-in configuration providers are available for a variety of sources, such as  `.json`  files,  `.xml`  files, environment variables, and command-line arguments. Write custom configuration providers to support other sources.

By [default](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0#default), ASP.NET Core apps are configured to read from  `appsettings.json` , environment variables, the command line, and more. When the app's configuration is loaded, values from environment variables override values from  `appsettings.json` .

For managing confidential configuration data such as passwords in the  `Development`  environment, .NET provides the [Secret Manager](https://learn.microsoft.com/en-us/aspnet/security/app-secrets?view=aspnetcore-10.0#secret-manager). For production secrets, we recommend [Azure Key Vault](https://learn.microsoft.com/en-us/aspnet/security/key-vault-configuration?view=aspnetcore-10.0).

For more information, see [Configuration in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/configuration/?view=aspnetcore-10.0).

## Environments

Execution environments, such as  `Development` ,  `Staging` , and  `Production` , are available in ASP.NET Core. Specify the environment an app is running in by setting the  `ASPNETCORE_ENVIRONMENT`  environment variable. ASP.NET Core reads that environment variable at app startup and stores the value in an  `IWebHostEnvironment`  implementation. This implementation is available anywhere in an app via dependency injection (DI).

The following example configures the exception handler and [HTTP Strict Transport Security Protocol (HSTS)](https://learn.microsoft.com/en-us/aspnet/security/enforcing-ssl?view=aspnetcore-10.0#http-strict-transport-security-protocol-hsts) middleware when ***not*** running in the  `Development`  environment:

```csharp
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    app.UseHsts();
    app.UseMigrationsEndPoint();
}
```

For more information, see [ASP.NET Core runtime environments](https://learn.microsoft.com/en-us/aspnet/core/environments?view=aspnetcore-10.0).

## Logging

ASP.NET Core supports a logging API that works with a variety of built-in and third-party logging providers. Available providers include:

* Console
* Debug
* Event Tracing on Windows
* Windows Event Log
* TraceSource
* Azure App Service
* Azure Application Insights

To create logs, resolve an [ILogger<TCategoryName>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger-1) service from dependency injection (DI) and call logging methods such as [LogInformation](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.loggerextensions.loginformation). The following example shows how to get and use a logger in a  `.razor`  file for a page in a Blazor Web App. A logger object and a console provider for it are stored in the DI container automatically when the [CreateBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createbuilder) method is called in  `Program.cs` .

```csharp
@page "/weather"
@attribute [StreamRendering]
@inject ILogger<Weather> Logger

<PageTitle>Weather</PageTitle>

<h1>Weather</h1>

<p>This component demonstrates showing data and logging.</p>

@if (forecasts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>Date</th>
                <th aria-label="Temperature in Celsius">Temp. (C)</th>
                <th aria-label="Temperature in Fahrenheit">Temp. (F)</th>
                <th>Summary</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var forecast in forecasts)
            {
                <tr>
                    <td>@forecast.Date.ToShortDateString()</td>
                    <td>@forecast.TemperatureC</td>
                    <td>@forecast.TemperatureF</td>
                    <td>@forecast.Summary</td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private WeatherForecast[]? forecasts;

    protected override async Task OnInitializedAsync()
    {
        // Simulate asynchronous loading to demonstrate streaming rendering
       
        await Task.Delay(500);

        Logger.LogInformation("This is an information log message.");
        Logger.LogWarning("This is a warning log message.");
        Logger.LogError("This is an error log message.");

        var startDate = DateOnly.FromDateTime(DateTime.Now);
        var summaries = new[] { "Freezing", "Bracing", "Chilly",
            "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching" };
        forecasts = Enumerable.Range(1, 5).Select(index => new WeatherForecast
        {
            Date = startDate.AddDays(index),
            TemperatureC = Random.Shared.Next(-20, 55),
            Summary = summaries[Random.Shared.Next(summaries.Length)]
        }).ToArray();
    }

    private class WeatherForecast
    {
        public DateOnly Date { get; set; }
        public int TemperatureC { get; set; }
        public string? Summary { get; set; }
        public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
    }
}
```

For more information, see [Logging in .NET and ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/logging/?view=aspnetcore-10.0).

## Routing

Routing in ASP.NET Core is a mechanism that maps incoming requests to specific endpoints in an application. It enables you to define URL patterns that correspond to different components, such as Razor components, Razor pages, MVC controller actions, or middleware.

The [UseRouting](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting) method adds routing middleware to the request pipeline. This middleware processes the routing information and determines the appropriate endpoint for each request. You don't have to explicitly call  `UseRouting`  unless you want to change the order in which middleware is processed.

For more information, see [Routing in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/routing?view=aspnetcore-10.0) and [ASP.NET Core Blazor routing](https://learn.microsoft.com/en-us/aspnet/blazor/fundamentals/routing?view=aspnetcore-10.0).

## Error handling

ASP.NET Core has built-in features for handling errors, such as:

* A developer exception page
* Custom error pages
* Static status code pages
* Startup exception handling

For more information, see [Handle errors in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/error-handling?view=aspnetcore-10.0).

## Make HTTP requests

An implementation of [IHttpClientFactory](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.ihttpclientfactory) is available for creating [HttpClient](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient) instances. The factory:

* Provides a central location for naming and configuring logical  `HttpClient`  instances. For example, register and configure a *github* client for accessing GitHub. Register and configure a default client for other purposes.
* Supports registration and chaining of multiple delegating handlers to build an outgoing request middleware pipeline. This pattern is similar to ASP.NET Core's inbound middleware pipeline. The pattern provides a mechanism to manage cross-cutting concerns for HTTP requests, including caching, error handling, serialization, and logging.
* Integrates with *Polly*, a popular third-party library for transient fault handling.
* Manages the pooling and lifetime of underlying [HttpClientHandler](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclienthandler) instances to avoid common DNS problems that occur when managing  `HttpClient`  lifetimes manually.
* Adds a configurable logging experience via [ILogger](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.ilogger) for all requests sent through clients created by the factory.

For more information, see [Make HTTP requests using IHttpClientFactory in ASP.NET Core](http-requests?view=aspnetcore-10.0).

## Content root

The content root is the base path for:

* The executable hosting the app (*.exe*).
* Compiled assemblies that make up the app (*.dll*).
* Content files used by the app, such as:
  + Razor files ( `.cshtml` ,  `.razor` )
  + Configuration files ( `.json` ,  `.xml` )
  + Data files ( `.db` )
* The [Web root](https://learn.microsoft.com/en-us/aspnet/core/#web-root), typically the  `wwwroot`  folder.

During development, the content root defaults to the project's root directory. This directory is also the base path for both the app's content files and the [web root](https://learn.microsoft.com/en-us/aspnet/core/#web-root). Specify a different content root by setting its path when [building the host](https://learn.microsoft.com/en-us/aspnet/core/#host). For more information, see [Content root](https://learn.microsoft.com/en-us/aspnet/core/host/generic-host?view=aspnetcore-10.0#contentroot).

## Web root

The web root is the base path for public, static resource files, such as:

* Stylesheets ( `.css` )
* JavaScript ( `.js` )
* Images ( `.png` ,  `.jpg` )

By default, static files are served only from the web root directory and its sub-directories. The web root path defaults to  `{CONTENT ROOT}/wwwroot` , where the  `{CONTENT ROOT}`  placeholder is the content root. Specify a different web root by setting its path when [building the host](https://learn.microsoft.com/en-us/aspnet/core/#host). For more information, see [Web root](https://learn.microsoft.com/en-us/aspnet/core/host/generic-host?view=aspnetcore-10.0#webroot).

Prevent publishing files in  `wwwroot`  with the [ `<Content>`  project item](https://learn.microsoft.com/en-us/visualstudio/msbuild/common-msbuild-project-items#content) in the project file. The following example prevents publishing content in  `wwwroot/local`  and its sub-directories:

```xml
<ItemGroup>
  <Content Update="wwwroot\local\**\*.*" CopyToPublishDirectory="Never" />
</ItemGroup>
```

In Razor  `.cshtml`  files,  `~/`  points to the web root. A path beginning with  `~/`  is referred to as a *virtual path*.

For more information, see [Static files in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/static-files?view=aspnetcore-10.0).

## How to download a sample

Many of the articles and tutorials include links to sample code.

1. [Download the ASP.NET repository zip file](https://codeload.github.com/dotnet/AspNetCore.Docs/zip/main).
2. Unzip the  `AspNetCore.Docs-main.zip`  file.
3. To access an article's sample app in the unzipped repository, use the URL in the article's sample link to help you navigate to the sample's folder. Usually, an article's sample link appears at the top of the article with the link text *View or download sample code*.

### Preprocessor directives in sample code

To demonstrate multiple scenarios, sample apps use the  `#define`  and  `#if-#else/#elif-#endif`  preprocessor directives to selectively compile and run different sections of sample code. For those samples that make use of this approach, set the  `#define`  directive at the top of the C# files to define the symbol associated with the scenario that you want to run. Some samples require defining the symbol at the top of multiple files in order to run a scenario.

For example, the following  `#define`  symbol list indicates that four scenarios are available (one scenario per symbol). The current sample configuration runs the  `TemplateCode`  scenario:

```csharp
#define TemplateCode // or LogFromMain or ExpandDefault or FilterInCode
```

To change the sample to run the  `ExpandDefault`  scenario, define the  `ExpandDefault`  symbol and leave the remaining symbols commented-out:

```csharp
#define ExpandDefault // TemplateCode or LogFromMain or FilterInCode
```

For more information on using [C# preprocessor directives](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/) to selectively compile sections of code, see [#define (C# Reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-define) and [#if (C# Reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-if).

### Regions in sample code

Some sample apps contain sections of code surrounded by [#region](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-region) and [#endregion](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-endregion) C# directives. The documentation build system injects these regions into the rendered documentation topics.

Region names usually contain the word "snippet." The following example shows a region named  `snippet_WebHostDefaults` :

```csharp
#region snippet_WebHostDefaults
Host.CreateDefaultBuilder(args)
    .ConfigureWebHostDefaults(webBuilder =>
    {
        webBuilder.UseStartup<Startup>();
    });
#endregion
```

The preceding C# code snippet is referenced in the topic's markdown file with the following line:

```md
[!code-csharp[](sample/SampleApp/Program.cs?name=snippet_WebHostDefaults)]
```

You may safely ignore or remove the  `#region`  and  `#endregion`  directives that surround the code. Don't alter the code within these directives if you plan to run the sample scenarios described in the topic.

For more information, see [Contribute to the ASP.NET documentation: Code snippets](https://github.com/dotnet/AspNetCore.Docs/blob/main/CONTRIBUTING.md#code-snippets).