# Configuration in ASP.NET Core

By [Rick Anderson](https://twitter.com/RickAndMSFT) and [Kirk Larkin](https://twitter.com/serpent5)

Application configuration in ASP.NET Core is performed using one or more [configuration providers](https://learn.microsoft.com/en-us/aspnet/core/#cp). Configuration providers read configuration data from key-value pairs using a variety of configuration sources:

* Settings files, such as  `appsettings.json`
* Environment variables
* Azure Key Vault
* Azure App Configuration
* Command-line arguments
* Custom providers, installed or created
* Directory files
* In-memory .NET objects

This article provides information on configuration in ASP.NET Core. For information on using configuration in non-ASP.NET Core apps, see [.NET Configuration](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration).

For Blazor configuration guidance, which adds to or supersedes the guidance in this node, see [ASP.NET Core Blazor configuration](https://learn.microsoft.com/en-us/blazor/fundamentals/configuration?view=aspnetcore-10.0).

## Application and Host Configuration

ASP.NET Core apps configure and launch a *host*. The host is responsible for app startup and lifetime management. The ASP.NET Core templates create a [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) which contains the host. While some configuration can be done in both the host and the application configuration providers, generally, only configuration that is necessary for the host should be done in host configuration.

Application configuration is the highest priority and is detailed in the next section. [Host configuration](https://learn.microsoft.com/en-us/aspnet/core/#host) follows application configuration, and is described in this article.

### Default application configuration sources

ASP.NET Core web apps created with [dotnet new](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-new) or Visual Studio generate the following code:

```csharp
var builder = WebApplication.CreateBuilder(args);
```

[WebApplication.CreateBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createbuilder) initializes a new instance of the [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) class with preconfigured defaults. The initialized  `WebApplicationBuilder`  ( `builder` ) provides default configuration for the app in the following order, from highest to lowest priority:

1. Command-line arguments using the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#command-line).
2. Non-prefixed environment variables using the [Non-prefixed environment variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp).
3. [User secrets](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0) when the app runs in the  `Development`  environment.
4. `appsettings.{Environment}.json`  using the [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp). For example,  `appsettings.Production.json`  and  `appsettings.Development.json` .
5. [appsettings.json](https://learn.microsoft.com/en-us/aspnet/core/#appsettingsjson) using the [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp).
6. A fallback to the host configuration described in the [next section](https://learn.microsoft.com/en-us/aspnet/core/#host).

Note:  `WebApplication.CreateBuilder(args)`  should only be called once in apps relying on IIS in-process hosting.

### Default host configuration sources

The following list contains the default host configuration sources from highest to lowest priority for [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder):

1. Command-line arguments using the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#command-line)
2. `DOTNET_` -prefixed environment variables using the [Environment variables configuration provider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.environmentvariables.environmentvariablesconfigurationprovider).
3. `ASPNETCORE_` -prefixed environment variables using the [Environment variables configuration provider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.environmentvariables.environmentvariablesconfigurationprovider).

For the [.NET Generic Host](https://learn.microsoft.com/en-us/aspnet/host/generic-host?view=aspnetcore-10.0) and [Web Host](https://learn.microsoft.com/en-us/aspnet/host/web-host?view=aspnetcore-10.0), the default host configuration sources from highest to lowest priority is:

1. `ASPNETCORE_` -prefixed environment variables using the [Environment variables configuration provider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.environmentvariables.environmentvariablesconfigurationprovider).
2. Command-line arguments using the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#command-line)
3. `DOTNET_` -prefixed environment variables using the [Environment variables configuration provider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.environmentvariables.environmentvariablesconfigurationprovider).

When a configuration value is set in host and application configuration, the application configuration is used.

### Host variables

The following variables are locked in early when initializing the host builders and can't be influenced by application config:

* [Application name](https://learn.microsoft.com/en-us/aspnet/minimal-apis?view=aspnetcore-10.0#change-the-content-root-application-name-and-environment)
* [Environment name](https://learn.microsoft.com/en-us/aspnet/environments?view=aspnetcore-10.0), for example  `Development` ,  `Production` , and  `Staging`
* [Content root](https://learn.microsoft.com/en-us/aspnet/?view=aspnetcore-10.0#content-root)
* [Web root](https://learn.microsoft.com/en-us/aspnet/?view=aspnetcore-10.0#web-root)
* Whether to scan for [hosting startup assemblies](https://learn.microsoft.com/en-us/aspnet/host/platform-specific-configuration?view=aspnetcore-10.0) and which assemblies to scan for.
* Variables read by app and library code from [HostBuilderContext.Configuration](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.hostbuildercontext.configuration#microsoft-extensions-hosting-hostbuildercontext-configuration) in [IHostBuilder.ConfigureAppConfiguration](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostbuilder.configureappconfiguration) callbacks.

Every other host setting is read from application config instead of host config.

`URLS`  is one of the many common host settings that is not a bootstrap setting. Like every other host setting not in the previous list,  `URLS`  is read later from application config. Host config is a fallback for application config, so host config can be used to set  `URLS` , but it will be overridden by any configuration source in application config like  `appsettings.json` .

For more information, see [Change the content root, app name, and environment](https://learn.microsoft.com/en-us/migration/50-to-60-samples?view=aspnetcore-10.0#change-the-content-root-app-name-and-environment) and [Change the content root, app name, and environment by environment variables or command line](https://learn.microsoft.com/en-us/migration/50-to-60-samples?view=aspnetcore-10.0#change-the-content-root-app-name-and-environment-by-environment-variables-or-command-line)

The remaining sections in this article refer to application configuration.

## Application configuration providers

The following code displays the enabled configuration providers in the order they were added:

```csharp
public class Index2Model : PageModel
{
    private IConfigurationRoot ConfigRoot;

    public Index2Model(IConfiguration configRoot)
    {
        ConfigRoot = (IConfigurationRoot)configRoot;
    }

    public ContentResult OnGet()
    {           
        string str = "";
        foreach (var provider in ConfigRoot.Providers.ToList())
        {
            str += provider.ToString() + "\n";
        }

        return Content(str);
    }
}
```

The preceding [list of highest to lowest priority default configuration sources](https://learn.microsoft.com/en-us/aspnet/core/#hi2low) shows the providers in the opposite order they are added to template generated application. For example, the [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp) is added before the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#command-line).

Configuration providers that are added later have higher priority and override previous key settings. For example, if  `MyKey`  is set in both  `appsettings.json`  and the environment, the environment value is used. Using the default configuration providers, the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp) overrides all other providers.

For more information on  `CreateBuilder` , see [Default builder settings](https://learn.microsoft.com/en-us/aspnet/host/generic-host?view=aspnetcore-10.0#default-builder-settings).

### `appsettings.json`

Consider the following  `appsettings.json`  file:

```json
{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "MyKey": "My appsettings.json Value",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

The following code from the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) displays several of the preceding configurations settings:

```csharp
public class TestModel : PageModel
{
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var myKeyValue = Configuration["MyKey"];
        var title = Configuration["Position:Title"];
        var name = Configuration["Position:Name"];
        var defaultLogLevel = Configuration["Logging:LogLevel:Default"];

        return Content($"MyKey value: {myKeyValue} \n" +
                       $"Title: {title} \n" +
                       $"Name: {name} \n" +
                       $"Default Log Level: {defaultLogLevel}");
    }
}
```

The default [JsonConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.json.jsonconfigurationprovider) loads configuration in the following order:

1. `appsettings.json`
2. `appsettings.{Environment}.json`  : For example, the  `appsettings.Production.json`  and  `appsettings.Development.json`  files. The environment version of the file is loaded based on the [IHostingEnvironment.EnvironmentName](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting.ihostingenvironment.environmentname). For more information, see [ASP.NET Core runtime environments](https://learn.microsoft.com/en-us/aspnet/environments?view=aspnetcore-10.0).

`appsettings.{Environment}.json`  values override keys in  `appsettings.json` . For example, by default:

* In development,  `appsettings.Development.json`  configuration overwrites values found in  `appsettings.json` .
* In production,  `appsettings.Production.json`  configuration overwrites values found in  `appsettings.json` . For example, when deploying the app to Azure.

If a configuration value must be guaranteed, see [GetValue](https://learn.microsoft.com/en-us/aspnet/core/#getvalue). The preceding example only reads strings and doesnât support a default value.

Using the [default](https://learn.microsoft.com/en-us/aspnet/core/#default) configuration, the  `appsettings.json`  and  `appsettings.{Environment}.json`  files are enabled with [reloadOnChange: true](https://github.com/dotnet/extensions/blob/release/3.1/src/Hosting/Hosting/src/Host.cs#L74-L75). Changes made to the  `appsettings.json`  and  `appsettings.{Environment}.json`  file ***after*** the app starts are read by the [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp).

### Comments in appsettings.json

Comments in  `appsettings.json`  and  `appsettings.{Environment}.json`  files are supported using JavaScript or [C# style comments](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/comments).

Some integrated development environments (IDE) display errors when editing a JSON file that contains comments. You can generally ignore comment errors and warnings, but you can also usually disable them with a setting in the IDE. In Visual Studio Code, for example, add the following to the  `settings.json`  file to disable the errors:

```json
"files.associations": {
  "appsettings*.json": "jsonc"
}
```

For other IDEs, check the tool's documentation and other product support channels to determine how to silence the errors.

### Bind hierarchical configuration data using the options pattern

The preferred way to read related configuration values is using the [options pattern](https://learn.microsoft.com/en-us/aspnet/core/options?view=aspnetcore-10.0). For example, to read the following configuration values:

```json
"Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  }
```

Create the following  `PositionOptions`  class:

```csharp
public class PositionOptions
{
    public const string Position = "Position";

    public string Title { get; set; } = String.Empty;
    public string Name { get; set; } = String.Empty;
}
```

An options class:

* Must be non-abstract with a public parameterless constructor.
* All public read-write properties of the type are bound.
* Fields are ***not*** bound. In the preceding code,  `Position`  is not bound. The  `Position`  field is used so the string  `"Position"`  doesn't need to be hard coded in the app when binding the class to a configuration provider.

The following code:

* Calls [ConfigurationBinder.Bind](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind) to bind the  `PositionOptions`  class to the  `Position`  section.
* Displays the  `Position`  configuration data.

```csharp
public class Test22Model : PageModel
{
    private readonly IConfiguration Configuration;

    public Test22Model(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var positionOptions = new PositionOptions();
        Configuration.GetSection(PositionOptions.Position).Bind(positionOptions);

        return Content($"Title: {positionOptions.Title} \n" +
                       $"Name: {positionOptions.Name}");
    }
}
```

In the preceding code, by default, changes to the JSON configuration file after the app has started are read.

[ `ConfigurationBinder.Get<T>` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder.get) binds and returns the specified type.  `ConfigurationBinder.Get<T>`  may be more convenient than using  `ConfigurationBinder.Bind` . The following code shows how to use  `ConfigurationBinder.Get<T>`  with the  `PositionOptions`  class:

```csharp
public class Test21Model : PageModel
{
    private readonly IConfiguration Configuration;
    public PositionOptions? positionOptions { get; private set; }

    public Test21Model(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {            
        positionOptions = Configuration.GetSection(PositionOptions.Position)
                                                     .Get<PositionOptions>();

        return Content($"Title: {positionOptions.Title} \n" +
                       $"Name: {positionOptions.Name}");
    }
}
```

In the preceding code, by default, changes to the JSON configuration file after the app has started are read.

An alternative approach when using the ***options pattern*** is to bind the  `Position`  section and add it to the [dependency injection service container](https://learn.microsoft.com/en-us/aspnet/dependency-injection?view=aspnetcore-10.0). In the following code,  `PositionOptions`  is added to the service container with [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsconfigurationservicecollectionextensions.configure) and bound to configuration:

```csharp
using ConfigSample.Options;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<PositionOptions>(
    builder.Configuration.GetSection(PositionOptions.Position));

var app = builder.Build();
```

Using the preceding code, the following code reads the position options:

```csharp
public class Test2Model : PageModel
{
    private readonly PositionOptions _options;

    public Test2Model(IOptions<PositionOptions> options)
    {
        _options = options.Value;
    }

    public ContentResult OnGet()
    {
        return Content($"Title: {_options.Title} \n" +
                       $"Name: {_options.Name}");
    }
}
```

In the preceding code, changes to the JSON configuration file after the app has started are ***not*** read. To read changes after the app has started, use [IOptionsSnapshot](https://learn.microsoft.com/en-us/aspnet/core/options?view=aspnetcore-10.0#ios).

Using the [default](https://learn.microsoft.com/en-us/aspnet/core/#default) configuration, the  `appsettings.json`  and  `appsettings.{Environment}.json`  files are enabled with [reloadOnChange: true](https://github.com/dotnet/extensions/blob/release/3.1/src/Hosting/Hosting/src/Host.cs#L74-L75). Changes made to the  `appsettings.json`  and  `appsettings.{Environment}.json`  file ***after*** the app starts are read by the [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp).

See [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp) in this document for information on adding additional JSON configuration files.

## Combining service collection

Consider the following which registers services and configures options:

```csharp
using ConfigSample.Options;
using Microsoft.Extensions.DependencyInjection.ConfigSample.Options;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<PositionOptions>(
    builder.Configuration.GetSection(PositionOptions.Position));
builder.Services.Configure<ColorOptions>(
    builder.Configuration.GetSection(ColorOptions.Color));

builder.Services.AddScoped<IMyDependency, MyDependency>();
builder.Services.AddScoped<IMyDependency2, MyDependency2>();

var app = builder.Build();
```

Related groups of registrations can be moved to an extension method to register services. For example, the configuration services are added to the following class:

```csharp
using ConfigSample.Options;
using Microsoft.Extensions.Configuration;

namespace Microsoft.Extensions.DependencyInjection
{
    public static class MyConfigServiceCollectionExtensions
    {
        public static IServiceCollection AddConfig(
             this IServiceCollection services, IConfiguration config)
        {
            services.Configure<PositionOptions>(
                config.GetSection(PositionOptions.Position));
            services.Configure<ColorOptions>(
                config.GetSection(ColorOptions.Color));

            return services;
        }

        public static IServiceCollection AddMyDependencyGroup(
             this IServiceCollection services)
        {
            services.AddScoped<IMyDependency, MyDependency>();
            services.AddScoped<IMyDependency2, MyDependency2>();

            return services;
        }
    }
}
```

The remaining services are registered in a similar class. The following code uses the new extension methods to register the services:

```csharp
using Microsoft.Extensions.DependencyInjection.ConfigSample.Options;

var builder = WebApplication.CreateBuilder(args);

builder.Services
    .AddConfig(builder.Configuration)
    .AddMyDependencyGroup();

builder.Services.AddRazorPages();

var app = builder.Build();
```

***Note:*** Each  `services.Add{GROUP_NAME}`  extension method adds and potentially configures services. For example, [AddControllersWithViews](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.mvcservicecollectionextensions.addcontrollerswithviews) adds the services MVC controllers with views require, and [AddRazorPages](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.mvcservicecollectionextensions.addrazorpages) adds the services Razor Pages requires.

## Security and user secrets

Configuration data guidelines:

* Never store passwords or other sensitive data in configuration provider code or in plain text configuration files. The [Secret Manager](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0) tool can be used to store secrets in development.
* Don't use production secrets in development or test environments.
* Specify secrets outside of the project so that they can't be accidentally committed to a source code repository.
* Production apps should use the most secure authentication flow available. For more information, see [Secure authentication flows](https://learn.microsoft.com/en-us/security/?view=aspnetcore-10.0#secure-authentication-flows).

By [default](https://learn.microsoft.com/en-us/aspnet/core/#default), the user secrets configuration source is registered after the JSON configuration sources. Therefore, user secrets keys take precedence over keys in  `appsettings.json`  and  `appsettings.{Environment}.json` .

For more information on storing passwords or other sensitive data:

* [ASP.NET Core runtime environments](https://learn.microsoft.com/en-us/aspnet/environments?view=aspnetcore-10.0)
* [Safe storage of app secrets in development in ASP.NET Core](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0): Includes advice on using environment variables to store sensitive data. The Secret Manager tool uses the [File configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#fcp) to store user secrets in a JSON file on the local system.
* [Azure Key Vault](https://azure.microsoft.com/services/key-vault/) safely stores app secrets for ASP.NET Core apps. For more information, see [Azure Key Vault configuration provider in ASP.NET Core](https://learn.microsoft.com/en-us/security/key-vault-configuration?view=aspnetcore-10.0).

## Non-prefixed environment variables

Non-prefixed environment variables are environment variables other than those prefixed by  `ASPNETCORE_`  or  `DOTNET_` . For example, the ASP.NET Core web application templates set  `"ASPNETCORE_ENVIRONMENT": "Development"`  in  `launchSettings.json` . For more information on  `ASPNETCORE_`  and  `DOTNET_`  environment variables, see:

* [List of highest to lowest priority default configuration sources](https://learn.microsoft.com/en-us/aspnet/core/#hi2low) including non-prefixed,  `ASPNETCORE_` -prefixed and  `DOTNETCORE_` -prefixed environment variables.
* [ `DOTNET_`  environment variables](https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-environment-variables) used outside of [Microsoft.Extensions.Hosting](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.hosting).

Using the [default](https://learn.microsoft.com/en-us/aspnet/core/#default) configuration, the [EnvironmentVariablesConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.environmentvariables.environmentvariablesconfigurationprovider) loads configuration from environment variable key-value pairs after reading  `appsettings.json` ,  `appsettings.{Environment}.json` , and [user secrets](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0). Therefore, key values read from the environment override values read from  `appsettings.json` ,  `appsettings.{Environment}.json` , and user secrets.

The  `:`  separator doesn't work with environment variable hierarchical keys on all platforms. For example, the  `:`  separator is not supported by [Bash](https://linuxhint.com/bash-environment-variables/). The double underscore,  `__` , is:

* Supported by all platforms.
* Automatically replaced by a colon,  `:` .

The following commands:

* Set the environment keys and values of the [preceding example](https://learn.microsoft.com/en-us/aspnet/core/#appsettingsjson) on Windows.
* Test the settings when using the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample). The  `dotnet run`  command must be run in the project directory.

```dotnetcli
set MyKey="My key from Environment"
set Position__Title=Environment_Editor
set Position__Name=Environment_Rick
dotnet run
```

The preceding environment settings:

* Are only set in processes launched from the command window they were set in.
* Won't be read by browsers launched with Visual Studio.

The following [setx](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/setx) commands can be used to set the environment keys and values on Windows. Unlike  `set` ,  `setx`  settings are persisted.  `/M`  sets the variable in the system environment. If the  `/M`  switch isn't used, a user environment variable is set.

```console
setx MyKey "My key from setx Environment" /M
setx Position__Title Environment_Editor /M
setx Position__Name Environment_Rick /M
```

To test that the preceding commands override  `appsettings.json`  and  `appsettings.{Environment}.json` :

* With Visual Studio: Exit and restart Visual Studio.
* With the CLI: Start a new command window and enter  `dotnet run` .

Call [AddEnvironmentVariables](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.environmentvariablesextensions.addenvironmentvariables) with a string to specify a prefix for environment variables:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Configuration.AddEnvironmentVariables(prefix: "MyCustomPrefix_");

var app = builder.Build();
```

In the preceding code:

* `builder.Configuration.AddEnvironmentVariables(prefix: "MyCustomPrefix_")`  is added after the [default configuration providers](https://learn.microsoft.com/en-us/aspnet/core/#default). For an example of ordering the configuration providers, see [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp).
* Environment variables set with the  `MyCustomPrefix_`  prefix override the [default configuration providers](https://learn.microsoft.com/en-us/aspnet/core/#default). This includes environment variables without the prefix.

The prefix is stripped off when the configuration key-value pairs are read.

The following commands test the custom prefix:

```dotnetcli
set MyCustomPrefix_MyKey="My key with MyCustomPrefix_ Environment"
set MyCustomPrefix_Position__Title=Editor_with_customPrefix
set MyCustomPrefix_Position__Name=Environment_Rick_cp
dotnet run
```

The [default configuration](https://learn.microsoft.com/en-us/aspnet/core/#default) loads environment variables and command line arguments prefixed with  `DOTNET_`  and  `ASPNETCORE_` . The  `DOTNET_`  and  `ASPNETCORE_`  prefixes are used by ASP.NET Core for [host and app configuration](https://learn.microsoft.com/en-us/aspnet/host/generic-host?view=aspnetcore-10.0#host-configuration), but not for user configuration. For more information on host and app configuration, see [.NET Generic Host](https://learn.microsoft.com/en-us/aspnet/host/generic-host?view=aspnetcore-10.0).

On [Azure App Service](https://azure.microsoft.com/services/app-service/), select **New application setting** on the **Settings > Configuration** page. Azure App Service application settings are:

* Encrypted at rest and transmitted over an encrypted channel.
* Exposed as environment variables.

For more information, see [Azure Apps: Override app configuration using the Azure Portal](https://learn.microsoft.com/en-us/host-and-deploy/azure-apps/?view=aspnetcore-10.0#override-app-configuration-using-the-azure-portal).

See [Connection string prefixes](https://learn.microsoft.com/en-us/aspnet/core/#constr) for information on Azure database connection strings.

### Naming of environment variables

Environment variable names reflect the structure of an  `appsettings.json`  file. Each element in the hierarchy is separated by a double underscore (preferable) or a colon. When the element structure includes an array, the array index should be treated as an additional element name in this path. Consider the following  `appsettings.json`  file and its equivalent values represented as environment variables.

* `appsettings.json` *

```json
{
    "SmtpServer": "smtp.example.com",
    "Logging": [
        {
            "Name": "ToEmail",
            "Level": "Critical",
            "Args": {
                "FromAddress": "MySystem@example.com",
                "ToAddress": "SRE@example.com"
            }
        },
        {
            "Name": "ToConsole",
            "Level": "Information"
        }
    ]
}
```

**environment variables**

```console
setx SmtpServer smtp.example.com
setx Logging__0__Name ToEmail
setx Logging__0__Level Critical
setx Logging__0__Args__FromAddress MySystem@example.com
setx Logging__0__Args__ToAddress SRE@example.com
setx Logging__1__Name ToConsole
setx Logging__1__Level Information
```

### Environment variables set in generated launchSettings.json

Environment variables set in  `launchSettings.json`  override those set in the system environment. For example, the ASP.NET Core web templates generate a  `launchSettings.json`  file that sets the endpoint configuration to:

```json
"applicationUrl": "https://localhost:5001;http://localhost:5000"
```

Configuring the  `applicationUrl`  sets the  `ASPNETCORE_URLS`  environment variable and overrides values set in the environment.

### Escape environment variables on Linux

On Linux, the value of URL environment variables must be escaped so  `systemd`  can parse it. Use the linux tool  `systemd-escape`  which yields  `http:--localhost:5001`

```cmd
groot@terminus:~$ systemd-escape http://localhost:5001
http:--localhost:5001
```

### Display environment variables

The following code displays the environment variables and values on application startup, which can be helpful when debugging environment settings:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

foreach (var c in builder.Configuration.AsEnumerable())
{
    Console.WriteLine(c.Key + " = " + c.Value);
}
```

## Command-line

Using the [default](https://learn.microsoft.com/en-us/aspnet/core/#default) configuration, the [CommandLineConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.commandline.commandlineconfigurationprovider) loads configuration from command-line argument key-value pairs after the following configuration sources:

* `appsettings.json`  and  `appsettings.{Environment}.json`  files.
* [App secrets](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0) in the  `Development`  environment.
* Environment variables.

By [default](https://learn.microsoft.com/en-us/aspnet/core/#default), configuration values set on the command-line override configuration values set with all the other configuration providers.

### Command-line arguments

The following command sets keys and values using  `=` :

```dotnetcli
dotnet run MyKey="Using =" Position:Title=Cmd Position:Name=Cmd_Rick
```

The following command sets keys and values using  `/` :

```dotnetcli
dotnet run /MyKey "Using /" /Position:Title=Cmd /Position:Name=Cmd_Rick
```

The following command sets keys and values using  `--` :

```dotnetcli
dotnet run --MyKey "Using --" --Position:Title=Cmd --Position:Name=Cmd_Rick
```

The key value:

* Must follow  `=` , or the key must have a prefix of  `--`  or  `/`  when the value follows a space.
* Isn't required if  `=`  is used. For example,  `MySetting=` .

Within the same command, don't mix command-line argument key-value pairs that use  `=`  with key-value pairs that use a space.

### Switch mappings

Switch mappings allow **key** name replacement logic. Provide a dictionary of switch replacements to the [AddCommandLine](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.commandlineconfigurationextensions.addcommandline) method.

When the switch mappings dictionary is used, the dictionary is checked for a key that matches the key provided by a command-line argument. If the command-line key is found in the dictionary, the dictionary value is passed back to set the key-value pair into the app's configuration. A switch mapping is required for any command-line key prefixed with a single dash ( `-` ).

Switch mappings dictionary key rules:

* Switches must start with  `-`  or  `--` .
* The switch mappings dictionary must not contain duplicate keys.

To use a switch mappings dictionary, pass it into the call to  `AddCommandLine` :

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

var switchMappings = new Dictionary<string, string>()
         {
             { "-k1", "key1" },
             { "-k2", "key2" },
             { "--alt3", "key3" },
             { "--alt4", "key4" },
             { "--alt5", "key5" },
             { "--alt6", "key6" },
         };

builder.Configuration.AddCommandLine(args, switchMappings);

var app = builder.Build();
```

Run the following command works to test key replacement:

```dotnetcli
dotnet run -k1 value1 -k2 value2 --alt3=value2 /alt4=value3 --alt5 value5 /alt6 value6
```

The following code shows the key values for the replaced keys:

```csharp
public class Test3Model : PageModel
{
    private readonly IConfiguration Config;

    public Test3Model(IConfiguration configuration)
    {
        Config = configuration;
    }

    public ContentResult OnGet()
    {
        return Content(
                $"Key1: '{Config["Key1"]}'\n" +
                $"Key2: '{Config["Key2"]}'\n" +
                $"Key3: '{Config["Key3"]}'\n" +
                $"Key4: '{Config["Key4"]}'\n" +
                $"Key5: '{Config["Key5"]}'\n" +
                $"Key6: '{Config["Key6"]}'");
    }
}
```

For apps that use switch mappings, the call to  `CreateDefaultBuilder`  shouldn't pass arguments. The  `CreateDefaultBuilder`  method's  `AddCommandLine`  call doesn't include mapped switches, and there's no way to pass the switch-mapping dictionary to  `CreateDefaultBuilder` . The solution isn't to pass the arguments to  `CreateDefaultBuilder`  but instead to allow the  `ConfigurationBuilder`  method's  `AddCommandLine`  method to process both the arguments and the switch-mapping dictionary.

## Set environment and command-line arguments with Visual Studio

Environment and command-line arguments can be set in Visual Studio from the launch profiles dialog:

* In Solution Explorer, right click the project and select **Properties**.
* Select the **Debug > General** tab and select **Open debug launch profiles UI**.

## Hierarchical configuration data

The Configuration API reads hierarchical configuration data by flattening the hierarchical data with the use of a delimiter in the configuration keys.

The [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) contains the following  `appsettings.json`  file:

```json
{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "MyKey": "My appsettings.json Value",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

The following code from the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) displays several of the configurations settings:

```csharp
public class TestModel : PageModel
{
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var myKeyValue = Configuration["MyKey"];
        var title = Configuration["Position:Title"];
        var name = Configuration["Position:Name"];
        var defaultLogLevel = Configuration["Logging:LogLevel:Default"];

        return Content($"MyKey value: {myKeyValue} \n" +
                       $"Title: {title} \n" +
                       $"Name: {name} \n" +
                       $"Default Log Level: {defaultLogLevel}");
    }
}
```

The preferred way to read hierarchical configuration data is using the options pattern. For more information, see [Bind hierarchical configuration data](https://learn.microsoft.com/en-us/aspnet/core/#optpat) in this document.

[GetSection](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationsection.getsection) and [GetChildren](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration.getchildren) methods are available to isolate sections and children of a section in the configuration data. These methods are described later in [GetSection, GetChildren, and Exists](https://learn.microsoft.com/en-us/aspnet/core/#getsection).

## Configuration keys and values

> [!WARNING]
> This article shows the use of connection strings. With a local database the user doesn't have to be authenticated, but in production, connection strings sometimes include a password to authenticate. A resource owner password credential (ROPC) is a security risk that should be avoided in production databases. Production apps should use the most secure authentication flow available. For more information on authentication for apps deployed to test or production environments, see [Secure authentication flows](https://learn.microsoft.com/en-us/security/?view=aspnetcore-10.0#secure-authentication-flows).

Configuration keys:

* Are case-insensitive. For example,  `ConnectionString`  and  `connectionstring`  are treated as equivalent keys.
* If a key and value is set in more than one configuration provider, the value from the last provider added is used. For more information, see [Default configuration](https://learn.microsoft.com/en-us/aspnet/core/#default).
* Hierarchical keys
  + Within the Configuration API, a colon separator ( `:` ) works on all platforms.
  + In environment variables, a colon separator may not work on all platforms. A double underscore,  `__` , is supported by all platforms and is automatically converted into a colon  `:` .
  + In Azure Key Vault, hierarchical keys use  `--`  as a separator. The [Azure Key Vault configuration provider](https://learn.microsoft.com/en-us/security/key-vault-configuration?view=aspnetcore-10.0) automatically replaces  `--`  with a  `:`  when the secrets are loaded into the app's configuration.
* The [ConfigurationBinder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder) supports binding arrays to objects using array indices in configuration keys. Array binding is described in the [Bind an array to a class](https://learn.microsoft.com/en-us/aspnet/core/#boa) section.

Configuration values:

* Are strings.
* Null values can't be stored in configuration or bound to objects.

## Configuration providers

The following table shows the configuration providers available to ASP.NET Core apps.

| Provider | Provides configuration from |
| --- | --- |
| [Azure Key Vault configuration provider](https://learn.microsoft.com/en-us/security/key-vault-configuration?view=aspnetcore-10.0) | Azure Key Vault |
| [Azure App configuration provider](https://learn.microsoft.com/en-us/azure/azure-app-configuration/quickstart-aspnet-core-app) | Azure App Configuration |
| [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp) | Command-line parameters |
| [Custom configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#custom-configuration-provider) | Custom source |
| [Environment Variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp) | Environment variables |
| [File configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#file-configuration-provider) | INI, JSON, and XML files |
| [Key-per-file configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#key-per-file-configuration-provider) | Directory files |
| [Memory configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#memory-configuration-provider) | In-memory collections |
| [User secrets](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0) | File in the user profile directory |

Configuration sources are read in the order that their configuration providers are specified. Order configuration providers in code to suit the priorities for the underlying configuration sources that the app requires.

A typical sequence of configuration providers is:

1. `appsettings.json`
2. `appsettings.{Environment}.json`
3. [User secrets](https://learn.microsoft.com/en-us/security/app-secrets?view=aspnetcore-10.0)
4. Environment variables using the [Environment Variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp).
5. Command-line arguments using the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp).

A common practice is to add the Command-line configuration provider last in a series of providers to allow command-line arguments to override configuration set by the other providers.

The preceding sequence of providers is used in the [default configuration](https://learn.microsoft.com/en-us/aspnet/core/#default).

### Connection string prefixes

> [!WARNING]
> This article shows the use of connection strings. With a local database the user doesn't have to be authenticated, but in production, connection strings sometimes include a password to authenticate. A resource owner password credential (ROPC) is a security risk that should be avoided in production databases. Production apps should use the most secure authentication flow available. For more information on authentication for apps deployed to test or production environments, see [Secure authentication flows](https://learn.microsoft.com/en-us/security/?view=aspnetcore-10.0#secure-authentication-flows).

The Configuration API has special processing rules for four connection string environment variables. These connection strings are involved in configuring Azure connection strings for the app environment. Environment variables with the prefixes shown in the table are loaded into the app with the [default configuration](https://learn.microsoft.com/en-us/aspnet/core/#default) or when no prefix is supplied to  `AddEnvironmentVariables` .

| Connection string prefix | Provider |
| --- | --- |
| `CUSTOMCONNSTR_` | Custom provider |
| `MYSQLCONNSTR_` | [MySQL](https://www.mysql.com/) |
| `SQLAZURECONNSTR_` | [Azure SQL Database](https://azure.microsoft.com/services/sql-database/) |
| `SQLCONNSTR_` | [SQL Server](https://www.microsoft.com/sql-server/) |

When an environment variable is discovered and loaded into configuration with any of the four prefixes shown in the table:

* The configuration key is created by removing the environment variable prefix and adding a configuration key section ( `ConnectionStrings` ).
* A new configuration key-value pair is created that represents the database connection provider (except for  `CUSTOMCONNSTR_` , which has no stated provider).

| Environment variable key | Converted configuration key | Provider configuration entry |
| --- | --- | --- |
| `CUSTOMCONNSTR_{KEY}` | `ConnectionStrings:{KEY}` | Configuration entry not created. |
| `MYSQLCONNSTR_{KEY}` | `ConnectionStrings:{KEY}` | Key:  `ConnectionStrings:{KEY}_ProviderName` : Value:  `MySql.Data.MySqlClient` |
| `SQLAZURECONNSTR_{KEY}` | `ConnectionStrings:{KEY}` | Key:  `ConnectionStrings:{KEY}_ProviderName` : Value:  `System.Data.SqlClient` |
| `SQLCONNSTR_{KEY}` | `ConnectionStrings:{KEY}` | Key:  `ConnectionStrings:{KEY}_ProviderName` : Value:  `System.Data.SqlClient` |

## File configuration provider

[FileConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.fileconfigurationprovider) is the base class for loading configuration from the file system. The following configuration providers derive from  `FileConfigurationProvider` :

* [INI configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#ini-configuration-provider)
* [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp)
* [XML configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#xml-configuration-provider)

### INI configuration provider

The [IniConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.ini.iniconfigurationprovider) loads configuration from INI file key-value pairs at runtime.

The following code adds several configuration providers:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Configuration
    .AddIniFile("MyIniConfig.ini", optional: true, reloadOnChange: true)
    .AddIniFile($"MyIniConfig.{builder.Environment.EnvironmentName}.ini",
                optional: true, reloadOnChange: true);

builder.Configuration.AddEnvironmentVariables();
builder.Configuration.AddCommandLine(args);

builder.Services.AddRazorPages();

var app = builder.Build();
```

In the preceding code, settings in the  `MyIniConfig.ini`  and  `MyIniConfig.{Environment}.ini`  files are overridden by settings in the:

* [Environment variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp)
* [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp).

The [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) contains the following  `MyIniConfig.ini`  file:

```ini
MyKey="MyIniConfig.ini Value"

[Position]
Title="My INI Config title"
Name="My INI Config name"

[Logging:LogLevel]
Default=Information
Microsoft=Warning
```

The following code from the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) displays several of the preceding configurations settings:

```csharp
public class TestModel : PageModel
{
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var myKeyValue = Configuration["MyKey"];
        var title = Configuration["Position:Title"];
        var name = Configuration["Position:Name"];
        var defaultLogLevel = Configuration["Logging:LogLevel:Default"];

        return Content($"MyKey value: {myKeyValue} \n" +
                       $"Title: {title} \n" +
                       $"Name: {name} \n" +
                       $"Default Log Level: {defaultLogLevel}");
    }
}
```

### JSON configuration provider

The [JsonConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.json.jsonconfigurationprovider) loads configuration from JSON file key-value pairs.

Overloads can specify:

* Whether the file is optional.
* Whether the configuration is reloaded if the file changes.

Consider the following code:

```csharp
using Microsoft.Extensions.DependencyInjection.ConfigSample.Options;

var builder = WebApplication.CreateBuilder(args);

builder.Configuration.AddJsonFile("MyConfig.json",
        optional: true,
        reloadOnChange: true);

builder.Services.AddRazorPages();

var app = builder.Build();
```

The preceding code:

* Configures the JSON configuration provider to load the  `MyConfig.json`  file with the following options:
  + `optional: true` : The file is optional.
  + `reloadOnChange: true`  : The file is reloaded when changes are saved.
* Reads the [default configuration providers](https://learn.microsoft.com/en-us/aspnet/core/#default) before the  `MyConfig.json`  file. Settings in the  `MyConfig.json`  file override setting in the default configuration providers, including the [Environment variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp) and the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp).

You typically ***don't*** want a custom JSON file overriding values set in the [Environment variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp) and the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp).

### XML configuration provider

The [XmlConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.xml.xmlconfigurationprovider) loads configuration from XML file key-value pairs at runtime.

The following code adds several configuration providers:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Configuration
    .AddXmlFile("MyXMLFile.xml", optional: true, reloadOnChange: true)
    .AddXmlFile($"MyXMLFile.{builder.Environment.EnvironmentName}.xml",
                optional: true, reloadOnChange: true);

builder.Configuration.AddEnvironmentVariables();
builder.Configuration.AddCommandLine(args);

builder.Services.AddRazorPages();

var app = builder.Build();
```

In the preceding code, settings in the  `MyXMLFile.xml`  and  `MyXMLFile.{Environment}.xml`  files are overridden by settings in the:

* [Environment variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp)
* [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp).

The [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) contains the following  `MyXMLFile.xml`  file:

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <MyKey>MyXMLFile Value</MyKey>
  <Position>
    <Title>Title from  MyXMLFile</Title>
    <Name>Name from MyXMLFile</Name>
  </Position>
  <Logging>
    <LogLevel>
      <Default>Information</Default>
      <Microsoft>Warning</Microsoft>
    </LogLevel>
  </Logging>
</configuration>
```

The following code from the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample) displays several of the preceding configurations settings:

```csharp
public class TestModel : PageModel
{
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var myKeyValue = Configuration["MyKey"];
        var title = Configuration["Position:Title"];
        var name = Configuration["Position:Name"];
        var defaultLogLevel = Configuration["Logging:LogLevel:Default"];

        return Content($"MyKey value: {myKeyValue} \n" +
                       $"Title: {title} \n" +
                       $"Name: {name} \n" +
                       $"Default Log Level: {defaultLogLevel}");
    }
}
```

Repeating elements that use the same element name work if the  `name`  attribute is used to distinguish the elements:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <section name="section0">
    <key name="key0">value 00</key>
    <key name="key1">value 01</key>
  </section>
  <section name="section1">
    <key name="key0">value 10</key>
    <key name="key1">value 11</key>
  </section>
</configuration>
```

The following code reads the previous configuration file and displays the keys and values:

```csharp
public class IndexModel : PageModel
{
    private readonly IConfiguration Configuration;

    public IndexModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var key00 = "section:section0:key:key0";
        var key01 = "section:section0:key:key1";
        var key10 = "section:section1:key:key0";
        var key11 = "section:section1:key:key1";

        var val00 = Configuration[key00];
        var val01 = Configuration[key01];
        var val10 = Configuration[key10];
        var val11 = Configuration[key11];

        return Content($"{key00} value: {val00} \n" +
                       $"{key01} value: {val01} \n" +
                       $"{key10} value: {val10} \n" +
                       $"{key10} value: {val11} \n"
                       );
    }
}
```

Attributes can be used to supply values:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <key attribute="value" />
  <section>
    <key attribute="value" />
  </section>
</configuration>
```

The previous configuration file loads the following keys with  `value` :

* key:attribute
* section:key:attribute

## Key-per-file configuration provider

The [KeyPerFileConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.keyperfile.keyperfileconfigurationprovider) uses a directory's files as configuration key-value pairs. The key is the file name. The value contains the file's contents. The Key-per-file configuration provider is used in Docker hosting scenarios.

To activate key-per-file configuration, call the [AddKeyPerFile](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.keyperfileconfigurationbuilderextensions.addkeyperfile) extension method on an instance of [ConfigurationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbuilder). The  `directoryPath`  to the files must be an absolute path.

Overloads permit specifying:

* An  `Action<KeyPerFileConfigurationSource>`  delegate that configures the source.
* Whether the directory is optional and the path to the directory.

The double-underscore ( `__` ) is used as a configuration key delimiter in file names. For example, the file name  `Logging__LogLevel__System`  produces the configuration key  `Logging:LogLevel:System` .

Call  `ConfigureAppConfiguration`  when building the host to specify the app's configuration:

```csharp
.ConfigureAppConfiguration((hostingContext, config) =>
{
    var path = Path.Combine(
        Directory.GetCurrentDirectory(), "path/to/files");
    config.AddKeyPerFile(directoryPath: path, optional: true);
})
```

## Memory configuration provider

The [MemoryConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.memory.memoryconfigurationprovider) uses an in-memory collection as configuration key-value pairs.

The following code adds a memory collection to the configuration system:

```csharp
var builder = WebApplication.CreateBuilder(args);

var Dict = new Dictionary<string, string>
        {
           {"MyKey", "Dictionary MyKey Value"},
           {"Position:Title", "Dictionary_Title"},
           {"Position:Name", "Dictionary_Name" },
           {"Logging:LogLevel:Default", "Warning"}
        };

builder.Configuration.AddInMemoryCollection(Dict);
builder.Configuration.AddEnvironmentVariables();
builder.Configuration.AddCommandLine(args);

builder.Services.AddRazorPages();

var app = builder.Build();
```

The following code from the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/3.x/ConfigSample) displays the preceding configurations settings:

```csharp
public class TestModel : PageModel
{
    // requires using Microsoft.Extensions.Configuration;
    private readonly IConfiguration Configuration;

    public TestModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var myKeyValue = Configuration["MyKey"];
        var title = Configuration["Position:Title"];
        var name = Configuration["Position:Name"];
        var defaultLogLevel = Configuration["Logging:LogLevel:Default"];

        return Content($"MyKey value: {myKeyValue} \n" +
                       $"Title: {title} \n" +
                       $"Name: {name} \n" +
                       $"Default Log Level: {defaultLogLevel}");
    }
}
```

In the preceding code,  `config.AddInMemoryCollection(Dict)`  is added after the [default configuration providers](https://learn.microsoft.com/en-us/aspnet/core/#default). For an example of ordering the configuration providers, see [JSON configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#jcp).

See [Bind an array](https://learn.microsoft.com/en-us/aspnet/core/#boa) for another example using  `MemoryConfigurationProvider` .

## Kestrel endpoint configuration

Kestrel specific endpoint configuration overrides all [cross-server](https://learn.microsoft.com/en-us/aspnet/servers/?view=aspnetcore-10.0) endpoint configurations. Cross-server endpoint configurations include:

* [UseUrls](https://learn.microsoft.com/en-us/aspnet/host/web-host?view=aspnetcore-10.0#server-urls)
* `--urls`  on the [command line](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-10.0#command-line)
* The [environment variable](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-10.0#environment-variables)  `ASPNETCORE_URLS`

Consider the following  `appsettings.json`  file used in an ASP.NET Core web app:

```json
{
  "Kestrel": {
    "Endpoints": {
      "Https": {
        "Url": "https://localhost:9999"
      }
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

When the preceding highlighted markup is used in an ASP.NET Core web app ***and*** the app is launched on the command line with the following cross-server endpoint configuration:

`dotnet run --urls="https://localhost:7777"`

Kestrel binds to the endpoint configured specifically for Kestrel in the  `appsettings.json`  file ( `https://localhost:9999` ) and not  `https://localhost:7777` .

Consider the Kestrel specific endpoint configured as an environment variable:

`set Kestrel__Endpoints__Https__Url=https://localhost:8888`

In the preceding environment variable,  `Https`  is the name of the Kestrel specific endpoint. The preceding  `appsettings.json`  file also defines a Kestrel specific endpoint named  `Https` . By [default](https://learn.microsoft.com/en-us/aspnet/core/#default-host-configuration), environment variables using the [Environment Variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp) are read after  `appsettings.{Environment}.json` , therefore, the preceding environment variable is used for the  `Https`  endpoint.

## GetValue

[ConfigurationBinder.GetValue](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder.getvalue) extracts a single value from configuration with a specified key and converts it to the specified type:

```csharp
public class TestNumModel : PageModel
{
    private readonly IConfiguration Configuration;

    public TestNumModel(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var number = Configuration.GetValue<int>("NumberKey", 99);
        return Content($"{number}");
    }
}
```

In the preceding code, if  `NumberKey`  isn't found in the configuration, the default value of  `99`  is used.

## GetSection, GetChildren, and Exists

For the examples that follow, consider the following  `MySubsection.json`  file:

```json
{
  "section0": {
    "key0": "value00",
    "key1": "value01"
  },
  "section1": {
    "key0": "value10",
    "key1": "value11"
  },
  "section2": {
    "subsection0": {
      "key0": "value200",
      "key1": "value201"
    },
    "subsection1": {
      "key0": "value210",
      "key1": "value211"
    }
  }
}
```

The following code adds  `MySubsection.json`  to the configuration providers:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Configuration
    .AddJsonFile("MySubsection.json",
                 optional: true,
                 reloadOnChange: true);

builder.Services.AddRazorPages();

var app = builder.Build();
```

### GetSection

[IConfiguration.GetSection](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration.getsection) returns a configuration subsection with the specified subsection key.

The following code returns values for  `section1` :

```csharp
public class TestSectionModel : PageModel
{
    private readonly IConfiguration Config;

    public TestSectionModel(IConfiguration configuration)
    {
        Config = configuration.GetSection("section1");
    }

    public ContentResult OnGet()
    {
        return Content(
                $"section1:key0: '{Config["key0"]}'\n" +
                $"section1:key1: '{Config["key1"]}'");
    }
}
```

The following code returns values for  `section2:subsection0` :

```csharp
public class TestSection2Model : PageModel
{
    private readonly IConfiguration Config;

    public TestSection2Model(IConfiguration configuration)
    {
        Config = configuration.GetSection("section2:subsection0");
    }

    public ContentResult OnGet()
    {
        return Content(
                $"section2:subsection0:key0 '{Config["key0"]}'\n" +
                $"section2:subsection0:key1:'{Config["key1"]}'");
    }
}
```

`GetSection`  never returns  `null` . If a matching section isn't found, an empty  `IConfigurationSection`  is returned.

When  `GetSection`  returns a matching section, [Value](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.value#microsoft-extensions-configuration-iconfigurationsection-value) isn't populated. A [Key](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.key#microsoft-extensions-configuration-iconfigurationsection-key) and [Path](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationsection.path#microsoft-extensions-configuration-iconfigurationsection-path) are returned when the section exists.

### GetChildren and Exists

The following code calls [IConfiguration.GetChildren](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration.getchildren) and returns values for  `section2:subsection0` :

```csharp
public class TestSection4Model : PageModel
{
    private readonly IConfiguration Config;

    public TestSection4Model(IConfiguration configuration)
    {
        Config = configuration;
    }

    public ContentResult OnGet()
    {
        string s = "";
        var selection = Config.GetSection("section2");
        if (!selection.Exists())
        {
            throw new Exception("section2 does not exist.");
        }
        var children = selection.GetChildren();

        foreach (var subSection in children)
        {
            int i = 0;
            var key1 = subSection.Key + ":key" + i++.ToString();
            var key2 = subSection.Key + ":key" + i.ToString();
            s += key1 + " value: " + selection[key1] + "\n";
            s += key2 + " value: " + selection[key2] + "\n";
        }
        return Content(s);
    }
}
```

The preceding code calls [ConfigurationExtensions.Exists](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationextensions.exists) to verify the section exists:

## Bind an array

The [ConfigurationBinder.Bind](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind) supports binding arrays to objects using array indices in configuration keys. Any array format that exposes a numeric key segment is capable of array binding to a [POCO](https://wikipedia.org/wiki/Plain_Old_CLR_Object) class array.

Consider  `MyArray.json`  from the [sample download](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/fundamentals/configuration/index/samples/6.x/ConfigSample):

```json
{
  "array": {
    "entries": {
      "0": "value00",
      "1": "value10",
      "2": "value20",
      "4": "value40",
      "5": "value50"
    }
  }
}
```

The following code adds  `MyArray.json`  to the configuration providers:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Configuration
    .AddJsonFile("MyArray.json",
                 optional: true,
                 reloadOnChange: true);

builder.Services.AddRazorPages();

var app = builder.Build();
```

The following code reads the configuration and displays the values:

```csharp
public class ArrayModel : PageModel
{
    private readonly IConfiguration Config;
    public ArrayExample? _array { get; private set; }

    public ArrayModel(IConfiguration config)
    {
        Config = config;
    }

    public ContentResult OnGet()
    {
       _array = Config.GetSection("array").Get<ArrayExample>();
        if (_array == null)
        {
            throw new ArgumentNullException(nameof(_array));
        }
        string s = String.Empty;

        for (int j = 0; j < _array.Entries.Length; j++)
        {
            s += $"Index: {j}  Value:  {_array.Entries[j]} \n";
        }

        return Content(s);
    }
}
```

```csharp
public class ArrayExample
{
    public string[]? Entries { get; set; } 
}
```

The preceding code returns the following output:

```text
Index: 0  Value: value00
Index: 1  Value: value10
Index: 2  Value: value20
Index: 3  Value: value40
Index: 4  Value: value50
```

In the preceding output, Index 3 has value  `value40` , corresponding to  `"4": "value40",`  in  `MyArray.json` . The bound array indices are continuous and not bound to the configuration key index. The configuration binder isn't capable of binding null values or creating null entries in bound objects.

## Custom configuration provider

The sample app demonstrates how to create a basic configuration provider that reads configuration key-value pairs from a database using [Entity Framework (EF)](https://learn.microsoft.com/en-us/ef/core/).

The provider has the following characteristics:

* The EF in-memory database is used for demonstration purposes. To use a database that requires a connection string, implement a secondary  `ConfigurationBuilder`  to supply the connection string from another configuration provider.
* The provider reads a database table into configuration at startup. The provider doesn't query the database on a per-key basis.
* Reload-on-change isn't implemented, so updating the database after the app starts has no effect on the app's configuration.

Define an  `EFConfigurationValue`  entity for storing configuration values in the database.

`Models/EFConfigurationValue.cs` :

```csharp
public class EFConfigurationValue
{
    public string Id { get; set; } = String.Empty;
    public string Value { get; set; } = String.Empty;
}
```

Add an  `EFConfigurationContext`  to store and access the configured values.

`EFConfigurationProvider/EFConfigurationContext.cs` :

```csharp
public class EFConfigurationContext : DbContext
{
    public EFConfigurationContext(DbContextOptions<EFConfigurationContext> options) : base(options)
    {
    }

    public DbSet<EFConfigurationValue> Values => Set<EFConfigurationValue>();
}
```

Create a class that implements [IConfigurationSource](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationsource).

`EFConfigurationProvider/EFConfigurationSource.cs` :

```csharp
public class EFConfigurationSource : IConfigurationSource
{
    private readonly Action<DbContextOptionsBuilder> _optionsAction;

    public EFConfigurationSource(Action<DbContextOptionsBuilder> optionsAction) => _optionsAction = optionsAction;

    public IConfigurationProvider Build(IConfigurationBuilder builder) => new EFConfigurationProvider(_optionsAction);
}
```

Create the custom configuration provider by inheriting from [ConfigurationProvider](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationprovider). The configuration provider initializes the database when it's empty. Since configuration keys are case-insensitive, the dictionary used to initialize the database is created with the case-insensitive comparer ([StringComparer.OrdinalIgnoreCase](https://learn.microsoft.com/en-us/dotnet/api/system.stringcomparer.ordinalignorecase#system-stringcomparer-ordinalignorecase)).

`EFConfigurationProvider/EFConfigurationProvider.cs` :

```csharp
public class EFConfigurationProvider : ConfigurationProvider
{
    public EFConfigurationProvider(Action<DbContextOptionsBuilder> optionsAction)
    {
        OptionsAction = optionsAction;
    }

    Action<DbContextOptionsBuilder> OptionsAction { get; }

    public override void Load()
    {
        var builder = new DbContextOptionsBuilder<EFConfigurationContext>();

        OptionsAction(builder);

        using (var dbContext = new EFConfigurationContext(builder.Options))
        {
            if (dbContext == null || dbContext.Values == null)
            {
                throw new Exception("Null DB context");
            }
            dbContext.Database.EnsureCreated();

            Data = !dbContext.Values.Any()
                ? CreateAndSaveDefaultValues(dbContext)
                : dbContext.Values.ToDictionary(c => c.Id, c => c.Value);
        }
    }

    private static IDictionary<string, string> CreateAndSaveDefaultValues(
        EFConfigurationContext dbContext)
    {
        // Quotes (c)2005 Universal Pictures: Serenity
        // https://www.uphe.com/movies/serenity-2005
        var configValues =
            new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
            {
                    { "quote1", "I aim to misbehave." },
                    { "quote2", "I swallowed a bug." },
                    { "quote3", "You can't stop the signal, Mal." }
            };

        if (dbContext == null || dbContext.Values == null)
        {
            throw new Exception("Null DB context");
        }

        dbContext.Values.AddRange(configValues
            .Select(kvp => new EFConfigurationValue
            {
                Id = kvp.Key,
                Value = kvp.Value
            })
            .ToArray());

        dbContext.SaveChanges();

        return configValues;
    }
}
```

An  `AddEFConfiguration`  extension method permits adding the configuration source to a  `ConfigurationBuilder` .

`Extensions/EntityFrameworkExtensions.cs` :

```csharp
public static class EntityFrameworkExtensions
{
    public static IConfigurationBuilder AddEFConfiguration(
               this IConfigurationBuilder builder,
               Action<DbContextOptionsBuilder> optionsAction)
    {
        return builder.Add(new EFConfigurationSource(optionsAction));
    }
}
```

The following code shows how to use the custom  `EFConfigurationProvider`  in  `Program.cs` :

```csharp
//using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

builder.Configuration.AddEFConfiguration(
    opt => opt.UseInMemoryDatabase("InMemoryDb"));

var app = builder.Build();

app.Run();
```

## Access configuration with Dependency Injection (DI)

Configuration can be injected into services using [Dependency Injection (DI)](https://learn.microsoft.com/en-us/aspnet/dependency-injection?view=aspnetcore-10.0) by resolving the [IConfiguration](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfiguration) service:

```csharp
public class Service
{
    private readonly IConfiguration _config;

    public Service(IConfiguration config) =>
        _config = config;

    public void DoSomething()
    {
        var configSettingValue = _config["ConfigSetting"];

        // ...
    }
}
```

For information on how to access values using  `IConfiguration` , see [GetValue](https://learn.microsoft.com/en-us/aspnet/core/#getvalue) and [GetSection, GetChildren, and Exists](https://learn.microsoft.com/en-us/aspnet/core/#getsection-getchildren-and-exists) in this article.

## Access configuration in Razor Pages

The following code displays configuration data in a Razor Page:

```cshtml
@page
@model Test5Model
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration

Configuration value for 'MyKey': @Configuration["MyKey"]
```

In the following code,  `MyOptions`  is added to the service container with [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsconfigurationservicecollectionextensions.configure) and bound to configuration:

```csharp
using SampleApp.Models;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<MyOptions>(
    builder.Configuration.GetSection("MyOptions"));

var app = builder.Build();
```

The following markup uses the [ `@inject` ](https://learn.microsoft.com/en-us/mvc/views/razor?view=aspnetcore-10.0#inject) Razor directive to resolve and display the options values:

```cshtml
@page
@model SampleApp.Pages.Test3Model
@using Microsoft.Extensions.Options
@using SampleApp.Models
@inject IOptions<MyOptions> optionsAccessor

<p><b>Option1:</b> @optionsAccessor.Value.Option1</p>
<p><b>Option2:</b> @optionsAccessor.Value.Option2</p>
```

## Access configuration in a MVC view file

The following code displays configuration data in a MVC view:

```cshtml
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration

Configuration value for 'MyKey': @Configuration["MyKey"]
```

## Access configuration in `Program.cs`

The following code accesses configuration in the  `Program.cs`  file.

```csharp
var builder = WebApplication.CreateBuilder(args);

var key1 = builder.Configuration.GetValue<string>("KeyOne");

var app = builder.Build();

app.MapGet("/", () => "Hello World!");

var key2 = app.Configuration.GetValue<int>("KeyTwo");
var key3 = app.Configuration.GetValue<bool>("KeyThree");

app.Logger.LogInformation("KeyOne: {KeyOne}", key1);
app.Logger.LogInformation("KeyTwo: {KeyTwo}", key2);
app.Logger.LogInformation("KeyThree: {KeyThree}", key3);

app.Run();
```

In  `appsettings.json`  for the preceding example:

```json
{
  ...
  "KeyOne": "Key One Value",
  "KeyTwo": 1999,
  "KeyThree": true
}
```

## Configure options with a delegate

Options configured in a delegate override values set in the configuration providers.

In the following code, an [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) service is added to the service container. It uses a delegate to configure values for  `MyOptions` :

```csharp
using SampleApp.Models;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<MyOptions>(myOptions =>
{
    myOptions.Option1 = "Value configured in delegate";
    myOptions.Option2 = 500;
});

var app = builder.Build();
```

The following code displays the options values:

```csharp
public class Test2Model : PageModel
{
    private readonly IOptions<MyOptions> _optionsDelegate;

    public Test2Model(IOptions<MyOptions> optionsDelegate )
    {
        _optionsDelegate = optionsDelegate;
    }

    public ContentResult OnGet()
    {
        return Content($"Option1: {_optionsDelegate.Value.Option1} \n" +
                       $"Option2: {_optionsDelegate.Value.Option2}");
    }
}
```

In the preceding example, the values of  `Option1`  and  `Option2`  are specified in  `appsettings.json`  and then overridden by the configured delegate.

## Host versus app configuration

Before the app is configured and started, a *host* is configured and launched. The host is responsible for app startup and lifetime management. Both the app and the host are configured using the configuration providers described in this topic. Host configuration key-value pairs are also included in the app's configuration. For more information on how the configuration providers are used when the host is built and how configuration sources affect host configuration, see [ASP.NET Core fundamentals overview](https://learn.microsoft.com/en-us/aspnet/?view=aspnetcore-10.0#host).

## Default host configuration

For details on the default configuration when using the [Web Host](https://learn.microsoft.com/en-us/aspnet/host/web-host?view=aspnetcore-10.0), see the [ASP.NET Core 2.2 version of this topic](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.2&preserve-view=true).

* Host configuration is provided from:
  + Environment variables prefixed with  `DOTNET_`  (for example,  `DOTNET_ENVIRONMENT` ) using the [Environment Variables configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#evcp). The prefix ( `DOTNET_` ) is stripped when the configuration key-value pairs are loaded.
  + Command-line arguments using the [Command-line configuration provider](https://learn.microsoft.com/en-us/aspnet/core/#clcp).
* Web Host default configuration is established ( `ConfigureWebHostDefaults` ):
  + Kestrel is used as the web server and configured using the app's configuration providers.
  + Add Host Filtering Middleware.
  + Add Forwarded Headers Middleware if the  `ASPNETCORE_FORWARDEDHEADERS_ENABLED`  environment variable is set to  `true` .
  + Enable IIS integration.

## Other configuration

This topic only pertains to *app configuration*. Other aspects of running and hosting ASP.NET Core apps are configured using configuration files not covered in this topic:

* `launch.json` / `launchSettings.json`  are tooling configuration files for the  `Development`  environment, described:
  + In [ASP.NET Core runtime environments](https://learn.microsoft.com/en-us/aspnet/environments?view=aspnetcore-10.0#development).
  + Across the documentation set where the files are used to configure ASP.NET Core apps for Development scenarios.
* `web.config`  is a server configuration file, described in the following topics:
  + [Host ASP.NET Core on Windows with IIS](https://learn.microsoft.com/en-us/host-and-deploy/iis/?view=aspnetcore-10.0)
  + [ASP.NET Core Module (ANCM) for IIS](https://learn.microsoft.com/en-us/host-and-deploy/aspnet-core-module?view=aspnetcore-10.0)

Environment variables set in  `launchSettings.json`  override those set in the system environment.

For more information on migrating app configuration from earlier versions of ASP.NET, see [Migrate configuration to ASP.NET Core](https://learn.microsoft.com/en-us/migration/fx-to-core/examples/configuration?view=aspnetcore-10.0).

## Add configuration from an external assembly

An [IHostingStartup](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.ihostingstartup) implementation allows adding enhancements to an app at startup from an external assembly outside of the app's  `Startup`  class. For more information, see [Use hosting startup assemblies in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/host/platform-specific-configuration?view=aspnetcore-10.0).

## Configuration-binding source generator

The [Configuration-binding source generator](https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime#configuration-binding-source-generator) provides AOT and trim-friendly configuration. For more information, see [Configuration-binding source generator](https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/runtime#configuration-binding-source-generator).