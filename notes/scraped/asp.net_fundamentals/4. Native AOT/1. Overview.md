# ASP.NET Core support for Native AOT

By [Mitch Denny](https://github.com/mitchdenny)

For Blazor WebAssembly Native AOT guidance, which adds to or supersedes the guidance in this article, see [ASP.NET Core Blazor WebAssembly build tools and ahead-of-time (AOT) compilation](https://learn.microsoft.com/en-us/aspnet/blazor/webassembly-build-tools-and-aot?view=aspnetcore-10.0).

## Why use Native AOT with ASP.NET Core

Publishing and deploying a Native AOT app provides the following benefits:

* **Minimized disk footprint**: When publishing using Native AOT, a single executable is produced containing just the code from external dependencies that is needed to support the program. Reduced executable size can lead to:
  + Smaller container images, for example in containerized deployment scenarios.
  + Reduced deployment time from smaller images.
* **Reduced startup time**: Native AOT applications can show reduced start-up times, which means
  + The app is ready to service requests quicker.
  + Improved deployment where container orchestrators need to manage transition from one version of the app to another.
* **Reduced memory demand**: Native AOT apps can have reduced memory demands, depending on the work done by the app. Reduced memory consumption can lead to greater deployment density and improved scalability.

The template app was run in our benchmarking lab to compare performance of an AOT published app, a trimmed runtime app, and an untrimmed runtime app. The following chart shows the results of the benchmarking:

![Chart showing comparison of application size, memory use, and startup time metrics of an AOT published app, a runtime app that is trimmed, and an untrimmed runtime app.](https://learn.microsoft.com/en-us/aspnet/core/aot/_static/aot-runtime-trimmed-perf-chart.png?view=aspnetcore-10.0)

The preceding chart shows that Native AOT has lower app size, memory usage, and startup time.

## ASP.NET Core and Native AOT compatibility

Not all features in ASP.NET Core are currently compatible with Native AOT. The following table summarizes ASP.NET Core feature compatibility with Native AOT:

| Feature | Fully Supported | Partially Supported | Not Supported |
| --- | --- | --- | --- |
| gRPC | âï¸Fully supported |  |  |
| Minimal APIs |  | âï¸Partially supported |  |
| MVC |  |  | âNot supported |
| Blazor Server |  |  | âNot supported |
| SignalR |  | âï¸Partially supported |  |
| JWT Authentication | âï¸Fully supported |  |  |
| Other Authentication |  |  | âNot supported |
| CORS | âï¸Fully supported |  |  |
| HealthChecks | âï¸Fully supported |  |  |
| HttpLogging | âï¸Fully supported |  |  |
| Localization | âï¸Fully supported |  |  |
| OutputCaching | âï¸Fully supported |  |  |
| RateLimiting | âï¸Fully supported |  |  |
| RequestDecompression | âï¸Fully supported |  |  |
| ResponseCaching | âï¸Fully supported |  |  |
| ResponseCompression | âï¸Fully supported |  |  |
| Rewrite | âï¸Fully supported |  |  |
| Session |  |  | âNot supported |
| Spa |  |  | âNot supported |
| StaticFiles | âï¸Fully supported |  |  |
| WebSockets | âï¸Fully supported |  |  |

For more information on limitations, see:

* [Limitations of Native AOT deployment](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot#limitations-of-native-aot-deployment)
* [Introduction to AOT warnings](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/fixing-warnings)
* [Known trimming incompatibilities](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/incompatibilities)
* [Introduction to trim warnings](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/fixing-warnings)
* [GitHub issue dotnet/core #8288](https://github.com/dotnet/core/issues/8288)

It's important to test an app thoroughly when moving to a Native AOT deployment model. The AOT deployed app should be tested to verify functionality hasn't changed from the untrimmed and JIT-compiled app. When building the app, review and correct AOT warnings. An app that issues [AOT warnings](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/fixing-warnings) during publishing may not work correctly. If no AOT warnings are issued at publish time, the published AOT app should work the same as the untrimmed and JIT-compiled app.

## Native AOT publishing

Native AOT is enabled with the  `PublishAot`  MSBuild property. The following example shows how to enable Native AOT in a project file:

```xml
<PropertyGroup>
  <PublishAot>true</PublishAot>
</PropertyGroup>
```

This setting enables Native AOT compilation during publish and enables dynamic code usage analysis during build and editing. A project that uses Native AOT publishing uses JIT compilation when running locally. An AOT app has the following differences from a JIT-compiled app:

* Features that aren't compatible with Native AOT are disabled and throw exceptions at run time.
* A source analyzer is enabled to highlight code that isn't compatible with Native AOT. At publish time, the entire app, including NuGet packages, are analyzed for compatibility again.

Native AOT analysis includes all of the app's code and the libraries the app depends on. Review Native AOT warnings and take corrective steps. It's a good idea to publish apps frequently to discover issues early in the development lifecycle.

In .NET 8, Native AOT is supported by the following ASP.NET Core app types:

* Minimal APIs - For more information, see the [The Web API (Native AOT) template](https://learn.microsoft.com/en-us/aspnet/core/#the-web-api-native-aot-template) section later in this article.
* gRPC - For more information, see [gRPC and Native AOT](https://learn.microsoft.com/en-us/aspnet/grpc/native-aot?view=aspnetcore-10.0).
* Worker services - For more information, see [AOT in Worker Service templates](https://learn.microsoft.com/en-us/aspnet/core/host/hosted-services?view=aspnetcore-10.0&preserve-view=true&view=aspnetcore-8.0#native-aot).

## The Web API (Native AOT) template

The **ASP.NET Core Web API (Native AOT)** template (short name  `webapiaot` ) creates a project with AOT enabled. The template differs from the **Web API** project template in the following ways:

* Uses Minimal APIs only, as MVC isn't yet compatible with Native AOT.
* Uses the [CreateSlimBuilder()](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createslimbuilder#microsoft-aspnetcore-builder-webapplication-createslimbuilder) API to ensure only the essential features are enabled by default, minimizing the app's deployed size.
* Is configured to listen on HTTP only, as HTTPS traffic is commonly handled by an ingress service in cloud-native deployments.
* Doesn't include a launch profile for running under IIS or IIS Express.
* Creates an [ `.http`  file](https://learn.microsoft.com/en-us/aspnet/test/http-files?view=aspnetcore-10.0) configured with sample HTTP requests that can be sent to the app's endpoints.
* Includes a sample  `Todo`  API instead of the weather forecast sample.
* Adds  `PublishAot`  to the project file, as shown [earlier in this article](https://learn.microsoft.com/en-us/aspnet/core/#native-aot-publishing).
* Enables the [JSON serializer source generators](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation). The source generator is used to generate serialization code at build time, which is required for Native AOT compilation.

### Changes to support source generation

The following example shows the code added to the  `Program.cs`  file to support JSON serialization source generation:

```diff
using MyFirstAotWebApi;
+using System.Text.Json.Serialization;

-var builder = WebApplication.CreateBuilder();
+var builder = WebApplication.CreateSlimBuilder(args);

+builder.Services.ConfigureHttpJsonOptions(options =>
+{
+  options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
+});

var app = builder.Build();

var sampleTodos = TodoGenerator.GenerateTodos().ToArray();

var todosApi = app.MapGroup("/todos");
todosApi.MapGet("/", () => sampleTodos);
todosApi.MapGet("/{id}", (int id) =>
    sampleTodos.FirstOrDefault(a => a.Id == id) is { } todo
        ? Results.Ok(todo)
        : Results.NotFound());

app.Run();

+[JsonSerializable(typeof(Todo[]))]
+internal partial class AppJsonSerializerContext : JsonSerializerContext
+{
+
+}
```

Without this added code,  `System.Text.Json`  uses reflection to serialize and deserialize JSON. Reflection isn't supported in Native AOT.

For more information, see:

* [Combine source generators](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation?pivots=dotnet-8-0#combine-source-generators)
* [TypeInfoResolverChain](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolverchain#system-text-json-jsonserializeroptions-typeinforesolverchain)

### Changes to `launchSettings.json`

The  `launchSettings.json`  file created by the **Web API (Native AOT)** template has the  `iisSettings`  section and  `IIS Express`  profile removed:

```diff
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
-  "iisSettings": {
-     "windowsAuthentication": false,
-     "anonymousAuthentication": true,
-     "iisExpress": {
-       "applicationUrl": "http://localhost:11152",
-       "sslPort": 0
-     }
-   },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "launchUrl": "todos",
      "applicationUrl": "http://localhost:5102",
        "environmentVariables": {
          "ASPNETCORE_ENVIRONMENT": "Development"
        }
      },
-     "IIS Express": {
-       "commandName": "IISExpress",
-       "launchBrowser": true,
-       "launchUrl": "todos",
-      "environmentVariables": {
-       "ASPNETCORE_ENVIRONMENT": "Development"
-      }
-    }
  }
}
```

### The `CreateSlimBuilder` method

The template uses the [CreateSlimBuilder()](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createslimbuilder#microsoft-aspnetcore-builder-webapplication-createslimbuilder) method instead of the [CreateBuilder()](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.createbuilder#microsoft-aspnetcore-builder-webapplication-createbuilder) method.

```csharp
using System.Text.Json.Serialization;
using MyFirstAotWebApi;

var builder = WebApplication.CreateSlimBuilder(args);
builder.Logging.AddConsole();

builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
});

var app = builder.Build();

var sampleTodos = TodoGenerator.GenerateTodos().ToArray();

var todosApi = app.MapGroup("/todos");
todosApi.MapGet("/", () => sampleTodos);
todosApi.MapGet("/{id}", (int id) =>
    sampleTodos.FirstOrDefault(a => a.Id == id) is { } todo
        ? Results.Ok(todo)
        : Results.NotFound());

app.Run();

[JsonSerializable(typeof(Todo[]))]
internal partial class AppJsonSerializerContext : JsonSerializerContext
{
}
```

The  `CreateSlimBuilder`  method initializes the [WebApplicationBuilder](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) with the minimum ASP.NET Core features necessary to run an app.

As noted earlier, the  `CreateSlimBuilder`  method doesn't include support for HTTPS or HTTP/3. These protocols typically aren't required for apps that run behind a TLS termination proxy. For example, see [TLS termination and end to end TLS with Application Gateway](https://learn.microsoft.com/en-us/azure/application-gateway/ssl-overview). HTTPS can be enabled by calling
[builder.WebHost.UseKestrelHttpsConfiguration](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderkestrelextensions.usekestrelhttpsconfiguration) HTTP/3 can be enabled by calling [builder.WebHost.UseQuic](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderquicextensions.usequic).

### `CreateSlimBuilder` vs `CreateBuilder`

The  `CreateSlimBuilder`  method doesn't support the following features that are supported by the  `CreateBuilder`  method:

* [Hosting startup assemblies](https://learn.microsoft.com/en-us/aspnet/core/host/platform-specific-configuration?view=aspnetcore-10.0)
* [UseStartup](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usestartup)
* The following logging providers:
  + [Windows EventLog](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging#windows-eventlog)
  + [Debug](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging#debug)
  + [Event Source](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging#event-source)
* Web hosting features:
  + [UseStaticWebAssets](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.webhostbuilderextensions.usestaticwebassets)
  + [IIS Integration](https://learn.microsoft.com/en-us/aspnet/host-and-deploy/iis/?view=aspnetcore-10.0)
* Kestrel configuration
  + [HTTPS endpoints in Kestrel](https://learn.microsoft.com/en-us/aspnet/core/servers/kestrel/endpoints?view=aspnetcore-10.0#https)
  + [Quic (HTTP/3)](https://learn.microsoft.com/en-us/aspnet/core/servers/kestrel/http3?view=aspnetcore-10.0#http3-benefits)
* [Regex and alpha constraints used in routing](https://github.com/dotnet/aspnetcore/issues/46142)

The  `CreateSlimBuilder`  method includes the following features needed for an efficient development experience:

* JSON file configuration for  `appsettings.json`  and  `appsettings.{EnvironmentName}.json` .
* User secrets configuration.
* Console logging.
* Logging configuration.

For a builder that omits the preceding features, see [The  `CreateEmptyBuilder`  method](https://learn.microsoft.com/en-us/aspnet/release-notes/aspnetcore-8.0?view=aspnetcore-10.0#new-createemptybuilder-method).

Including minimal features has benefits for trimming as well as AOT. For more information, see [Trim self-contained deployments and executables](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained).

For more detailed information, see [Comparing  `WebApplication.CreateBuilder`  to  `CreateSlimBuilder` ](https://andrewlock.net/exploring-the-dotnet-8-preview-comparing-createbuilder-to-the-new-createslimbuilder-method/)

## Source generators

Because unused code is trimmed during publishing for Native AOT, the app can't use unbounded reflection at runtime. [Source generators](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview) are used to produce code that avoids the need for reflection. In some cases, source generators produce code optimized for AOT even when a generator isn't required.

To view the source code that is generated, add the [ `EmitCompilerGeneratedFiles` ](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview) property to an app's  `.csproj`  file, as shown in the following example:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <!-- Other properties omitted for brevity -->
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
  </PropertyGroup>

</Project>
```

Run the  `dotnet build`  command to see the generated code. The output includes an  `obj/Debug/net8.0/generated/`  directory that contains all the generated files for the project.

The  `dotnet publish`  command also compiles the source files and generates files that are compiled. In addition,  `dotnet publish`  passes the generated assemblies to a native IL compiler. The IL compiler produces the native executable. The native executable contains the native machine code.

### Libraries and Native AOT

Many of the popular libraries used in ASP.NET Core projects currently have some compatibility issues when used in a project targeting Native AOT, such as:

* Use of reflection to inspect and discover types.
* Conditionally loading libraries at runtime.
* Generating code on the fly to implement functionality.

Libraries using these dynamic features need to be updated in order to work with Native AOT. They can be updated using tools like Roslyn source generators.

Library authors hoping to support Native AOT are encouraged to:

* Read about [Native AOT compatibility requirements](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=net8plus).
* [Prepare the library for trimming](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/prepare-libraries-for-trimming).

## Minimal APIs and JSON payloads

The Minimal API framework is optimized for receiving and returning JSON payloads using [System.Text.Json](https://learn.microsoft.com/en-us/dotnet/api/system.text.json).  `System.Text.Json` :

* Imposes compatibility requirements for JSON and Native AOT.
* Requires the use of the [ `System.Text.Json`  source generator](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation).

All types that are transmitted as part of the HTTP body or returned from request delegates in Minimal APIs apps must be configured on a [JsonSerializerContext](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonserializercontext) that is registered via ASP.NET Coreâs dependency injection:

```csharp
using System.Text.Json.Serialization;
using MyFirstAotWebApi;

var builder = WebApplication.CreateSlimBuilder(args);
builder.Logging.AddConsole();

builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);
});

var app = builder.Build();

var sampleTodos = TodoGenerator.GenerateTodos().ToArray();

var todosApi = app.MapGroup("/todos");
todosApi.MapGet("/", () => sampleTodos);
todosApi.MapGet("/{id}", (int id) =>
    sampleTodos.FirstOrDefault(a => a.Id == id) is { } todo
        ? Results.Ok(todo)
        : Results.NotFound());

app.Run();

[JsonSerializable(typeof(Todo[]))]
internal partial class AppJsonSerializerContext : JsonSerializerContext
{
}
```

In the preceding highlighted code:

* The JSON serializer context is registered with the [DI container](https://learn.microsoft.com/en-us/aspnet/core/dependency-injection?view=aspnetcore-10.0). For more information, see:
  + [Combine source generators](https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/source-generation?pivots=dotnet-8-0#combine-source-generators)
  + [TypeInfoResolverChain](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.jsonserializeroptions.typeinforesolverchain#system-text-json-jsonserializeroptions-typeinforesolverchain)
* The custom  `JsonSerializerContext`  is annotated with the [ `[JsonSerializable]` ](https://learn.microsoft.com/en-us/dotnet/api/system.text.json.serialization.jsonserializableattribute) attribute to enable source generated JSON serializer code for the  `ToDo`  type.

A parameter on the delegate that isn't bound to the body and does ***not*** need to be serializable. For example, a query string parameter that is a rich object type and implements  `IParsable<T>` .

```csharp
public class Todo
{
    public int Id { get; set; }
    public string? Title { get; set; }
    public DateOnly? DueBy { get; set; }
    public bool IsComplete { get; set; }
}

static class TodoGenerator
{
    private static readonly (string[] Prefixes, string[] Suffixes)[] _parts = new[]
        {
            (new[] { "Walk the", "Feed the" }, new[] { "dog", "cat", "goat" }),
            (new[] { "Do the", "Put away the" }, new[] { "groceries", "dishes", "laundry" }),
            (new[] { "Clean the" }, new[] { "bathroom", "pool", "blinds", "car" })
        };
    // Remaining code omitted for brevity.
```

## Known issues

See [this GitHub issue](https://github.com/dotnet/core/issues/8288) to report or review issues with Native AOT support in ASP.NET Core.