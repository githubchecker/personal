# Options pattern in ASP.NET Core

By [Rick Anderson](https://twitter.com/RickAndMSFT).

The options pattern uses classes to provide strongly typed access to groups of related settings. When [configuration settings](https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-10.0) are isolated by scenario into separate classes, the app adheres to two important software engineering principles:

* [Encapsulation](https://learn.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#encapsulation):
  + Classes that depend on configuration settings depend only on the configuration settings that they use.
* [Separation of Concerns](https://learn.microsoft.com/en-us/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns):
  + Settings for different parts of the app aren't dependent or coupled to one another.

Options also provide a mechanism to validate configuration data. For more information, see the [Options validation](https://learn.microsoft.com/en-us/aspnet/core/#options-validation) section.

This article provides information on the options pattern in ASP.NET Core. For information on using the options pattern in console apps, see [Options pattern in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/options).

## Bind hierarchical configuration

The preferred way to read related configuration values is using the [options pattern](https://learn.microsoft.com/en-us/aspnet/core/options?view=aspnetcore-10.0). For example, to read the following configuration values:

```json
"Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  }
```

Create the following  `PositionOptions`  class:

```csharp
public class PositionOptions
{
    public const string Position = "Position";

    public string Title { get; set; } = String.Empty;
    public string Name { get; set; } = String.Empty;
}
```

An options class:

* Must be non-abstract.
* Has public read-write properties of the type that have corresponding items in config are bound.
* Has its read-write properties bound to matching entries in configuration.
* Does ***not*** have its fields bound. In the preceding code,  `Position`  is not bound. The  `Position`  field is used so the string  `"Position"`  doesn't need to be hard coded in the app when binding the class to a configuration provider.

The following code:

* Calls [ConfigurationBinder.Bind](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder.bind) to bind the  `PositionOptions`  class to the  `Position`  section.
* Displays the  `Position`  configuration data.

```csharp
public class Test22Model : PageModel
{
    private readonly IConfiguration Configuration;

    public Test22Model(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var positionOptions = new PositionOptions();
        Configuration.GetSection(PositionOptions.Position).Bind(positionOptions);

        return Content($"Title: {positionOptions.Title} \n" +
                       $"Name: {positionOptions.Name}");
    }
}
```

In the preceding code, by default, changes to the JSON configuration file after the app has started are read.

[ `ConfigurationBinder.Get<T>` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationbinder.get) binds and returns the specified type.  `ConfigurationBinder.Get<T>`  may be more convenient than using  `ConfigurationBinder.Bind` . The following code shows how to use  `ConfigurationBinder.Get<T>`  with the  `PositionOptions`  class:

```csharp
public class Test21Model : PageModel
{
    private readonly IConfiguration Configuration;
    public PositionOptions? positionOptions { get; private set; }

    public Test21Model(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {            
        positionOptions = Configuration.GetSection(PositionOptions.Position)
                                                     .Get<PositionOptions>();

        return Content($"Title: {positionOptions.Title} \n" +
                       $"Name: {positionOptions.Name}");
    }
}
```

In the preceding code, by default, changes to the JSON configuration file after the app has started are read.

Bind also allows the concretion of an abstract class. Consider the following code which uses the abstract class  `SomethingWithAName` :

```csharp
namespace ConfigSample.Options;

public abstract class SomethingWithAName
{
    public abstract string? Name { get; set; }
}

public class NameTitleOptions(int age) : SomethingWithAName
{
    public const string NameTitle = "NameTitle";

    public override string? Name { get; set; }
    public string Title { get; set; } = string.Empty;

    public int Age { get; set; } = age;
}
```

The following code displays the  `NameTitleOptions`  configuration values:

```csharp
public class Test33Model : PageModel
{
    private readonly IConfiguration Configuration;

    public Test33Model(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public ContentResult OnGet()
    {
        var nameTitleOptions = new NameTitleOptions(22);
        Configuration.GetSection(NameTitleOptions.NameTitle).Bind(nameTitleOptions);

        return Content($"Title: {nameTitleOptions.Title} \n" +
                       $"Name: {nameTitleOptions.Name}  \n" +
                       $"Age: {nameTitleOptions.Age}"
                       );
    }
}
```

Calls to  `Bind`  are less strict than calls to  `Get<>` :

* `Bind`  allows the concretion of an abstract.
* `Get<>`  has to create an instance itself.

## The Options Pattern

An alternative approach when using the ***options pattern*** is to bind the  `Position`  section and add it to the [dependency injection service container](https://learn.microsoft.com/en-us/aspnet/dependency-injection?view=aspnetcore-10.0). In the following code,  `PositionOptions`  is added to the service container with [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsconfigurationservicecollectionextensions.configure) and bound to configuration:

```csharp
using ConfigSample.Options;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<PositionOptions>(
    builder.Configuration.GetSection(PositionOptions.Position));

var app = builder.Build();
```

Using the preceding code, the following code reads the position options:

```csharp
public class Test2Model : PageModel
{
    private readonly PositionOptions _options;

    public Test2Model(IOptions<PositionOptions> options)
    {
        _options = options.Value;
    }

    public ContentResult OnGet()
    {
        return Content($"Title: {_options.Title} \n" +
                       $"Name: {_options.Name}");
    }
}
```

In the preceding code, changes to the JSON configuration file after the app has started are ***not*** read. To read changes after the app has started, use [IOptionsSnapshot](https://learn.microsoft.com/en-us/aspnet/core/options?view=aspnetcore-10.0#ios).

## Options interfaces

[IOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptions-1):

* Does ***not*** support:
  + Reading of configuration data after the app has started.
  + [Named options](https://learn.microsoft.com/en-us/aspnet/core/#named)
* Is registered as a [Singleton](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#singleton) and can be injected into any [service lifetime](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes).

[IOptionsSnapshot<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionssnapshot-1):

* Is useful in scenarios where options should be recomputed on every request. For more information, see [Use IOptionsSnapshot to read updated data](https://learn.microsoft.com/en-us/aspnet/core/#ios).
* Is registered as [Scoped](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) and therefore can't be injected into a Singleton service.
* Supports [named options](https://learn.microsoft.com/en-us/aspnet/core/#named)

[IOptionsMonitor<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitor-1):

* Is used to retrieve options and manage options notifications for  `TOptions`  instances.
* Is registered as a [Singleton](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#singleton) and can be injected into any [service lifetime](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes).
* Supports:
  + Change notifications
  + [named options](https://learn.microsoft.com/en-us/aspnet/core/#named)
  + [Reloadable configuration](https://learn.microsoft.com/en-us/aspnet/core/#ios)
  + Selective options invalidation ([IOptionsMonitorCache<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitorcache-1))

[Post-configuration](https://learn.microsoft.com/en-us/aspnet/core/#options-post-configuration) scenarios enable setting or changing options after all [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) configuration occurs.

[IOptionsFactory<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsfactory-1) is responsible for creating new options instances. It has a single [Create](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsfactory-1.create) method. The default implementation takes all registered [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) and [IPostConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ipostconfigureoptions-1) and runs all the configurations first, followed by the post-configuration. It distinguishes between [IConfigureNamedOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigurenamedoptions-1) and [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) and only calls the appropriate interface.

[IOptionsMonitorCache<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitorcache-1) is used by [IOptionsMonitor<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitor-1) to cache  `TOptions`  instances. The [IOptionsMonitorCache<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitorcache-1) invalidates options instances in the monitor so that the value is recomputed ([TryRemove](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitorcache-1.tryremove)). Values can be manually introduced with [TryAdd](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitorcache-1.tryadd). The [Clear](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitorcache-1.clear) method is used when all named instances should be recreated on demand.

## Use IOptionsSnapshot to read updated data

Using [IOptionsSnapshot<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionssnapshot-1):

* Options are computed once per request when accessed and cached for the lifetime of the request.
* May incur a significant performance penalty because it's a [Scoped service](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) and is recomputed per request. For more information, see [this GitHub issue](https://github.com/dotnet/runtime/issues/53793) and [Improve the performance of configuration binding](https://github.com/dotnet/runtime/issues/36130).
* Changes to the configuration are read after the app starts when using configuration providers that support reading updated configuration values.

The difference between  `IOptionsMonitor`  and  `IOptionsSnapshot`  is that:

* `IOptionsMonitor`  is a [Singleton service](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#singleton) that retrieves current option values at any time, which is especially useful in singleton dependencies.
* `IOptionsSnapshot`  is a [Scoped service](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scoped) and provides a snapshot of the options at the time the  `IOptionsSnapshot<T>`  object is constructed. Options snapshots are designed for use with transient and scoped dependencies.

The following code uses [IOptionsSnapshot<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionssnapshot-1).

```csharp
public class TestSnapModel : PageModel
{
    private readonly MyOptions _snapshotOptions;

    public TestSnapModel(IOptionsSnapshot<MyOptions> snapshotOptionsAccessor)
    {
        _snapshotOptions = snapshotOptionsAccessor.Value;
    }

    public ContentResult OnGet()
    {
        return Content($"Option1: {_snapshotOptions.Option1} \n" +
                       $"Option2: {_snapshotOptions.Option2}");
    }
}
```

The following code registers a configuration instance which  `MyOptions`  binds against:

```csharp
using SampleApp.Models;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<MyOptions>(
    builder.Configuration.GetSection("MyOptions"));

var app = builder.Build();
```

In the preceding code, changes to the JSON configuration file after the app has started are read.

## IOptionsMonitor

The following code registers a configuration instance which  `MyOptions`  binds against.

```csharp
using SampleApp.Models;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<MyOptions>(
    builder.Configuration.GetSection("MyOptions"));

var app = builder.Build();
```

The following example uses [IOptionsMonitor<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitor-1):

```csharp
public class TestMonitorModel : PageModel
{
    private readonly IOptionsMonitor<MyOptions> _optionsDelegate;

    public TestMonitorModel(IOptionsMonitor<MyOptions> optionsDelegate )
    {
        _optionsDelegate = optionsDelegate;
    }

    public ContentResult OnGet()
    {
        return Content($"Option1: {_optionsDelegate.CurrentValue.Option1} \n" +
                       $"Option2: {_optionsDelegate.CurrentValue.Option2}");
    }
}
```

In the preceding code, by default, changes to the JSON configuration file after the app has started are read.

## Specify a custom key name for a configuration property using `ConfigurationKeyName`

By default, the property names of the options class are used as the key name in the configuration source. If the property name is  `Title` , the key name in the configuration is  `Title`  as well.

When the names differentiate, you can use the [ `ConfigurationKeyName`  attribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationkeynameattribute) to specify the key name in the configuration source. Using this technique, you can map a property in the configuration to one in your code with a different name.

This is useful when the property name in the configuration source isn't a valid C# identifier or when you want to use a different name in your code.

For example, consider the following options class:

```csharp
public class PositionOptionsWithConfigurationKeyName
{
    public const string Position = "Position";

    [ConfigurationKeyName("position-title")]
    public string Title { get; set; } = string.Empty;

    [ConfigurationKeyName("position-name")]
    public string Name { get; set; } = string.Empty;
}
```

The  `Title`  and  `Name`  class properties are bound to the  `position-title`  and  `position-name`  from the following  `appsettings.json`  file:

```json
{
  "Position": {
    "position-title": "Editor",
    "position-name": "Joe Smith"
  }
}
```

## Named options support using IConfigureNamedOptions

Named options:

* Are useful when multiple configuration sections bind to the same properties.
* Are case sensitive.

Consider the following  `appsettings.json`  file:

```json
{
  "TopItem": {
    "Month": {
      "Name": "Green Widget",
      "Model": "GW46"
    },
    "Year": {
      "Name": "Orange Gadget",
      "Model": "OG35"
    }
  }
}
```

Rather than creating two classes to bind  `TopItem:Month`  and  `TopItem:Year` , the following class is used for each section:

```csharp
public class TopItemSettings
{
    public const string Month = "Month";
    public const string Year = "Year";

    public string Name { get; set; } = string.Empty;
    public string Model { get; set; } = string.Empty;
}
```

The following code configures the named options:

```csharp
using SampleApp.Models;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<TopItemSettings>(TopItemSettings.Month,
    builder.Configuration.GetSection("TopItem:Month"));
builder.Services.Configure<TopItemSettings>(TopItemSettings.Year,
    builder.Configuration.GetSection("TopItem:Year"));

var app = builder.Build();
```

The following code displays the named options:

```csharp
public class TestNOModel : PageModel
{
    private readonly TopItemSettings _monthTopItem;
    private readonly TopItemSettings _yearTopItem;

    public TestNOModel(IOptionsSnapshot<TopItemSettings> namedOptionsAccessor)
    {
        _monthTopItem = namedOptionsAccessor.Get(TopItemSettings.Month);
        _yearTopItem = namedOptionsAccessor.Get(TopItemSettings.Year);
    }

    public ContentResult OnGet()
    {
        return Content($"Month:Name {_monthTopItem.Name} \n" +
                       $"Month:Model {_monthTopItem.Model} \n\n" +
                       $"Year:Name {_yearTopItem.Name} \n" +
                       $"Year:Model {_yearTopItem.Model} \n"   );
    }
}
```

All options are named instances. [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) instances are treated as targeting the  `Options.DefaultName`  instance, which is  `string.Empty` . [IConfigureNamedOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigurenamedoptions-1) also implements [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1). The default implementation of the [IOptionsFactory<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsfactory-1) has logic to use each appropriately. The  `null`  named option is used to target all of the named instances instead of a specific named instance. [ConfigureAll](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsservicecollectionextensions.configureall) and [PostConfigureAll](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsservicecollectionextensions.postconfigureall) use this convention.

## OptionsBuilder API

[OptionsBuilder<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1) is used to configure  `TOptions`  instances.  `OptionsBuilder`  streamlines creating named options as it's only a single parameter to the initial  `AddOptions<TOptions>(string optionsName)`  call instead of appearing in all of the subsequent calls. Options validation and the  `ConfigureOptions`  overloads that accept service dependencies are only available via  `OptionsBuilder` .

`OptionsBuilder`  is used in the [Options validation](https://learn.microsoft.com/en-us/aspnet/core/#val) section.

See [Use AddOptions to configure custom repository](https://learn.microsoft.com/en-us/security/data-protection/using-data-protection?view=aspnetcore-10.0#add-opt) for information adding a custom repository.

## Use DI services to configure options

Services can be accessed from dependency injection while configuring options in two ways:

* Pass a configuration delegate to [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1.configure) on [OptionsBuilder<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1).  `OptionsBuilder<TOptions>`  provides overloads of [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1.configure) that allow use of up to five services to configure options:

  ```csharp
  builder.Services.AddOptions<MyOptions>("optionalName")
      .Configure<Service1, Service2, Service3, Service4, Service5>(
          (o, s, s2, s3, s4, s5) => 
              o.Property = DoSomethingWith(s, s2, s3, s4, s5));
  ```
* Create a type that implements [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) or [IConfigureNamedOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigurenamedoptions-1) and register the type as a service.

We recommend passing a configuration delegate to [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1.configure), since creating a service is more complex. Creating a type is equivalent to what the framework does when calling [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1.configure). Calling [Configure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1.configure) registers a transient generic [IConfigureNamedOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigurenamedoptions-1), which has a constructor that accepts the generic service types specified.

## Options validation

Options validation enables option values to be validated.

Consider the following  `appsettings.json`  file:

```json
{
  "MyConfig": {
    "Key1": "My Key One",
    "Key2": 10,
    "Key3": 32
  }
}
```

The following class is used to bind to the  `"MyConfig"`  configuration section and applies a couple of  `DataAnnotations`  rules:

```csharp
public class MyConfigOptions
{
    public const string MyConfig = "MyConfig";

    [RegularExpression(@"^[a-zA-Z''-'\s]{1,40}$")]
    public string Key1 { get; set; }
    [Range(0, 1000,
        ErrorMessage = "Value for {0} must be between {1} and {2}.")]
    public int Key2 { get; set; }
    public int Key3 { get; set; }
}
```

The following code:

* Calls [AddOptions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsservicecollectionextensions.addoptions) to get an [OptionsBuilder<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsbuilder-1) that binds to the  `MyConfigOptions`  class.
* Calls [ValidateDataAnnotations](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsbuilderdataannotationsextensions.validatedataannotations) to enable validation using  `DataAnnotations` .

```csharp
using OptionsValidationSample.Configuration;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.AddOptions<MyConfigOptions>()
            .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig))
            .ValidateDataAnnotations();

var app = builder.Build();
```

The  `ValidateDataAnnotations`  extension method is defined in the [Microsoft.Extensions.Options.DataAnnotations](https://www.nuget.org/packages/Microsoft.Extensions.Options.DataAnnotations) NuGet package. For web apps that use the  `Microsoft.NET.Sdk.Web`  SDK, this package is referenced implicitly from the shared framework.

The following code displays the configuration values or the validation errors:

```csharp
public class HomeController : Controller
{
    private readonly ILogger<HomeController> _logger;
    private readonly IOptions<MyConfigOptions> _config;

    public HomeController(IOptions<MyConfigOptions> config,
                          ILogger<HomeController> logger)
    {
        _config = config;
        _logger = logger;

        try
        {
            var configValue = _config.Value;

        }
        catch (OptionsValidationException ex)
        {
            foreach (var failure in ex.Failures)
            {
                _logger.LogError(failure);
            }
        }
    }

    public ContentResult Index()
    {
        string msg;
        try
        {
            msg = $"Key1: {_config.Value.Key1} \n" +
                  $"Key2: {_config.Value.Key2} \n" +
                  $"Key3: {_config.Value.Key3}";
        }
        catch (OptionsValidationException optValEx)
        {
            return Content(optValEx.Message);
        }
        return Content(msg);
    }
```

The following code applies a more complex validation rule using a delegate:

```csharp
using OptionsValidationSample.Configuration;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.AddOptions<MyConfigOptions>()
            .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig))
            .ValidateDataAnnotations()
        .Validate(config =>
        {
            if (config.Key2 != 0)
            {
                return config.Key3 > config.Key2;
            }

            return true;
        }, "Key3 must be > than Key2.");   // Failure message.

var app = builder.Build();
```

### `IValidateOptions<TOptions>` and `IValidatableObject`

The following class implements [IValidateOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ivalidateoptions-1):

```csharp
public class MyConfigValidation : IValidateOptions<MyConfigOptions>
{
    public MyConfigOptions _config { get; private set; }

    public  MyConfigValidation(IConfiguration config)
    {
        _config = config.GetSection(MyConfigOptions.MyConfig)
            .Get<MyConfigOptions>();
    }

    public ValidateOptionsResult Validate(string name, MyConfigOptions options)
    {
        string? vor = null;
        var rx = new Regex(@"^[a-zA-Z''-'\s]{1,40}$");
        var match = rx.Match(options.Key1!);

        if (string.IsNullOrEmpty(match.Value))
        {
            vor = $"{options.Key1} doesn't match RegEx \n";
        }

        if ( options.Key2 < 0 || options.Key2 > 1000)
        {
            vor = $"{options.Key2} doesn't match Range 0 - 1000 \n";
        }

        if (_config.Key2 != default)
        {
            if(_config.Key3 <= _config.Key2)
            {
                vor +=  "Key3 must be > than Key2.";
            }
        }

        if (vor != null)
        {
            return ValidateOptionsResult.Fail(vor);
        }

        return ValidateOptionsResult.Success;
    }
}
```

`IValidateOptions`  enables moving the validation code out of  `Program.cs`  and into a class.

Using the preceding code, validation is enabled in  `Program.cs`  with the following code:

```csharp
using Microsoft.Extensions.Options;
using OptionsValidationSample.Configuration;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.Configure<MyConfigOptions>(builder.Configuration.GetSection(
                                        MyConfigOptions.MyConfig));

builder.Services.AddSingleton<IValidateOptions
                              <MyConfigOptions>, MyConfigValidation>();

var app = builder.Build();
```

Options validation also supports [IValidatableObject](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.ivalidatableobject). To perform class-level validation of a class within the class itself:

* Implement the  `IValidatableObject`  interface and its [Validate](https://learn.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.ivalidatableobject.validate) method within the class.
* Call [ValidateDataAnnotations](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsbuilderdataannotationsextensions.validatedataannotations) in  `Program.cs` .

### `ValidateOnStart`

Options validation runs the first time a  `TOption`  instance is created. That means, for instance, when first
access to [ `IOptionsSnapshot<TOptions>.Value` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionssnapshot-1) occurs in a request pipeline or when
[ `IOptionsMonitor<TOptions>.Get(string)` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionsmonitor-1.get#microsoft-extensions-options-optionsmonitor-1-get(system-string)) is called on settings present. After settings are reloaded, validation runs again. The ASP.NET Core runtime uses [OptionsCache<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.optionscache-1) to cache the options instance once it is created.

To run options validation eagerly, when the app starts, call [ValidateOnStart<TOptions>(OptionsBuilder<TOptions>)](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsbuilderextensions.validateonstart#microsoft-extensions-dependencyinjection-optionsbuilderextensions-validateonstart-1(microsoft-extensions-options-optionsbuilder((-0))))in  `Program.cs` :

```csharp
builder.Services.AddOptions<MyConfigOptions>()
    .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig))
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

## Options post-configuration

Set post-configuration with [IPostConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ipostconfigureoptions-1). Post-configuration runs after all [IConfigureOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.iconfigureoptions-1) configuration occurs:

```csharp
using OptionsValidationSample.Configuration;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.AddOptions<MyConfigOptions>()
                .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig));

builder.Services.PostConfigure<MyConfigOptions>(myOptions =>
{
    myOptions.Key1 = "post_configured_key1_value";
});
```

[PostConfigure](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ipostconfigureoptions-1.postconfigure) is available to post-configure named options:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();

builder.Services.Configure<TopItemSettings>(TopItemSettings.Month,
    builder.Configuration.GetSection("TopItem:Month"));
builder.Services.Configure<TopItemSettings>(TopItemSettings.Year,
    builder.Configuration.GetSection("TopItem:Year"));

builder.Services.PostConfigure<TopItemSettings>("Month", myOptions =>
{
    myOptions.Name = "post_configured_name_value";
    myOptions.Model = "post_configured_model_value";
});

var app = builder.Build();
```

Use [PostConfigureAll](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.optionsservicecollectionextensions.postconfigureall) to post-configure all configuration instances:

```csharp
using OptionsValidationSample.Configuration;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

builder.Services.AddOptions<MyConfigOptions>()
                .Bind(builder.Configuration.GetSection(MyConfigOptions.MyConfig));

builder.Services.PostConfigureAll<MyConfigOptions>(myOptions =>
{
    myOptions.Key1 = "post_configured_key1_value";
});
```

## Access options in `Program.cs`

To access [IOptions<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptions-1) or [IOptionsMonitor<TOptions>](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.options.ioptionsmonitor-1) in  `Program.cs` , call [GetRequiredService](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.serviceproviderserviceextensions.getrequiredservice) on [WebApplication.Services](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.webapplication.services):

```csharp
var app = builder.Build();

var option1 = app.Services.GetRequiredService<IOptionsMonitor<MyOptions>>()
    .CurrentValue.Option1;
```