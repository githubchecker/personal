# HTTP logging in ASP.NET Core

HTTP logging is a middleware that logs information about incoming HTTP requests and HTTP responses. HTTP logging provides logs of:

* HTTP request information
* Common properties
* Headers
* Body
* HTTP response information

HTTP logging can:

* Log all requests and responses or only requests and responses that meet certain criteria.
* Select which parts of the request and response are logged.
* Allow you to redact sensitive information from the logs.

HTTP logging ***can reduce the performance of an app***, especially when logging the request and response bodies. Consider the performance impact when selecting fields to log. Test the performance impact of the selected logging properties.

> [!WARNING]
> HTTP logging can potentially log personally identifiable information (PII). Consider the risk and avoid logging sensitive information.
> For more information about redaction, check [redacting sensitive data](https://learn.microsoft.com/en-us/aspnet/core/#redacting-sensitive-data)

## Enable HTTP logging

HTTP logging is enabled by calling [AddHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httploggingservicesextensions.addhttplogging) and [UseHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httploggingbuilderextensions.usehttplogging), as shown in the following example:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Hello World!");

app.Run();
```

The empty lambda in the preceding example of calling  `AddHttpLogging`  adds the middleware with the default configuration. By default, HTTP logging logs common properties such as path, status-code, and headers for requests and responses.

Add the following line to the  `appsettings.Development.json`  file at the  `"LogLevel": {`  level so the HTTP logs are displayed:

```json
"Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware": "Information"
```

With the default configuration, a request and response is logged as a pair of messages similar to the following example:

```output
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]
      Request:
      Protocol: HTTP/2
      Method: GET
      Scheme: https
      PathBase:
      Path: /
      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
      Host: localhost:52941
      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36 Edg/118.0.2088.61
      Accept-Encoding: gzip, deflate, br
      Accept-Language: en-US,en;q=0.9
      Upgrade-Insecure-Requests: [Redacted]
      sec-ch-ua: [Redacted]
      sec-ch-ua-mobile: [Redacted]
      sec-ch-ua-platform: [Redacted]
      sec-fetch-site: [Redacted]
      sec-fetch-mode: [Redacted]
      sec-fetch-user: [Redacted]
      sec-fetch-dest: [Redacted]
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]
      Response:
      StatusCode: 200
      Content-Type: text/plain; charset=utf-8
      Date: Tue, 24 Oct 2023 02:03:53 GMT
      Server: Kestrel
```

## HTTP logging options

To configure global options for the HTTP logging middleware, call [AddHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httploggingservicesextensions.addhttplogging) in  `Program.cs` , using the lambda to configure [HttpLoggingOptions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions).

```csharp
using Microsoft.AspNetCore.HttpLogging;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.All;
    logging.RequestHeaders.Add("sec-ch-ua");
    logging.ResponseHeaders.Add("MyResponseHeader");
    logging.MediaTypeOptions.AddText("application/javascript");
    logging.RequestBodyLogLimit = 4096;
    logging.ResponseBodyLogLimit = 4096;
    logging.CombineLogs = true;
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();

app.UseHttpLogging();

app.Use(async (context, next) =>
{
    context.Response.Headers["MyResponseHeader"] =
        new string[] { "My Response Header Value" };

    await next();
});

app.MapGet("/", () => "Hello World!");

app.Run();
```

> [!NOTE]
> In the preceding sample and following samples,  `UseHttpLogging`  is called after  `UseStaticFiles` , so HTTP logging isn't enabled for static files. To enable static file HTTP logging, call  `UseHttpLogging`  before  `UseStaticFiles` .

### `LoggingFields`

[ `HttpLoggingOptions.LoggingFields` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.loggingfields#microsoft-aspnetcore-httplogging-httploggingoptions-loggingfields) is an enum flag that configures specific parts of the request and response to log.  `LoggingFields`  defaults to [RequestPropertiesAndHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingfields#microsoft-aspnetcore-httplogging-httploggingfields-requestpropertiesandheaders) | [ResponsePropertiesAndHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingfields#microsoft-aspnetcore-httplogging-httploggingfields-responsepropertiesandheaders).

### `RequestHeaders` and `ResponseHeaders`

[RequestHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.requestheaders#microsoft-aspnetcore-httplogging-httploggingoptions-requestheaders) and [ResponseHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.responseheaders#microsoft-aspnetcore-httplogging-httploggingoptions-responseheaders) are sets of HTTP headers that are logged. Header values are only logged for header names that are in these collections. The following code adds  `sec-ch-ua`  to the [RequestHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.requestheaders#microsoft-aspnetcore-httplogging-httploggingoptions-requestheaders), so the value of the  `sec-ch-ua`  header is logged. And it adds  `MyResponseHeader`  to the [ResponseHeaders](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.responseheaders#microsoft-aspnetcore-httplogging-httploggingoptions-responseheaders), so the value of the  `MyResponseHeader`  header is logged. If these lines are removed, the values of these headers are  `[Redacted]` .

```csharp
using Microsoft.AspNetCore.HttpLogging;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.All;
    logging.RequestHeaders.Add("sec-ch-ua");
    logging.ResponseHeaders.Add("MyResponseHeader");
    logging.MediaTypeOptions.AddText("application/javascript");
    logging.RequestBodyLogLimit = 4096;
    logging.ResponseBodyLogLimit = 4096;
    logging.CombineLogs = true;
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();

app.UseHttpLogging();

app.Use(async (context, next) =>
{
    context.Response.Headers["MyResponseHeader"] =
        new string[] { "My Response Header Value" };

    await next();
});

app.MapGet("/", () => "Hello World!");

app.Run();
```

### `MediaTypeOptions`

[MediaTypeOptions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.mediatypeoptions#microsoft-aspnetcore-httplogging-httploggingoptions-mediatypeoptions) provides configuration for selecting which encoding to use for a specific media type.

```csharp
using Microsoft.AspNetCore.HttpLogging;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.All;
    logging.RequestHeaders.Add("sec-ch-ua");
    logging.ResponseHeaders.Add("MyResponseHeader");
    logging.MediaTypeOptions.AddText("application/javascript");
    logging.RequestBodyLogLimit = 4096;
    logging.ResponseBodyLogLimit = 4096;
    logging.CombineLogs = true;
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();

app.UseHttpLogging();

app.Use(async (context, next) =>
{
    context.Response.Headers["MyResponseHeader"] =
        new string[] { "My Response Header Value" };

    await next();
});

app.MapGet("/", () => "Hello World!");

app.Run();
```

This approach can also be used to enable logging for data that isn't logged by default (for example, form data, which might have a media type such as  `application/x-www-form-urlencoded`  or  `multipart/form-data` ).

#### `MediaTypeOptions` methods

* [AddText](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.mediatypeoptions.addtext)
* [AddBinary](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.mediatypeoptions.addbinary)
* [Clear](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.mediatypeoptions.clear)

### `RequestBodyLogLimit` and `ResponseBodyLogLimit`

* [RequestBodyLogLimit](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.requestbodyloglimit#microsoft-aspnetcore-httplogging-httploggingoptions-requestbodyloglimit)
* [ResponseBodyLogLimit](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.responsebodyloglimit#microsoft-aspnetcore-httplogging-httploggingoptions-responsebodyloglimit)

```csharp
using Microsoft.AspNetCore.HttpLogging;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.All;
    logging.RequestHeaders.Add("sec-ch-ua");
    logging.ResponseHeaders.Add("MyResponseHeader");
    logging.MediaTypeOptions.AddText("application/javascript");
    logging.RequestBodyLogLimit = 4096;
    logging.ResponseBodyLogLimit = 4096;
    logging.CombineLogs = true;
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();

app.UseHttpLogging();

app.Use(async (context, next) =>
{
    context.Response.Headers["MyResponseHeader"] =
        new string[] { "My Response Header Value" };

    await next();
});

app.MapGet("/", () => "Hello World!");

app.Run();
```

### `CombineLogs`

Setting [CombineLogs](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions.combinelogs#microsoft-aspnetcore-httplogging-httploggingoptions-combinelogs) to  `true`  configures the middleware to consolidate all of its enabled logs for a request and response into one log at the end. This includes the request, request body, response, response body, and duration.

```csharp
using Microsoft.AspNetCore.HttpLogging;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.All;
    logging.RequestHeaders.Add("sec-ch-ua");
    logging.ResponseHeaders.Add("MyResponseHeader");
    logging.MediaTypeOptions.AddText("application/javascript");
    logging.RequestBodyLogLimit = 4096;
    logging.ResponseBodyLogLimit = 4096;
    logging.CombineLogs = true;
});

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}

app.UseStaticFiles();

app.UseHttpLogging();

app.Use(async (context, next) =>
{
    context.Response.Headers["MyResponseHeader"] =
        new string[] { "My Response Header Value" };

    await next();
});

app.MapGet("/", () => "Hello World!");

app.Run();
```

## Endpoint-specific configuration

For endpoint-specific configuration in Minimal API apps, a [WithHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httploggingendpointconventionbuilderextensions.withhttplogging) extension method is available. The following example shows how to configure HTTP logging for one endpoint:

```csharp
app.MapGet("/response", () => "Hello World! (logging response)")
    .WithHttpLogging(HttpLoggingFields.ResponsePropertiesAndHeaders);
```

For endpoint-specific configuration in apps that use controllers, the [ `[HttpLogging]`  attribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingattribute) is available. The attribute can also be used in Minimal API apps, as shown in the following example:

```csharp
app.MapGet("/duration", [HttpLogging(loggingFields: HttpLoggingFields.Duration)]
    () => "Hello World! (logging duration)");
```

## `IHttpLoggingInterceptor`

[IHttpLoggingInterceptor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.ihttplogginginterceptor) is the interface for a service that can be implemented to handle per-request and per-response callbacks for customizing what details get logged. Any endpoint-specific log settings are applied first and can then be overridden in these callbacks. An implementation can:

* Inspect a request or response.
* Enable or disable any [HttpLoggingFields](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingfields).
* Adjust how much of the request or response body is logged.
* Add custom fields to the logs.

Register an [IHttpLoggingInterceptor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.ihttplogginginterceptor) implementation by calling [AddHttpLoggingInterceptor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httploggingservicesextensions.addhttplogginginterceptor) in  `Program.cs` . If multiple [IHttpLoggingInterceptor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.ihttplogginginterceptor) instances are registered, they're run in the order registered.

The following example shows how to register an [IHttpLoggingInterceptor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.ihttplogginginterceptor) implementation:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.Duration;
});
builder.Services.AddHttpLoggingInterceptor<SampleHttpLoggingInterceptor>();
```

The following example is an [IHttpLoggingInterceptor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.ihttplogginginterceptor) implementation that:

* Inspects the request method and disables logging for POST requests.
* For non-POST requests:
  + Redacts request path, request headers, and response headers.
  + Adds custom fields and field values to the request and response logs.

```csharp
using Microsoft.AspNetCore.HttpLogging;

namespace HttpLoggingSample;

internal sealed class SampleHttpLoggingInterceptor : IHttpLoggingInterceptor
{
    public ValueTask OnRequestAsync(HttpLoggingInterceptorContext logContext)
    {
        if (logContext.HttpContext.Request.Method == "POST")
        {
            // Don't log anything if the request is a POST.
            logContext.LoggingFields = HttpLoggingFields.None;
        }

        // Don't enrich if we're not going to log any part of the request.
        if (!logContext.IsAnyEnabled(HttpLoggingFields.Request))
        {
            return default;
        }

        if (logContext.TryDisable(HttpLoggingFields.RequestPath))
        {
            RedactPath(logContext);
        }

        if (logContext.TryDisable(HttpLoggingFields.RequestHeaders))
        {
            RedactRequestHeaders(logContext);
        }

        EnrichRequest(logContext);

        return default;
    }

    public ValueTask OnResponseAsync(HttpLoggingInterceptorContext logContext)
    {
        // Don't enrich if we're not going to log any part of the response
        if (!logContext.IsAnyEnabled(HttpLoggingFields.Response))
        {
            return default;
        }

        if (logContext.TryDisable(HttpLoggingFields.ResponseHeaders))
        {
            RedactResponseHeaders(logContext);
        }

        EnrichResponse(logContext);

        return default;
    }

    private void RedactPath(HttpLoggingInterceptorContext logContext)
    {
        logContext.AddParameter(nameof(logContext.HttpContext.Request.Path), "RedactedPath");
    }

    private void RedactRequestHeaders(HttpLoggingInterceptorContext logContext)
    {
        foreach (var header in logContext.HttpContext.Request.Headers)
        {
            logContext.AddParameter(header.Key, "RedactedHeader");
        }
    }

    private void EnrichRequest(HttpLoggingInterceptorContext logContext)
    {
        logContext.AddParameter("RequestEnrichment", "Stuff");
    }

    private void RedactResponseHeaders(HttpLoggingInterceptorContext logContext)
    {
        foreach (var header in logContext.HttpContext.Response.Headers)
        {
            logContext.AddParameter(header.Key, "RedactedHeader");
        }
    }

    private void EnrichResponse(HttpLoggingInterceptorContext logContext)
    {
        logContext.AddParameter("ResponseEnrichment", "Stuff");
    }
}
```

With this interceptor, a POST request doesn't generate any logs even if HTTP logging is configured to log [ `HttpLoggingFields.All` ](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingfields). A GET request generates logs similar to the following example:

```output
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]
      Request:
      Path: RedactedPath
      Accept: RedactedHeader
      Host: RedactedHeader
      User-Agent: RedactedHeader
      Accept-Encoding: RedactedHeader
      Accept-Language: RedactedHeader
      Upgrade-Insecure-Requests: RedactedHeader
      sec-ch-ua: RedactedHeader
      sec-ch-ua-mobile: RedactedHeader
      sec-ch-ua-platform: RedactedHeader
      sec-fetch-site: RedactedHeader
      sec-fetch-mode: RedactedHeader
      sec-fetch-user: RedactedHeader
      sec-fetch-dest: RedactedHeader
      RequestEnrichment: Stuff
      Protocol: HTTP/2
      Method: GET
      Scheme: https
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]
      Response:
      Content-Type: RedactedHeader
      MyResponseHeader: RedactedHeader
      ResponseEnrichment: Stuff
      StatusCode: 200
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[4]
      ResponseBody: Hello World!
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[8]
      Duration: 2.2778ms
```

## Logging configuration order of precedence

The following list shows the order of precedence for logging configuration:

1. Global configuration from [HttpLoggingOptions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingoptions), set by calling [AddHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httploggingservicesextensions.addhttplogging).
2. Endpoint-specific configuration from the [ `[HttpLogging]`  attribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.httplogging.httploggingattribute) or the [WithHttpLogging](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.httploggingendpointconventionbuilderextensions.withhttplogging) extension method overrides global configuration.
3. [ `IHttpLoggingInterceptor` ](https://learn.microsoft.com/en-us/aspnet/core/#ihttplogginginterceptor) is called with the results and can further modify the configuration per request.

## Redacting sensitive data

Http logging with redaction can be enabled by calling [AddHttpLoggingRedaction](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httploggingservicecollectionextensions.addhttploggingredaction):

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(logging =>
{
    logging.LoggingFields = HttpLoggingFields.Duration;
});

builder.Services.AddRedaction();
builder.Services.AddHttpLoggingRedaction(op => { });
```

For more information about .NET's data redaction library, see [Data redaction in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/data-redaction).

## Logging redaction options

To configure options for logging with redaction, call [AddHttpLoggingRedaction](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.httploggingservicecollectionextensions.addhttploggingredaction) in  `Program.cs`  using the lambda to configure [LoggingRedactionOptions](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions):

```csharp
using Microsoft.Extensions.Compliance.Classification;

namespace HttpLoggingSample
{
    public static class MyTaxonomyClassifications
    {
        public static string Name => "MyTaxonomy";

        public static DataClassification Private => new(Name, nameof(Private));
        public static DataClassification Public => new(Name, nameof(Public));
        public static DataClassification Personal => new(Name, nameof(Personal));
    }
}
```

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

With the previous redaction configuration, the output is similar to the following:

```output
info: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[9]
      Request and Response:
      server.address: localhost:61361
      Path: /
      http.request.header.accept:
      Protocol: HTTP/2
      Method: GET
      Scheme: https
      http.response.header.content-type:
      StatusCode: 200
      Duration: 8.4684
info: Microsoft.AspNetCore.Hosting.Diagnostics[2]
      Request finished HTTP/2 GET https://localhost:61361/ - 200 - text/plain;+charset=utf-8 105.5334ms
```

> [!NOTE]
> Request path  `/home`  isn't logged because it's included in the [ `ExcludePathStartsWith`  property](https://learn.microsoft.com/en-us/aspnet/core/#excludepathstartswith).  `http.request.header.accept`  and  `http.response.header.content-type`  were redacted by [Microsoft.Extensions.Compliance.Redaction.ErasingRedactor](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.compliance.redaction.erasingredactor).

### `RequestPathLoggingMode`

[RequestPathLoggingMode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.requestpathloggingmode) determines how the request path is logged, whether  `Formatted`  or  `Structured` , set by [IncomingPathLoggingMode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.incomingpathloggingmode):

* `Formatted` : Logs the request path without parameters.
* `Structured` : Logs the request path with parameters included.

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

### `RequestPathParameterRedactionMode`

[RequestPathParameterRedactionMode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.requestpathparameterredactionmode)
specifies how route parameters in the request path should be redacted, whether  `Strict` ,  `Loose` , or  `None` , set by [HttpRouteParameterRedactionMode](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.http.diagnostics.httprouteparameterredactionmode):

* `Strict` : Request route parameters are considered sensitive, require explicit annotation with a data classification, and are redacted by default.
* `Loose` : All parameters are considered as non-sensitive and included as-is by default.
* `None` : Route parameters aren't redacted regardless of the presence of data classification annotations.

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

### `RequestHeadersDataClasses`

[RequestHeadersDataClasses](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.requestheadersdataclasses) maps request headers to their data classification, which determines how they are redacted:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

### `ResponseHeadersDataClasses`

[ResponseHeadersDataClasses](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.responseheadersdataclasses), similar to [RequestHeadersDataClasses](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.requestheadersdataclasses)`, but for response headers:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

### `RouteParameterDataClasses`

[RouteParameterDataClasses](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.routeparameterdataclasses) maps route parameters to their data classification:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

### `ExcludePathStartsWith`

[ExcludePathStartsWith](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.excludepathstartswith) specifies paths that should be excluded from logging entirely:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```

### `IncludeUnmatchedRoutes`

[IncludeUnmatchedRoutes](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.diagnostics.logging.loggingredactionoptions.includeunmatchedroutes) allows reporting unmatched routes. If set to  `true` , logs whole path of routes not identified by [Routing](https://learn.microsoft.com/en-us/aspnet/routing?view=aspnetcore-10.0) instead of logging  `Unknown`  value for path attribute:

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddHttpLogging(o => { });
builder.Services.AddRedaction();

builder.Services.AddHttpLoggingRedaction(op =>
{
    op.RequestPathParameterRedactionMode = HttpRouteParameterRedactionMode.None;
    op.RequestPathLoggingMode = IncomingPathLoggingMode.Formatted;
    op.RequestHeadersDataClasses.Add(HeaderNames.Accept, MyTaxonomyClassifications.Public);
    op.ResponseHeadersDataClasses.Add(HeaderNames.ContentType, MyTaxonomyClassifications.Private);
    op.RouteParameterDataClasses = new Dictionary<string, DataClassification>
    {
        { "one", MyTaxonomyClassifications.Personal },
    };
    // Add the paths that should be filtered, with a leading '/'.
    op.ExcludePathStartsWith.Add("/home");
    op.IncludeUnmatchedRoutes = true;
});

var app = builder.Build();

app.UseHttpLogging();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.MapGet("/", () => "Logged!");
app.MapGet("/home", () => "Not logged!");

app.Run();
```